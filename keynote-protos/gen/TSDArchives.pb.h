// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSDArchives.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_TSDArchives_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_TSDArchives_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSKArchives.pb.h"
#include "TSSArchives.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TSDArchives_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_TSDArchives_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[80]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_TSDArchives_2eproto;
namespace TSD {
class AngleGradientArchive;
struct AngleGradientArchiveDefaultTypeInternal;
extern AngleGradientArchiveDefaultTypeInternal _AngleGradientArchive_default_instance_;
class Attribution;
struct AttributionDefaultTypeInternal;
extern AttributionDefaultTypeInternal _Attribution_default_instance_;
class BezierPathSourceArchive;
struct BezierPathSourceArchiveDefaultTypeInternal;
extern BezierPathSourceArchiveDefaultTypeInternal _BezierPathSourceArchive_default_instance_;
class CalloutPathSourceArchive;
struct CalloutPathSourceArchiveDefaultTypeInternal;
extern CalloutPathSourceArchiveDefaultTypeInternal _CalloutPathSourceArchive_default_instance_;
class CanvasSelectionArchive;
struct CanvasSelectionArchiveDefaultTypeInternal;
extern CanvasSelectionArchiveDefaultTypeInternal _CanvasSelectionArchive_default_instance_;
class CommentStorageArchive;
struct CommentStorageArchiveDefaultTypeInternal;
extern CommentStorageArchiveDefaultTypeInternal _CommentStorageArchive_default_instance_;
class ConnectionLineArchive;
struct ConnectionLineArchiveDefaultTypeInternal;
extern ConnectionLineArchiveDefaultTypeInternal _ConnectionLineArchive_default_instance_;
class ConnectionLinePathSourceArchive;
struct ConnectionLinePathSourceArchiveDefaultTypeInternal;
extern ConnectionLinePathSourceArchiveDefaultTypeInternal _ConnectionLinePathSourceArchive_default_instance_;
class ContactShadowArchive;
struct ContactShadowArchiveDefaultTypeInternal;
extern ContactShadowArchiveDefaultTypeInternal _ContactShadowArchive_default_instance_;
class ContainerArchive;
struct ContainerArchiveDefaultTypeInternal;
extern ContainerArchiveDefaultTypeInternal _ContainerArchive_default_instance_;
class CurvedShadowArchive;
struct CurvedShadowArchiveDefaultTypeInternal;
extern CurvedShadowArchiveDefaultTypeInternal _CurvedShadowArchive_default_instance_;
class DrawableArchive;
struct DrawableArchiveDefaultTypeInternal;
extern DrawableArchiveDefaultTypeInternal _DrawableArchive_default_instance_;
class DrawableContentDescription;
struct DrawableContentDescriptionDefaultTypeInternal;
extern DrawableContentDescriptionDefaultTypeInternal _DrawableContentDescription_default_instance_;
class DrawableSelectionArchive;
struct DrawableSelectionArchiveDefaultTypeInternal;
extern DrawableSelectionArchiveDefaultTypeInternal _DrawableSelectionArchive_default_instance_;
class DropShadowArchive;
struct DropShadowArchiveDefaultTypeInternal;
extern DropShadowArchiveDefaultTypeInternal _DropShadowArchive_default_instance_;
class EdgeInsetsArchive;
struct EdgeInsetsArchiveDefaultTypeInternal;
extern EdgeInsetsArchiveDefaultTypeInternal _EdgeInsetsArchive_default_instance_;
class EditableBezierPathSourceArchive;
struct EditableBezierPathSourceArchiveDefaultTypeInternal;
extern EditableBezierPathSourceArchiveDefaultTypeInternal _EditableBezierPathSourceArchive_default_instance_;
class EditableBezierPathSourceArchive_Node;
struct EditableBezierPathSourceArchive_NodeDefaultTypeInternal;
extern EditableBezierPathSourceArchive_NodeDefaultTypeInternal _EditableBezierPathSourceArchive_Node_default_instance_;
class EditableBezierPathSourceArchive_Subpath;
struct EditableBezierPathSourceArchive_SubpathDefaultTypeInternal;
extern EditableBezierPathSourceArchive_SubpathDefaultTypeInternal _EditableBezierPathSourceArchive_Subpath_default_instance_;
class ExteriorTextWrapArchive;
struct ExteriorTextWrapArchiveDefaultTypeInternal;
extern ExteriorTextWrapArchiveDefaultTypeInternal _ExteriorTextWrapArchive_default_instance_;
class FillArchive;
struct FillArchiveDefaultTypeInternal;
extern FillArchiveDefaultTypeInternal _FillArchive_default_instance_;
class FrameArchive;
struct FrameArchiveDefaultTypeInternal;
extern FrameArchiveDefaultTypeInternal _FrameArchive_default_instance_;
class FreehandDrawingAnimationArchive;
struct FreehandDrawingAnimationArchiveDefaultTypeInternal;
extern FreehandDrawingAnimationArchiveDefaultTypeInternal _FreehandDrawingAnimationArchive_default_instance_;
class FreehandDrawingArchive;
struct FreehandDrawingArchiveDefaultTypeInternal;
extern FreehandDrawingArchiveDefaultTypeInternal _FreehandDrawingArchive_default_instance_;
class FreehandDrawingContentDescription;
struct FreehandDrawingContentDescriptionDefaultTypeInternal;
extern FreehandDrawingContentDescriptionDefaultTypeInternal _FreehandDrawingContentDescription_default_instance_;
class FreehandDrawingToolkitUIState;
struct FreehandDrawingToolkitUIStateDefaultTypeInternal;
extern FreehandDrawingToolkitUIStateDefaultTypeInternal _FreehandDrawingToolkitUIState_default_instance_;
class GeometryArchive;
struct GeometryArchiveDefaultTypeInternal;
extern GeometryArchiveDefaultTypeInternal _GeometryArchive_default_instance_;
class GradientArchive;
struct GradientArchiveDefaultTypeInternal;
extern GradientArchiveDefaultTypeInternal _GradientArchive_default_instance_;
class GradientArchive_GradientStop;
struct GradientArchive_GradientStopDefaultTypeInternal;
extern GradientArchive_GradientStopDefaultTypeInternal _GradientArchive_GradientStop_default_instance_;
class GroupArchive;
struct GroupArchiveDefaultTypeInternal;
extern GroupArchiveDefaultTypeInternal _GroupArchive_default_instance_;
class GroupSelectionArchive;
struct GroupSelectionArchiveDefaultTypeInternal;
extern GroupSelectionArchiveDefaultTypeInternal _GroupSelectionArchive_default_instance_;
class GuideArchive;
struct GuideArchiveDefaultTypeInternal;
extern GuideArchiveDefaultTypeInternal _GuideArchive_default_instance_;
class GuideStorageArchive;
struct GuideStorageArchiveDefaultTypeInternal;
extern GuideStorageArchiveDefaultTypeInternal _GuideStorageArchive_default_instance_;
class ImageAdjustmentsArchive;
struct ImageAdjustmentsArchiveDefaultTypeInternal;
extern ImageAdjustmentsArchiveDefaultTypeInternal _ImageAdjustmentsArchive_default_instance_;
class ImageArchive;
struct ImageArchiveDefaultTypeInternal;
extern ImageArchiveDefaultTypeInternal _ImageArchive_default_instance_;
class ImageDataAttributes;
struct ImageDataAttributesDefaultTypeInternal;
extern ImageDataAttributesDefaultTypeInternal _ImageDataAttributes_default_instance_;
class ImageFillArchive;
struct ImageFillArchiveDefaultTypeInternal;
extern ImageFillArchiveDefaultTypeInternal _ImageFillArchive_default_instance_;
class InfoHyperlinkSelectionArchive;
struct InfoHyperlinkSelectionArchiveDefaultTypeInternal;
extern InfoHyperlinkSelectionArchiveDefaultTypeInternal _InfoHyperlinkSelectionArchive_default_instance_;
class LineEndArchive;
struct LineEndArchiveDefaultTypeInternal;
extern LineEndArchiveDefaultTypeInternal _LineEndArchive_default_instance_;
class MaskArchive;
struct MaskArchiveDefaultTypeInternal;
extern MaskArchiveDefaultTypeInternal _MaskArchive_default_instance_;
class MediaStyleArchive;
struct MediaStyleArchiveDefaultTypeInternal;
extern MediaStyleArchiveDefaultTypeInternal _MediaStyleArchive_default_instance_;
class MediaStylePropertiesArchive;
struct MediaStylePropertiesArchiveDefaultTypeInternal;
extern MediaStylePropertiesArchiveDefaultTypeInternal _MediaStylePropertiesArchive_default_instance_;
class MovieArchive;
struct MovieArchiveDefaultTypeInternal;
extern MovieArchiveDefaultTypeInternal _MovieArchive_default_instance_;
class MovieFingerprint;
struct MovieFingerprintDefaultTypeInternal;
extern MovieFingerprintDefaultTypeInternal _MovieFingerprint_default_instance_;
class MovieFingerprintTrack;
struct MovieFingerprintTrackDefaultTypeInternal;
extern MovieFingerprintTrackDefaultTypeInternal _MovieFingerprintTrack_default_instance_;
class PathSelectionArchive;
struct PathSelectionArchiveDefaultTypeInternal;
extern PathSelectionArchiveDefaultTypeInternal _PathSelectionArchive_default_instance_;
class PathSourceArchive;
struct PathSourceArchiveDefaultTypeInternal;
extern PathSourceArchiveDefaultTypeInternal _PathSourceArchive_default_instance_;
class PatternedStrokeArchive;
struct PatternedStrokeArchiveDefaultTypeInternal;
extern PatternedStrokeArchiveDefaultTypeInternal _PatternedStrokeArchive_default_instance_;
class PencilAnnotationArchive;
struct PencilAnnotationArchiveDefaultTypeInternal;
extern PencilAnnotationArchiveDefaultTypeInternal _PencilAnnotationArchive_default_instance_;
class PencilAnnotationSelectionArchive;
struct PencilAnnotationSelectionArchiveDefaultTypeInternal;
extern PencilAnnotationSelectionArchiveDefaultTypeInternal _PencilAnnotationSelectionArchive_default_instance_;
class PencilAnnotationStorageArchive;
struct PencilAnnotationStorageArchiveDefaultTypeInternal;
extern PencilAnnotationStorageArchiveDefaultTypeInternal _PencilAnnotationStorageArchive_default_instance_;
class PointPathSourceArchive;
struct PointPathSourceArchiveDefaultTypeInternal;
extern PointPathSourceArchiveDefaultTypeInternal _PointPathSourceArchive_default_instance_;
class ReflectionArchive;
struct ReflectionArchiveDefaultTypeInternal;
extern ReflectionArchiveDefaultTypeInternal _ReflectionArchive_default_instance_;
class ReplaceAnnotationAuthorCommandArchive;
struct ReplaceAnnotationAuthorCommandArchiveDefaultTypeInternal;
extern ReplaceAnnotationAuthorCommandArchiveDefaultTypeInternal _ReplaceAnnotationAuthorCommandArchive_default_instance_;
class ScalarPathSourceArchive;
struct ScalarPathSourceArchiveDefaultTypeInternal;
extern ScalarPathSourceArchiveDefaultTypeInternal _ScalarPathSourceArchive_default_instance_;
class ShadowArchive;
struct ShadowArchiveDefaultTypeInternal;
extern ShadowArchiveDefaultTypeInternal _ShadowArchive_default_instance_;
class ShapeArchive;
struct ShapeArchiveDefaultTypeInternal;
extern ShapeArchiveDefaultTypeInternal _ShapeArchive_default_instance_;
class ShapeStyleArchive;
struct ShapeStyleArchiveDefaultTypeInternal;
extern ShapeStyleArchiveDefaultTypeInternal _ShapeStyleArchive_default_instance_;
class ShapeStylePropertiesArchive;
struct ShapeStylePropertiesArchiveDefaultTypeInternal;
extern ShapeStylePropertiesArchiveDefaultTypeInternal _ShapeStylePropertiesArchive_default_instance_;
class SmartStrokeArchive;
struct SmartStrokeArchiveDefaultTypeInternal;
extern SmartStrokeArchiveDefaultTypeInternal _SmartStrokeArchive_default_instance_;
class SpecColorFillSetColorArchive;
struct SpecColorFillSetColorArchiveDefaultTypeInternal;
extern SpecColorFillSetColorArchiveDefaultTypeInternal _SpecColorFillSetColorArchive_default_instance_;
class SpecFrameSetAssetScaleArchive;
struct SpecFrameSetAssetScaleArchiveDefaultTypeInternal;
extern SpecFrameSetAssetScaleArchiveDefaultTypeInternal _SpecFrameSetAssetScaleArchive_default_instance_;
class SpecGradientFillSetAngleArchive;
struct SpecGradientFillSetAngleArchiveDefaultTypeInternal;
extern SpecGradientFillSetAngleArchiveDefaultTypeInternal _SpecGradientFillSetAngleArchive_default_instance_;
class SpecImageFillSetTechniqueArchive;
struct SpecImageFillSetTechniqueArchiveDefaultTypeInternal;
extern SpecImageFillSetTechniqueArchiveDefaultTypeInternal _SpecImageFillSetTechniqueArchive_default_instance_;
class SpecReflectionSetOpacityArchive;
struct SpecReflectionSetOpacityArchiveDefaultTypeInternal;
extern SpecReflectionSetOpacityArchiveDefaultTypeInternal _SpecReflectionSetOpacityArchive_default_instance_;
class SpecShadowSetAngleArchive;
struct SpecShadowSetAngleArchiveDefaultTypeInternal;
extern SpecShadowSetAngleArchiveDefaultTypeInternal _SpecShadowSetAngleArchive_default_instance_;
class SpecShadowSetColorArchive;
struct SpecShadowSetColorArchiveDefaultTypeInternal;
extern SpecShadowSetColorArchiveDefaultTypeInternal _SpecShadowSetColorArchive_default_instance_;
class SpecShadowSetOffsetArchive;
struct SpecShadowSetOffsetArchiveDefaultTypeInternal;
extern SpecShadowSetOffsetArchiveDefaultTypeInternal _SpecShadowSetOffsetArchive_default_instance_;
class SpecShadowSetOpacityArchive;
struct SpecShadowSetOpacityArchiveDefaultTypeInternal;
extern SpecShadowSetOpacityArchiveDefaultTypeInternal _SpecShadowSetOpacityArchive_default_instance_;
class SpecShadowSetRadiusArchive;
struct SpecShadowSetRadiusArchiveDefaultTypeInternal;
extern SpecShadowSetRadiusArchiveDefaultTypeInternal _SpecShadowSetRadiusArchive_default_instance_;
class SpecStrokeSetColorArchive;
struct SpecStrokeSetColorArchiveDefaultTypeInternal;
extern SpecStrokeSetColorArchiveDefaultTypeInternal _SpecStrokeSetColorArchive_default_instance_;
class SpecStrokeSetPatternArchive;
struct SpecStrokeSetPatternArchiveDefaultTypeInternal;
extern SpecStrokeSetPatternArchiveDefaultTypeInternal _SpecStrokeSetPatternArchive_default_instance_;
class SpecStrokeSetWidthArchive;
struct SpecStrokeSetWidthArchiveDefaultTypeInternal;
extern SpecStrokeSetWidthArchiveDefaultTypeInternal _SpecStrokeSetWidthArchive_default_instance_;
class StandinCaptionArchive;
struct StandinCaptionArchiveDefaultTypeInternal;
extern StandinCaptionArchiveDefaultTypeInternal _StandinCaptionArchive_default_instance_;
class StrokeArchive;
struct StrokeArchiveDefaultTypeInternal;
extern StrokeArchiveDefaultTypeInternal _StrokeArchive_default_instance_;
class StrokePatternArchive;
struct StrokePatternArchiveDefaultTypeInternal;
extern StrokePatternArchiveDefaultTypeInternal _StrokePatternArchive_default_instance_;
class ThemePresetsArchive;
struct ThemePresetsArchiveDefaultTypeInternal;
extern ThemePresetsArchiveDefaultTypeInternal _ThemePresetsArchive_default_instance_;
class ThemeReplaceFillPresetCommandArchive;
struct ThemeReplaceFillPresetCommandArchiveDefaultTypeInternal;
extern ThemeReplaceFillPresetCommandArchiveDefaultTypeInternal _ThemeReplaceFillPresetCommandArchive_default_instance_;
class TransformGradientArchive;
struct TransformGradientArchiveDefaultTypeInternal;
extern TransformGradientArchiveDefaultTypeInternal _TransformGradientArchive_default_instance_;
class UserDefinedGuideArchive;
struct UserDefinedGuideArchiveDefaultTypeInternal;
extern UserDefinedGuideArchiveDefaultTypeInternal _UserDefinedGuideArchive_default_instance_;
}  // namespace TSD
PROTOBUF_NAMESPACE_OPEN
template<> ::TSD::AngleGradientArchive* Arena::CreateMaybeMessage<::TSD::AngleGradientArchive>(Arena*);
template<> ::TSD::Attribution* Arena::CreateMaybeMessage<::TSD::Attribution>(Arena*);
template<> ::TSD::BezierPathSourceArchive* Arena::CreateMaybeMessage<::TSD::BezierPathSourceArchive>(Arena*);
template<> ::TSD::CalloutPathSourceArchive* Arena::CreateMaybeMessage<::TSD::CalloutPathSourceArchive>(Arena*);
template<> ::TSD::CanvasSelectionArchive* Arena::CreateMaybeMessage<::TSD::CanvasSelectionArchive>(Arena*);
template<> ::TSD::CommentStorageArchive* Arena::CreateMaybeMessage<::TSD::CommentStorageArchive>(Arena*);
template<> ::TSD::ConnectionLineArchive* Arena::CreateMaybeMessage<::TSD::ConnectionLineArchive>(Arena*);
template<> ::TSD::ConnectionLinePathSourceArchive* Arena::CreateMaybeMessage<::TSD::ConnectionLinePathSourceArchive>(Arena*);
template<> ::TSD::ContactShadowArchive* Arena::CreateMaybeMessage<::TSD::ContactShadowArchive>(Arena*);
template<> ::TSD::ContainerArchive* Arena::CreateMaybeMessage<::TSD::ContainerArchive>(Arena*);
template<> ::TSD::CurvedShadowArchive* Arena::CreateMaybeMessage<::TSD::CurvedShadowArchive>(Arena*);
template<> ::TSD::DrawableArchive* Arena::CreateMaybeMessage<::TSD::DrawableArchive>(Arena*);
template<> ::TSD::DrawableContentDescription* Arena::CreateMaybeMessage<::TSD::DrawableContentDescription>(Arena*);
template<> ::TSD::DrawableSelectionArchive* Arena::CreateMaybeMessage<::TSD::DrawableSelectionArchive>(Arena*);
template<> ::TSD::DropShadowArchive* Arena::CreateMaybeMessage<::TSD::DropShadowArchive>(Arena*);
template<> ::TSD::EdgeInsetsArchive* Arena::CreateMaybeMessage<::TSD::EdgeInsetsArchive>(Arena*);
template<> ::TSD::EditableBezierPathSourceArchive* Arena::CreateMaybeMessage<::TSD::EditableBezierPathSourceArchive>(Arena*);
template<> ::TSD::EditableBezierPathSourceArchive_Node* Arena::CreateMaybeMessage<::TSD::EditableBezierPathSourceArchive_Node>(Arena*);
template<> ::TSD::EditableBezierPathSourceArchive_Subpath* Arena::CreateMaybeMessage<::TSD::EditableBezierPathSourceArchive_Subpath>(Arena*);
template<> ::TSD::ExteriorTextWrapArchive* Arena::CreateMaybeMessage<::TSD::ExteriorTextWrapArchive>(Arena*);
template<> ::TSD::FillArchive* Arena::CreateMaybeMessage<::TSD::FillArchive>(Arena*);
template<> ::TSD::FrameArchive* Arena::CreateMaybeMessage<::TSD::FrameArchive>(Arena*);
template<> ::TSD::FreehandDrawingAnimationArchive* Arena::CreateMaybeMessage<::TSD::FreehandDrawingAnimationArchive>(Arena*);
template<> ::TSD::FreehandDrawingArchive* Arena::CreateMaybeMessage<::TSD::FreehandDrawingArchive>(Arena*);
template<> ::TSD::FreehandDrawingContentDescription* Arena::CreateMaybeMessage<::TSD::FreehandDrawingContentDescription>(Arena*);
template<> ::TSD::FreehandDrawingToolkitUIState* Arena::CreateMaybeMessage<::TSD::FreehandDrawingToolkitUIState>(Arena*);
template<> ::TSD::GeometryArchive* Arena::CreateMaybeMessage<::TSD::GeometryArchive>(Arena*);
template<> ::TSD::GradientArchive* Arena::CreateMaybeMessage<::TSD::GradientArchive>(Arena*);
template<> ::TSD::GradientArchive_GradientStop* Arena::CreateMaybeMessage<::TSD::GradientArchive_GradientStop>(Arena*);
template<> ::TSD::GroupArchive* Arena::CreateMaybeMessage<::TSD::GroupArchive>(Arena*);
template<> ::TSD::GroupSelectionArchive* Arena::CreateMaybeMessage<::TSD::GroupSelectionArchive>(Arena*);
template<> ::TSD::GuideArchive* Arena::CreateMaybeMessage<::TSD::GuideArchive>(Arena*);
template<> ::TSD::GuideStorageArchive* Arena::CreateMaybeMessage<::TSD::GuideStorageArchive>(Arena*);
template<> ::TSD::ImageAdjustmentsArchive* Arena::CreateMaybeMessage<::TSD::ImageAdjustmentsArchive>(Arena*);
template<> ::TSD::ImageArchive* Arena::CreateMaybeMessage<::TSD::ImageArchive>(Arena*);
template<> ::TSD::ImageDataAttributes* Arena::CreateMaybeMessage<::TSD::ImageDataAttributes>(Arena*);
template<> ::TSD::ImageFillArchive* Arena::CreateMaybeMessage<::TSD::ImageFillArchive>(Arena*);
template<> ::TSD::InfoHyperlinkSelectionArchive* Arena::CreateMaybeMessage<::TSD::InfoHyperlinkSelectionArchive>(Arena*);
template<> ::TSD::LineEndArchive* Arena::CreateMaybeMessage<::TSD::LineEndArchive>(Arena*);
template<> ::TSD::MaskArchive* Arena::CreateMaybeMessage<::TSD::MaskArchive>(Arena*);
template<> ::TSD::MediaStyleArchive* Arena::CreateMaybeMessage<::TSD::MediaStyleArchive>(Arena*);
template<> ::TSD::MediaStylePropertiesArchive* Arena::CreateMaybeMessage<::TSD::MediaStylePropertiesArchive>(Arena*);
template<> ::TSD::MovieArchive* Arena::CreateMaybeMessage<::TSD::MovieArchive>(Arena*);
template<> ::TSD::MovieFingerprint* Arena::CreateMaybeMessage<::TSD::MovieFingerprint>(Arena*);
template<> ::TSD::MovieFingerprintTrack* Arena::CreateMaybeMessage<::TSD::MovieFingerprintTrack>(Arena*);
template<> ::TSD::PathSelectionArchive* Arena::CreateMaybeMessage<::TSD::PathSelectionArchive>(Arena*);
template<> ::TSD::PathSourceArchive* Arena::CreateMaybeMessage<::TSD::PathSourceArchive>(Arena*);
template<> ::TSD::PatternedStrokeArchive* Arena::CreateMaybeMessage<::TSD::PatternedStrokeArchive>(Arena*);
template<> ::TSD::PencilAnnotationArchive* Arena::CreateMaybeMessage<::TSD::PencilAnnotationArchive>(Arena*);
template<> ::TSD::PencilAnnotationSelectionArchive* Arena::CreateMaybeMessage<::TSD::PencilAnnotationSelectionArchive>(Arena*);
template<> ::TSD::PencilAnnotationStorageArchive* Arena::CreateMaybeMessage<::TSD::PencilAnnotationStorageArchive>(Arena*);
template<> ::TSD::PointPathSourceArchive* Arena::CreateMaybeMessage<::TSD::PointPathSourceArchive>(Arena*);
template<> ::TSD::ReflectionArchive* Arena::CreateMaybeMessage<::TSD::ReflectionArchive>(Arena*);
template<> ::TSD::ReplaceAnnotationAuthorCommandArchive* Arena::CreateMaybeMessage<::TSD::ReplaceAnnotationAuthorCommandArchive>(Arena*);
template<> ::TSD::ScalarPathSourceArchive* Arena::CreateMaybeMessage<::TSD::ScalarPathSourceArchive>(Arena*);
template<> ::TSD::ShadowArchive* Arena::CreateMaybeMessage<::TSD::ShadowArchive>(Arena*);
template<> ::TSD::ShapeArchive* Arena::CreateMaybeMessage<::TSD::ShapeArchive>(Arena*);
template<> ::TSD::ShapeStyleArchive* Arena::CreateMaybeMessage<::TSD::ShapeStyleArchive>(Arena*);
template<> ::TSD::ShapeStylePropertiesArchive* Arena::CreateMaybeMessage<::TSD::ShapeStylePropertiesArchive>(Arena*);
template<> ::TSD::SmartStrokeArchive* Arena::CreateMaybeMessage<::TSD::SmartStrokeArchive>(Arena*);
template<> ::TSD::SpecColorFillSetColorArchive* Arena::CreateMaybeMessage<::TSD::SpecColorFillSetColorArchive>(Arena*);
template<> ::TSD::SpecFrameSetAssetScaleArchive* Arena::CreateMaybeMessage<::TSD::SpecFrameSetAssetScaleArchive>(Arena*);
template<> ::TSD::SpecGradientFillSetAngleArchive* Arena::CreateMaybeMessage<::TSD::SpecGradientFillSetAngleArchive>(Arena*);
template<> ::TSD::SpecImageFillSetTechniqueArchive* Arena::CreateMaybeMessage<::TSD::SpecImageFillSetTechniqueArchive>(Arena*);
template<> ::TSD::SpecReflectionSetOpacityArchive* Arena::CreateMaybeMessage<::TSD::SpecReflectionSetOpacityArchive>(Arena*);
template<> ::TSD::SpecShadowSetAngleArchive* Arena::CreateMaybeMessage<::TSD::SpecShadowSetAngleArchive>(Arena*);
template<> ::TSD::SpecShadowSetColorArchive* Arena::CreateMaybeMessage<::TSD::SpecShadowSetColorArchive>(Arena*);
template<> ::TSD::SpecShadowSetOffsetArchive* Arena::CreateMaybeMessage<::TSD::SpecShadowSetOffsetArchive>(Arena*);
template<> ::TSD::SpecShadowSetOpacityArchive* Arena::CreateMaybeMessage<::TSD::SpecShadowSetOpacityArchive>(Arena*);
template<> ::TSD::SpecShadowSetRadiusArchive* Arena::CreateMaybeMessage<::TSD::SpecShadowSetRadiusArchive>(Arena*);
template<> ::TSD::SpecStrokeSetColorArchive* Arena::CreateMaybeMessage<::TSD::SpecStrokeSetColorArchive>(Arena*);
template<> ::TSD::SpecStrokeSetPatternArchive* Arena::CreateMaybeMessage<::TSD::SpecStrokeSetPatternArchive>(Arena*);
template<> ::TSD::SpecStrokeSetWidthArchive* Arena::CreateMaybeMessage<::TSD::SpecStrokeSetWidthArchive>(Arena*);
template<> ::TSD::StandinCaptionArchive* Arena::CreateMaybeMessage<::TSD::StandinCaptionArchive>(Arena*);
template<> ::TSD::StrokeArchive* Arena::CreateMaybeMessage<::TSD::StrokeArchive>(Arena*);
template<> ::TSD::StrokePatternArchive* Arena::CreateMaybeMessage<::TSD::StrokePatternArchive>(Arena*);
template<> ::TSD::ThemePresetsArchive* Arena::CreateMaybeMessage<::TSD::ThemePresetsArchive>(Arena*);
template<> ::TSD::ThemeReplaceFillPresetCommandArchive* Arena::CreateMaybeMessage<::TSD::ThemeReplaceFillPresetCommandArchive>(Arena*);
template<> ::TSD::TransformGradientArchive* Arena::CreateMaybeMessage<::TSD::TransformGradientArchive>(Arena*);
template<> ::TSD::UserDefinedGuideArchive* Arena::CreateMaybeMessage<::TSD::UserDefinedGuideArchive>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TSD {

enum PointPathSourceArchive_PointPathSourceType : int {
  PointPathSourceArchive_PointPathSourceType_kTSDLeftSingleArrow = 0,
  PointPathSourceArchive_PointPathSourceType_kTSDRightSingleArrow = 1,
  PointPathSourceArchive_PointPathSourceType_kTSDDoubleArrow = 10,
  PointPathSourceArchive_PointPathSourceType_kTSDStar = 100,
  PointPathSourceArchive_PointPathSourceType_kTSDPlus = 200
};
bool PointPathSourceArchive_PointPathSourceType_IsValid(int value);
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MIN = PointPathSourceArchive_PointPathSourceType_kTSDLeftSingleArrow;
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MAX = PointPathSourceArchive_PointPathSourceType_kTSDPlus;
constexpr int PointPathSourceArchive_PointPathSourceType_PointPathSourceType_ARRAYSIZE = PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PointPathSourceArchive_PointPathSourceType_descriptor();
template<typename T>
inline const std::string& PointPathSourceArchive_PointPathSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PointPathSourceArchive_PointPathSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PointPathSourceArchive_PointPathSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PointPathSourceArchive_PointPathSourceType_descriptor(), enum_t_value);
}
inline bool PointPathSourceArchive_PointPathSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PointPathSourceArchive_PointPathSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PointPathSourceArchive_PointPathSourceType>(
    PointPathSourceArchive_PointPathSourceType_descriptor(), name, value);
}
enum ScalarPathSourceArchive_ScalarPathSourceType : int {
  ScalarPathSourceArchive_ScalarPathSourceType_kTSDRoundedRectangle = 0,
  ScalarPathSourceArchive_ScalarPathSourceType_kTSDRegularPolygon = 1,
  ScalarPathSourceArchive_ScalarPathSourceType_kTSDChevron = 2
};
bool ScalarPathSourceArchive_ScalarPathSourceType_IsValid(int value);
constexpr ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MIN = ScalarPathSourceArchive_ScalarPathSourceType_kTSDRoundedRectangle;
constexpr ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MAX = ScalarPathSourceArchive_ScalarPathSourceType_kTSDChevron;
constexpr int ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_ARRAYSIZE = ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScalarPathSourceArchive_ScalarPathSourceType_descriptor();
template<typename T>
inline const std::string& ScalarPathSourceArchive_ScalarPathSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScalarPathSourceArchive_ScalarPathSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScalarPathSourceArchive_ScalarPathSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ScalarPathSourceArchive_ScalarPathSourceType_descriptor(), enum_t_value);
}
inline bool ScalarPathSourceArchive_ScalarPathSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ScalarPathSourceArchive_ScalarPathSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ScalarPathSourceArchive_ScalarPathSourceType>(
    ScalarPathSourceArchive_ScalarPathSourceType_descriptor(), name, value);
}
enum ConnectionLinePathSourceArchive_ConnectionLinePathSourceType : int {
  ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeQuadratic = 0,
  ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeOrthogonal = 1
};
bool ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_IsValid(int value);
constexpr ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MIN = ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeQuadratic;
constexpr ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MAX = ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeOrthogonal;
constexpr int ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_ARRAYSIZE = ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor();
template<typename T>
inline const std::string& ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionLinePathSourceArchive_ConnectionLinePathSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor(), enum_t_value);
}
inline bool ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionLinePathSourceArchive_ConnectionLinePathSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnectionLinePathSourceArchive_ConnectionLinePathSourceType>(
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor(), name, value);
}
enum EditableBezierPathSourceArchive_NodeType : int {
  EditableBezierPathSourceArchive_NodeType_sharp = 1,
  EditableBezierPathSourceArchive_NodeType_bezier = 2,
  EditableBezierPathSourceArchive_NodeType_smooth = 3
};
bool EditableBezierPathSourceArchive_NodeType_IsValid(int value);
constexpr EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive_NodeType_NodeType_MIN = EditableBezierPathSourceArchive_NodeType_sharp;
constexpr EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive_NodeType_NodeType_MAX = EditableBezierPathSourceArchive_NodeType_smooth;
constexpr int EditableBezierPathSourceArchive_NodeType_NodeType_ARRAYSIZE = EditableBezierPathSourceArchive_NodeType_NodeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EditableBezierPathSourceArchive_NodeType_descriptor();
template<typename T>
inline const std::string& EditableBezierPathSourceArchive_NodeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EditableBezierPathSourceArchive_NodeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EditableBezierPathSourceArchive_NodeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EditableBezierPathSourceArchive_NodeType_descriptor(), enum_t_value);
}
inline bool EditableBezierPathSourceArchive_NodeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EditableBezierPathSourceArchive_NodeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EditableBezierPathSourceArchive_NodeType>(
    EditableBezierPathSourceArchive_NodeType_descriptor(), name, value);
}
enum GradientArchive_GradientType : int {
  GradientArchive_GradientType_Linear = 0,
  GradientArchive_GradientType_Radial = 1
};
bool GradientArchive_GradientType_IsValid(int value);
constexpr GradientArchive_GradientType GradientArchive_GradientType_GradientType_MIN = GradientArchive_GradientType_Linear;
constexpr GradientArchive_GradientType GradientArchive_GradientType_GradientType_MAX = GradientArchive_GradientType_Radial;
constexpr int GradientArchive_GradientType_GradientType_ARRAYSIZE = GradientArchive_GradientType_GradientType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GradientArchive_GradientType_descriptor();
template<typename T>
inline const std::string& GradientArchive_GradientType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GradientArchive_GradientType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GradientArchive_GradientType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GradientArchive_GradientType_descriptor(), enum_t_value);
}
inline bool GradientArchive_GradientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GradientArchive_GradientType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GradientArchive_GradientType>(
    GradientArchive_GradientType_descriptor(), name, value);
}
enum ImageFillArchive_ImageFillTechnique : int {
  ImageFillArchive_ImageFillTechnique_NaturalSize = 0,
  ImageFillArchive_ImageFillTechnique_Stretch = 1,
  ImageFillArchive_ImageFillTechnique_Tile = 2,
  ImageFillArchive_ImageFillTechnique_ScaleToFill = 3,
  ImageFillArchive_ImageFillTechnique_ScaleToFit = 4
};
bool ImageFillArchive_ImageFillTechnique_IsValid(int value);
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MIN = ImageFillArchive_ImageFillTechnique_NaturalSize;
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MAX = ImageFillArchive_ImageFillTechnique_ScaleToFit;
constexpr int ImageFillArchive_ImageFillTechnique_ImageFillTechnique_ARRAYSIZE = ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageFillArchive_ImageFillTechnique_descriptor();
template<typename T>
inline const std::string& ImageFillArchive_ImageFillTechnique_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageFillArchive_ImageFillTechnique>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageFillArchive_ImageFillTechnique_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageFillArchive_ImageFillTechnique_descriptor(), enum_t_value);
}
inline bool ImageFillArchive_ImageFillTechnique_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageFillArchive_ImageFillTechnique* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageFillArchive_ImageFillTechnique>(
    ImageFillArchive_ImageFillTechnique_descriptor(), name, value);
}
enum StrokePatternArchive_StrokePatternType : int {
  StrokePatternArchive_StrokePatternType_TSDPattern = 0,
  StrokePatternArchive_StrokePatternType_TSDSolidPattern = 1,
  StrokePatternArchive_StrokePatternType_TSDEmptyPattern = 2
};
bool StrokePatternArchive_StrokePatternType_IsValid(int value);
constexpr StrokePatternArchive_StrokePatternType StrokePatternArchive_StrokePatternType_StrokePatternType_MIN = StrokePatternArchive_StrokePatternType_TSDPattern;
constexpr StrokePatternArchive_StrokePatternType StrokePatternArchive_StrokePatternType_StrokePatternType_MAX = StrokePatternArchive_StrokePatternType_TSDEmptyPattern;
constexpr int StrokePatternArchive_StrokePatternType_StrokePatternType_ARRAYSIZE = StrokePatternArchive_StrokePatternType_StrokePatternType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StrokePatternArchive_StrokePatternType_descriptor();
template<typename T>
inline const std::string& StrokePatternArchive_StrokePatternType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StrokePatternArchive_StrokePatternType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StrokePatternArchive_StrokePatternType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StrokePatternArchive_StrokePatternType_descriptor(), enum_t_value);
}
inline bool StrokePatternArchive_StrokePatternType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StrokePatternArchive_StrokePatternType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StrokePatternArchive_StrokePatternType>(
    StrokePatternArchive_StrokePatternType_descriptor(), name, value);
}
enum StrokeArchive_LineCap : int {
  StrokeArchive_LineCap_ButtCap = 0,
  StrokeArchive_LineCap_RoundCap = 1,
  StrokeArchive_LineCap_SquareCap = 2
};
bool StrokeArchive_LineCap_IsValid(int value);
constexpr StrokeArchive_LineCap StrokeArchive_LineCap_LineCap_MIN = StrokeArchive_LineCap_ButtCap;
constexpr StrokeArchive_LineCap StrokeArchive_LineCap_LineCap_MAX = StrokeArchive_LineCap_SquareCap;
constexpr int StrokeArchive_LineCap_LineCap_ARRAYSIZE = StrokeArchive_LineCap_LineCap_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StrokeArchive_LineCap_descriptor();
template<typename T>
inline const std::string& StrokeArchive_LineCap_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StrokeArchive_LineCap>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StrokeArchive_LineCap_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StrokeArchive_LineCap_descriptor(), enum_t_value);
}
inline bool StrokeArchive_LineCap_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StrokeArchive_LineCap* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StrokeArchive_LineCap>(
    StrokeArchive_LineCap_descriptor(), name, value);
}
enum ShadowArchive_ShadowType : int {
  ShadowArchive_ShadowType_TSDDropShadow = 0,
  ShadowArchive_ShadowType_TSDContactShadow = 1,
  ShadowArchive_ShadowType_TSDCurvedShadow = 2
};
bool ShadowArchive_ShadowType_IsValid(int value);
constexpr ShadowArchive_ShadowType ShadowArchive_ShadowType_ShadowType_MIN = ShadowArchive_ShadowType_TSDDropShadow;
constexpr ShadowArchive_ShadowType ShadowArchive_ShadowType_ShadowType_MAX = ShadowArchive_ShadowType_TSDCurvedShadow;
constexpr int ShadowArchive_ShadowType_ShadowType_ARRAYSIZE = ShadowArchive_ShadowType_ShadowType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShadowArchive_ShadowType_descriptor();
template<typename T>
inline const std::string& ShadowArchive_ShadowType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShadowArchive_ShadowType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShadowArchive_ShadowType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShadowArchive_ShadowType_descriptor(), enum_t_value);
}
inline bool ShadowArchive_ShadowType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShadowArchive_ShadowType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShadowArchive_ShadowType>(
    ShadowArchive_ShadowType_descriptor(), name, value);
}
enum MovieArchive_MovieLoopOption : int {
  MovieArchive_MovieLoopOption_None = 0,
  MovieArchive_MovieLoopOption_Repeat = 1,
  MovieArchive_MovieLoopOption_BackAndForth = 2
};
bool MovieArchive_MovieLoopOption_IsValid(int value);
constexpr MovieArchive_MovieLoopOption MovieArchive_MovieLoopOption_MovieLoopOption_MIN = MovieArchive_MovieLoopOption_None;
constexpr MovieArchive_MovieLoopOption MovieArchive_MovieLoopOption_MovieLoopOption_MAX = MovieArchive_MovieLoopOption_BackAndForth;
constexpr int MovieArchive_MovieLoopOption_MovieLoopOption_ARRAYSIZE = MovieArchive_MovieLoopOption_MovieLoopOption_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MovieArchive_MovieLoopOption_descriptor();
template<typename T>
inline const std::string& MovieArchive_MovieLoopOption_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MovieArchive_MovieLoopOption>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MovieArchive_MovieLoopOption_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MovieArchive_MovieLoopOption_descriptor(), enum_t_value);
}
inline bool MovieArchive_MovieLoopOption_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MovieArchive_MovieLoopOption* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MovieArchive_MovieLoopOption>(
    MovieArchive_MovieLoopOption_descriptor(), name, value);
}
enum FreehandDrawingToolkitUIState_FreehandDrawingToolType : int {
  FreehandDrawingToolkitUIState_FreehandDrawingToolType_Pen = 0,
  FreehandDrawingToolkitUIState_FreehandDrawingToolType_Pencil = 1,
  FreehandDrawingToolkitUIState_FreehandDrawingToolType_Crayon = 2,
  FreehandDrawingToolkitUIState_FreehandDrawingToolType_Fill = 3,
  FreehandDrawingToolkitUIState_FreehandDrawingToolType_Eraser = 4,
  FreehandDrawingToolkitUIState_FreehandDrawingToolType_MarqueeSelect = 5
};
bool FreehandDrawingToolkitUIState_FreehandDrawingToolType_IsValid(int value);
constexpr FreehandDrawingToolkitUIState_FreehandDrawingToolType FreehandDrawingToolkitUIState_FreehandDrawingToolType_FreehandDrawingToolType_MIN = FreehandDrawingToolkitUIState_FreehandDrawingToolType_Pen;
constexpr FreehandDrawingToolkitUIState_FreehandDrawingToolType FreehandDrawingToolkitUIState_FreehandDrawingToolType_FreehandDrawingToolType_MAX = FreehandDrawingToolkitUIState_FreehandDrawingToolType_MarqueeSelect;
constexpr int FreehandDrawingToolkitUIState_FreehandDrawingToolType_FreehandDrawingToolType_ARRAYSIZE = FreehandDrawingToolkitUIState_FreehandDrawingToolType_FreehandDrawingToolType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FreehandDrawingToolkitUIState_FreehandDrawingToolType_descriptor();
template<typename T>
inline const std::string& FreehandDrawingToolkitUIState_FreehandDrawingToolType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FreehandDrawingToolkitUIState_FreehandDrawingToolType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FreehandDrawingToolkitUIState_FreehandDrawingToolType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FreehandDrawingToolkitUIState_FreehandDrawingToolType_descriptor(), enum_t_value);
}
inline bool FreehandDrawingToolkitUIState_FreehandDrawingToolType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FreehandDrawingToolkitUIState_FreehandDrawingToolType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FreehandDrawingToolkitUIState_FreehandDrawingToolType>(
    FreehandDrawingToolkitUIState_FreehandDrawingToolType_descriptor(), name, value);
}
enum GuideArchive_GuideType : int {
  GuideArchive_GuideType_Horizontal = 0,
  GuideArchive_GuideType_Vertical = 1
};
bool GuideArchive_GuideType_IsValid(int value);
constexpr GuideArchive_GuideType GuideArchive_GuideType_GuideType_MIN = GuideArchive_GuideType_Horizontal;
constexpr GuideArchive_GuideType GuideArchive_GuideType_GuideType_MAX = GuideArchive_GuideType_Vertical;
constexpr int GuideArchive_GuideType_GuideType_ARRAYSIZE = GuideArchive_GuideType_GuideType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GuideArchive_GuideType_descriptor();
template<typename T>
inline const std::string& GuideArchive_GuideType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuideArchive_GuideType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuideArchive_GuideType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GuideArchive_GuideType_descriptor(), enum_t_value);
}
inline bool GuideArchive_GuideType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GuideArchive_GuideType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GuideArchive_GuideType>(
    GuideArchive_GuideType_descriptor(), name, value);
}
enum UserDefinedGuideArchive_GuideType : int {
  UserDefinedGuideArchive_GuideType_Horizontal = 0,
  UserDefinedGuideArchive_GuideType_Vertical = 1
};
bool UserDefinedGuideArchive_GuideType_IsValid(int value);
constexpr UserDefinedGuideArchive_GuideType UserDefinedGuideArchive_GuideType_GuideType_MIN = UserDefinedGuideArchive_GuideType_Horizontal;
constexpr UserDefinedGuideArchive_GuideType UserDefinedGuideArchive_GuideType_GuideType_MAX = UserDefinedGuideArchive_GuideType_Vertical;
constexpr int UserDefinedGuideArchive_GuideType_GuideType_ARRAYSIZE = UserDefinedGuideArchive_GuideType_GuideType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserDefinedGuideArchive_GuideType_descriptor();
template<typename T>
inline const std::string& UserDefinedGuideArchive_GuideType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserDefinedGuideArchive_GuideType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserDefinedGuideArchive_GuideType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserDefinedGuideArchive_GuideType_descriptor(), enum_t_value);
}
inline bool UserDefinedGuideArchive_GuideType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserDefinedGuideArchive_GuideType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserDefinedGuideArchive_GuideType>(
    UserDefinedGuideArchive_GuideType_descriptor(), name, value);
}
enum LineJoin : int {
  MiterJoin = 0,
  RoundJoin = 1,
  BevelJoin = 2
};
bool LineJoin_IsValid(int value);
constexpr LineJoin LineJoin_MIN = MiterJoin;
constexpr LineJoin LineJoin_MAX = BevelJoin;
constexpr int LineJoin_ARRAYSIZE = LineJoin_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LineJoin_descriptor();
template<typename T>
inline const std::string& LineJoin_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LineJoin>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LineJoin_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LineJoin_descriptor(), enum_t_value);
}
inline bool LineJoin_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LineJoin* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LineJoin>(
    LineJoin_descriptor(), name, value);
}
// ===================================================================

class EdgeInsetsArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.EdgeInsetsArchive) */ {
 public:
  inline EdgeInsetsArchive() : EdgeInsetsArchive(nullptr) {}
  ~EdgeInsetsArchive() override;
  explicit constexpr EdgeInsetsArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EdgeInsetsArchive(const EdgeInsetsArchive& from);
  EdgeInsetsArchive(EdgeInsetsArchive&& from) noexcept
    : EdgeInsetsArchive() {
    *this = ::std::move(from);
  }

  inline EdgeInsetsArchive& operator=(const EdgeInsetsArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline EdgeInsetsArchive& operator=(EdgeInsetsArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EdgeInsetsArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const EdgeInsetsArchive* internal_default_instance() {
    return reinterpret_cast<const EdgeInsetsArchive*>(
               &_EdgeInsetsArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EdgeInsetsArchive& a, EdgeInsetsArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(EdgeInsetsArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EdgeInsetsArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EdgeInsetsArchive* New() const final {
    return CreateMaybeMessage<EdgeInsetsArchive>(nullptr);
  }

  EdgeInsetsArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EdgeInsetsArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EdgeInsetsArchive& from);
  void MergeFrom(const EdgeInsetsArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgeInsetsArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.EdgeInsetsArchive";
  }
  protected:
  explicit EdgeInsetsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopFieldNumber = 1,
    kLeftFieldNumber = 2,
    kBottomFieldNumber = 3,
    kRightFieldNumber = 4,
  };
  // required float top = 1;
  bool has_top() const;
  private:
  bool _internal_has_top() const;
  public:
  void clear_top();
  float top() const;
  void set_top(float value);
  private:
  float _internal_top() const;
  void _internal_set_top(float value);
  public:

  // required float left = 2;
  bool has_left() const;
  private:
  bool _internal_has_left() const;
  public:
  void clear_left();
  float left() const;
  void set_left(float value);
  private:
  float _internal_left() const;
  void _internal_set_left(float value);
  public:

  // required float bottom = 3;
  bool has_bottom() const;
  private:
  bool _internal_has_bottom() const;
  public:
  void clear_bottom();
  float bottom() const;
  void set_bottom(float value);
  private:
  float _internal_bottom() const;
  void _internal_set_bottom(float value);
  public:

  // required float right = 4;
  bool has_right() const;
  private:
  bool _internal_has_right() const;
  public:
  void clear_right();
  float right() const;
  void set_right(float value);
  private:
  float _internal_right() const;
  void _internal_set_right(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.EdgeInsetsArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float top_;
  float left_;
  float bottom_;
  float right_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class GeometryArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.GeometryArchive) */ {
 public:
  inline GeometryArchive() : GeometryArchive(nullptr) {}
  ~GeometryArchive() override;
  explicit constexpr GeometryArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeometryArchive(const GeometryArchive& from);
  GeometryArchive(GeometryArchive&& from) noexcept
    : GeometryArchive() {
    *this = ::std::move(from);
  }

  inline GeometryArchive& operator=(const GeometryArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeometryArchive& operator=(GeometryArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeometryArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeometryArchive* internal_default_instance() {
    return reinterpret_cast<const GeometryArchive*>(
               &_GeometryArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GeometryArchive& a, GeometryArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(GeometryArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeometryArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeometryArchive* New() const final {
    return CreateMaybeMessage<GeometryArchive>(nullptr);
  }

  GeometryArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeometryArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeometryArchive& from);
  void MergeFrom(const GeometryArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeometryArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.GeometryArchive";
  }
  protected:
  explicit GeometryArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kSizeFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kAngleFieldNumber = 4,
  };
  // optional .TSP.Point position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::TSP::Point& position() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Point* release_position();
  ::TSP::Point* mutable_position();
  void set_allocated_position(::TSP::Point* position);
  private:
  const ::TSP::Point& _internal_position() const;
  ::TSP::Point* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::TSP::Point* position);
  ::TSP::Point* unsafe_arena_release_position();

  // optional .TSP.Size size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::TSP::Size& size() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_size();
  ::TSP::Size* mutable_size();
  void set_allocated_size(::TSP::Size* size);
  private:
  const ::TSP::Size& _internal_size() const;
  ::TSP::Size* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::TSP::Size* size);
  ::TSP::Size* unsafe_arena_release_size();

  // optional uint32 flags = 3;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_flags() const;
  void _internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float angle = 4;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.GeometryArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Point* position_;
  ::TSP::Size* size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 flags_;
  float angle_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class PointPathSourceArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.PointPathSourceArchive) */ {
 public:
  inline PointPathSourceArchive() : PointPathSourceArchive(nullptr) {}
  ~PointPathSourceArchive() override;
  explicit constexpr PointPathSourceArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointPathSourceArchive(const PointPathSourceArchive& from);
  PointPathSourceArchive(PointPathSourceArchive&& from) noexcept
    : PointPathSourceArchive() {
    *this = ::std::move(from);
  }

  inline PointPathSourceArchive& operator=(const PointPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointPathSourceArchive& operator=(PointPathSourceArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointPathSourceArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointPathSourceArchive* internal_default_instance() {
    return reinterpret_cast<const PointPathSourceArchive*>(
               &_PointPathSourceArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PointPathSourceArchive& a, PointPathSourceArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PointPathSourceArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointPathSourceArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PointPathSourceArchive* New() const final {
    return CreateMaybeMessage<PointPathSourceArchive>(nullptr);
  }

  PointPathSourceArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PointPathSourceArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PointPathSourceArchive& from);
  void MergeFrom(const PointPathSourceArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointPathSourceArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.PointPathSourceArchive";
  }
  protected:
  explicit PointPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PointPathSourceArchive_PointPathSourceType PointPathSourceType;
  static constexpr PointPathSourceType kTSDLeftSingleArrow =
    PointPathSourceArchive_PointPathSourceType_kTSDLeftSingleArrow;
  static constexpr PointPathSourceType kTSDRightSingleArrow =
    PointPathSourceArchive_PointPathSourceType_kTSDRightSingleArrow;
  static constexpr PointPathSourceType kTSDDoubleArrow =
    PointPathSourceArchive_PointPathSourceType_kTSDDoubleArrow;
  static constexpr PointPathSourceType kTSDStar =
    PointPathSourceArchive_PointPathSourceType_kTSDStar;
  static constexpr PointPathSourceType kTSDPlus =
    PointPathSourceArchive_PointPathSourceType_kTSDPlus;
  static inline bool PointPathSourceType_IsValid(int value) {
    return PointPathSourceArchive_PointPathSourceType_IsValid(value);
  }
  static constexpr PointPathSourceType PointPathSourceType_MIN =
    PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MIN;
  static constexpr PointPathSourceType PointPathSourceType_MAX =
    PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MAX;
  static constexpr int PointPathSourceType_ARRAYSIZE =
    PointPathSourceArchive_PointPathSourceType_PointPathSourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PointPathSourceType_descriptor() {
    return PointPathSourceArchive_PointPathSourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& PointPathSourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PointPathSourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PointPathSourceType_Name.");
    return PointPathSourceArchive_PointPathSourceType_Name(enum_t_value);
  }
  static inline bool PointPathSourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PointPathSourceType* value) {
    return PointPathSourceArchive_PointPathSourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 2,
    kNaturalSizeFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional .TSP.Point point = 2;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::TSP::Point& point() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Point* release_point();
  ::TSP::Point* mutable_point();
  void set_allocated_point(::TSP::Point* point);
  private:
  const ::TSP::Point& _internal_point() const;
  ::TSP::Point* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::TSP::Point* point);
  ::TSP::Point* unsafe_arena_release_point();

  // optional .TSP.Size naturalSize = 3;
  bool has_naturalsize() const;
  private:
  bool _internal_has_naturalsize() const;
  public:
  void clear_naturalsize();
  const ::TSP::Size& naturalsize() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_naturalsize();
  ::TSP::Size* mutable_naturalsize();
  void set_allocated_naturalsize(::TSP::Size* naturalsize);
  private:
  const ::TSP::Size& _internal_naturalsize() const;
  ::TSP::Size* _internal_mutable_naturalsize();
  public:
  void unsafe_arena_set_allocated_naturalsize(
      ::TSP::Size* naturalsize);
  ::TSP::Size* unsafe_arena_release_naturalsize();

  // optional .TSD.PointPathSourceArchive.PointPathSourceType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::PointPathSourceArchive_PointPathSourceType type() const;
  void set_type(::TSD::PointPathSourceArchive_PointPathSourceType value);
  private:
  ::TSD::PointPathSourceArchive_PointPathSourceType _internal_type() const;
  void _internal_set_type(::TSD::PointPathSourceArchive_PointPathSourceType value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.PointPathSourceArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Point* point_;
  ::TSP::Size* naturalsize_;
  int type_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ScalarPathSourceArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ScalarPathSourceArchive) */ {
 public:
  inline ScalarPathSourceArchive() : ScalarPathSourceArchive(nullptr) {}
  ~ScalarPathSourceArchive() override;
  explicit constexpr ScalarPathSourceArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScalarPathSourceArchive(const ScalarPathSourceArchive& from);
  ScalarPathSourceArchive(ScalarPathSourceArchive&& from) noexcept
    : ScalarPathSourceArchive() {
    *this = ::std::move(from);
  }

  inline ScalarPathSourceArchive& operator=(const ScalarPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScalarPathSourceArchive& operator=(ScalarPathSourceArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScalarPathSourceArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScalarPathSourceArchive* internal_default_instance() {
    return reinterpret_cast<const ScalarPathSourceArchive*>(
               &_ScalarPathSourceArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ScalarPathSourceArchive& a, ScalarPathSourceArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ScalarPathSourceArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScalarPathSourceArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScalarPathSourceArchive* New() const final {
    return CreateMaybeMessage<ScalarPathSourceArchive>(nullptr);
  }

  ScalarPathSourceArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScalarPathSourceArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScalarPathSourceArchive& from);
  void MergeFrom(const ScalarPathSourceArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScalarPathSourceArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ScalarPathSourceArchive";
  }
  protected:
  explicit ScalarPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceType;
  static constexpr ScalarPathSourceType kTSDRoundedRectangle =
    ScalarPathSourceArchive_ScalarPathSourceType_kTSDRoundedRectangle;
  static constexpr ScalarPathSourceType kTSDRegularPolygon =
    ScalarPathSourceArchive_ScalarPathSourceType_kTSDRegularPolygon;
  static constexpr ScalarPathSourceType kTSDChevron =
    ScalarPathSourceArchive_ScalarPathSourceType_kTSDChevron;
  static inline bool ScalarPathSourceType_IsValid(int value) {
    return ScalarPathSourceArchive_ScalarPathSourceType_IsValid(value);
  }
  static constexpr ScalarPathSourceType ScalarPathSourceType_MIN =
    ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MIN;
  static constexpr ScalarPathSourceType ScalarPathSourceType_MAX =
    ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MAX;
  static constexpr int ScalarPathSourceType_ARRAYSIZE =
    ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScalarPathSourceType_descriptor() {
    return ScalarPathSourceArchive_ScalarPathSourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& ScalarPathSourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScalarPathSourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScalarPathSourceType_Name.");
    return ScalarPathSourceArchive_ScalarPathSourceType_Name(enum_t_value);
  }
  static inline bool ScalarPathSourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScalarPathSourceType* value) {
    return ScalarPathSourceArchive_ScalarPathSourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNaturalSizeFieldNumber = 3,
    kTypeFieldNumber = 1,
    kScalarFieldNumber = 2,
    kIsCurveContinuousFieldNumber = 4,
  };
  // optional .TSP.Size naturalSize = 3;
  bool has_naturalsize() const;
  private:
  bool _internal_has_naturalsize() const;
  public:
  void clear_naturalsize();
  const ::TSP::Size& naturalsize() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_naturalsize();
  ::TSP::Size* mutable_naturalsize();
  void set_allocated_naturalsize(::TSP::Size* naturalsize);
  private:
  const ::TSP::Size& _internal_naturalsize() const;
  ::TSP::Size* _internal_mutable_naturalsize();
  public:
  void unsafe_arena_set_allocated_naturalsize(
      ::TSP::Size* naturalsize);
  ::TSP::Size* unsafe_arena_release_naturalsize();

  // optional .TSD.ScalarPathSourceArchive.ScalarPathSourceType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::ScalarPathSourceArchive_ScalarPathSourceType type() const;
  void set_type(::TSD::ScalarPathSourceArchive_ScalarPathSourceType value);
  private:
  ::TSD::ScalarPathSourceArchive_ScalarPathSourceType _internal_type() const;
  void _internal_set_type(::TSD::ScalarPathSourceArchive_ScalarPathSourceType value);
  public:

  // optional float scalar = 2;
  bool has_scalar() const;
  private:
  bool _internal_has_scalar() const;
  public:
  void clear_scalar();
  float scalar() const;
  void set_scalar(float value);
  private:
  float _internal_scalar() const;
  void _internal_set_scalar(float value);
  public:

  // optional bool is_curve_continuous = 4;
  bool has_is_curve_continuous() const;
  private:
  bool _internal_has_is_curve_continuous() const;
  public:
  void clear_is_curve_continuous();
  bool is_curve_continuous() const;
  void set_is_curve_continuous(bool value);
  private:
  bool _internal_is_curve_continuous() const;
  void _internal_set_is_curve_continuous(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ScalarPathSourceArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Size* naturalsize_;
  int type_;
  float scalar_;
  bool is_curve_continuous_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class BezierPathSourceArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.BezierPathSourceArchive) */ {
 public:
  inline BezierPathSourceArchive() : BezierPathSourceArchive(nullptr) {}
  ~BezierPathSourceArchive() override;
  explicit constexpr BezierPathSourceArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BezierPathSourceArchive(const BezierPathSourceArchive& from);
  BezierPathSourceArchive(BezierPathSourceArchive&& from) noexcept
    : BezierPathSourceArchive() {
    *this = ::std::move(from);
  }

  inline BezierPathSourceArchive& operator=(const BezierPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline BezierPathSourceArchive& operator=(BezierPathSourceArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BezierPathSourceArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const BezierPathSourceArchive* internal_default_instance() {
    return reinterpret_cast<const BezierPathSourceArchive*>(
               &_BezierPathSourceArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BezierPathSourceArchive& a, BezierPathSourceArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(BezierPathSourceArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BezierPathSourceArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BezierPathSourceArchive* New() const final {
    return CreateMaybeMessage<BezierPathSourceArchive>(nullptr);
  }

  BezierPathSourceArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BezierPathSourceArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BezierPathSourceArchive& from);
  void MergeFrom(const BezierPathSourceArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BezierPathSourceArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.BezierPathSourceArchive";
  }
  protected:
  explicit BezierPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathStringFieldNumber = 1,
    kNaturalSizeFieldNumber = 2,
    kPathFieldNumber = 3,
  };
  // optional string path_string = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_path_string() const;
  private:
  bool _internal_has_path_string() const;
  public:
  PROTOBUF_DEPRECATED void clear_path_string();
  PROTOBUF_DEPRECATED const std::string& path_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_path_string(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_path_string();
  PROTOBUF_DEPRECATED std::string* release_path_string();
  PROTOBUF_DEPRECATED void set_allocated_path_string(std::string* path_string);
  private:
  const std::string& _internal_path_string() const;
  void _internal_set_path_string(const std::string& value);
  std::string* _internal_mutable_path_string();
  public:

  // optional .TSP.Size naturalSize = 2;
  bool has_naturalsize() const;
  private:
  bool _internal_has_naturalsize() const;
  public:
  void clear_naturalsize();
  const ::TSP::Size& naturalsize() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_naturalsize();
  ::TSP::Size* mutable_naturalsize();
  void set_allocated_naturalsize(::TSP::Size* naturalsize);
  private:
  const ::TSP::Size& _internal_naturalsize() const;
  ::TSP::Size* _internal_mutable_naturalsize();
  public:
  void unsafe_arena_set_allocated_naturalsize(
      ::TSP::Size* naturalsize);
  ::TSP::Size* unsafe_arena_release_naturalsize();

  // optional .TSP.Path path = 3;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::TSP::Path& path() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Path* release_path();
  ::TSP::Path* mutable_path();
  void set_allocated_path(::TSP::Path* path);
  private:
  const ::TSP::Path& _internal_path() const;
  ::TSP::Path* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::TSP::Path* path);
  ::TSP::Path* unsafe_arena_release_path();

  // @@protoc_insertion_point(class_scope:TSD.BezierPathSourceArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_string_;
  ::TSP::Size* naturalsize_;
  ::TSP::Path* path_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class CalloutPathSourceArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.CalloutPathSourceArchive) */ {
 public:
  inline CalloutPathSourceArchive() : CalloutPathSourceArchive(nullptr) {}
  ~CalloutPathSourceArchive() override;
  explicit constexpr CalloutPathSourceArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CalloutPathSourceArchive(const CalloutPathSourceArchive& from);
  CalloutPathSourceArchive(CalloutPathSourceArchive&& from) noexcept
    : CalloutPathSourceArchive() {
    *this = ::std::move(from);
  }

  inline CalloutPathSourceArchive& operator=(const CalloutPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CalloutPathSourceArchive& operator=(CalloutPathSourceArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CalloutPathSourceArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CalloutPathSourceArchive* internal_default_instance() {
    return reinterpret_cast<const CalloutPathSourceArchive*>(
               &_CalloutPathSourceArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CalloutPathSourceArchive& a, CalloutPathSourceArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CalloutPathSourceArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CalloutPathSourceArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CalloutPathSourceArchive* New() const final {
    return CreateMaybeMessage<CalloutPathSourceArchive>(nullptr);
  }

  CalloutPathSourceArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CalloutPathSourceArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CalloutPathSourceArchive& from);
  void MergeFrom(const CalloutPathSourceArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CalloutPathSourceArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.CalloutPathSourceArchive";
  }
  protected:
  explicit CalloutPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNaturalSizeFieldNumber = 1,
    kTailPositionFieldNumber = 2,
    kTailSizeFieldNumber = 3,
    kCornerRadiusFieldNumber = 4,
    kCenterTailFieldNumber = 5,
  };
  // optional .TSP.Size natural_size = 1;
  bool has_natural_size() const;
  private:
  bool _internal_has_natural_size() const;
  public:
  void clear_natural_size();
  const ::TSP::Size& natural_size() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_natural_size();
  ::TSP::Size* mutable_natural_size();
  void set_allocated_natural_size(::TSP::Size* natural_size);
  private:
  const ::TSP::Size& _internal_natural_size() const;
  ::TSP::Size* _internal_mutable_natural_size();
  public:
  void unsafe_arena_set_allocated_natural_size(
      ::TSP::Size* natural_size);
  ::TSP::Size* unsafe_arena_release_natural_size();

  // optional .TSP.Point tail_position = 2;
  bool has_tail_position() const;
  private:
  bool _internal_has_tail_position() const;
  public:
  void clear_tail_position();
  const ::TSP::Point& tail_position() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Point* release_tail_position();
  ::TSP::Point* mutable_tail_position();
  void set_allocated_tail_position(::TSP::Point* tail_position);
  private:
  const ::TSP::Point& _internal_tail_position() const;
  ::TSP::Point* _internal_mutable_tail_position();
  public:
  void unsafe_arena_set_allocated_tail_position(
      ::TSP::Point* tail_position);
  ::TSP::Point* unsafe_arena_release_tail_position();

  // optional float tail_size = 3;
  bool has_tail_size() const;
  private:
  bool _internal_has_tail_size() const;
  public:
  void clear_tail_size();
  float tail_size() const;
  void set_tail_size(float value);
  private:
  float _internal_tail_size() const;
  void _internal_set_tail_size(float value);
  public:

  // optional float corner_radius = 4;
  bool has_corner_radius() const;
  private:
  bool _internal_has_corner_radius() const;
  public:
  void clear_corner_radius();
  float corner_radius() const;
  void set_corner_radius(float value);
  private:
  float _internal_corner_radius() const;
  void _internal_set_corner_radius(float value);
  public:

  // optional bool center_tail = 5;
  bool has_center_tail() const;
  private:
  bool _internal_has_center_tail() const;
  public:
  void clear_center_tail();
  bool center_tail() const;
  void set_center_tail(bool value);
  private:
  bool _internal_center_tail() const;
  void _internal_set_center_tail(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.CalloutPathSourceArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Size* natural_size_;
  ::TSP::Point* tail_position_;
  float tail_size_;
  float corner_radius_;
  bool center_tail_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ConnectionLinePathSourceArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ConnectionLinePathSourceArchive) */ {
 public:
  inline ConnectionLinePathSourceArchive() : ConnectionLinePathSourceArchive(nullptr) {}
  ~ConnectionLinePathSourceArchive() override;
  explicit constexpr ConnectionLinePathSourceArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionLinePathSourceArchive(const ConnectionLinePathSourceArchive& from);
  ConnectionLinePathSourceArchive(ConnectionLinePathSourceArchive&& from) noexcept
    : ConnectionLinePathSourceArchive() {
    *this = ::std::move(from);
  }

  inline ConnectionLinePathSourceArchive& operator=(const ConnectionLinePathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionLinePathSourceArchive& operator=(ConnectionLinePathSourceArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionLinePathSourceArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionLinePathSourceArchive* internal_default_instance() {
    return reinterpret_cast<const ConnectionLinePathSourceArchive*>(
               &_ConnectionLinePathSourceArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ConnectionLinePathSourceArchive& a, ConnectionLinePathSourceArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionLinePathSourceArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionLinePathSourceArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnectionLinePathSourceArchive* New() const final {
    return CreateMaybeMessage<ConnectionLinePathSourceArchive>(nullptr);
  }

  ConnectionLinePathSourceArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionLinePathSourceArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConnectionLinePathSourceArchive& from);
  void MergeFrom(const ConnectionLinePathSourceArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionLinePathSourceArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ConnectionLinePathSourceArchive";
  }
  protected:
  explicit ConnectionLinePathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceType;
  static constexpr ConnectionLinePathSourceType kTSDConnectionLineTypeQuadratic =
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeQuadratic;
  static constexpr ConnectionLinePathSourceType kTSDConnectionLineTypeOrthogonal =
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeOrthogonal;
  static inline bool ConnectionLinePathSourceType_IsValid(int value) {
    return ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_IsValid(value);
  }
  static constexpr ConnectionLinePathSourceType ConnectionLinePathSourceType_MIN =
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MIN;
  static constexpr ConnectionLinePathSourceType ConnectionLinePathSourceType_MAX =
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MAX;
  static constexpr int ConnectionLinePathSourceType_ARRAYSIZE =
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ConnectionLinePathSourceType_descriptor() {
    return ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& ConnectionLinePathSourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConnectionLinePathSourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConnectionLinePathSourceType_Name.");
    return ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_Name(enum_t_value);
  }
  static inline bool ConnectionLinePathSourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConnectionLinePathSourceType* value) {
    return ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kTypeFieldNumber = 2,
    kOutsetFromFieldNumber = 3,
    kOutsetToFieldNumber = 4,
  };
  // required .TSD.BezierPathSourceArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::BezierPathSourceArchive& super() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::BezierPathSourceArchive* release_super();
  ::TSD::BezierPathSourceArchive* mutable_super();
  void set_allocated_super(::TSD::BezierPathSourceArchive* super);
  private:
  const ::TSD::BezierPathSourceArchive& _internal_super() const;
  ::TSD::BezierPathSourceArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::BezierPathSourceArchive* super);
  ::TSD::BezierPathSourceArchive* unsafe_arena_release_super();

  // optional .TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType type() const;
  void set_type(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType value);
  private:
  ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType _internal_type() const;
  void _internal_set_type(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType value);
  public:

  // optional float outset_from = 3;
  bool has_outset_from() const;
  private:
  bool _internal_has_outset_from() const;
  public:
  void clear_outset_from();
  float outset_from() const;
  void set_outset_from(float value);
  private:
  float _internal_outset_from() const;
  void _internal_set_outset_from(float value);
  public:

  // optional float outset_to = 4;
  bool has_outset_to() const;
  private:
  bool _internal_has_outset_to() const;
  public:
  void clear_outset_to();
  float outset_to() const;
  void set_outset_to(float value);
  private:
  float _internal_outset_to() const;
  void _internal_set_outset_to(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ConnectionLinePathSourceArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSD::BezierPathSourceArchive* super_;
  int type_;
  float outset_from_;
  float outset_to_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class EditableBezierPathSourceArchive_Node PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.EditableBezierPathSourceArchive.Node) */ {
 public:
  inline EditableBezierPathSourceArchive_Node() : EditableBezierPathSourceArchive_Node(nullptr) {}
  ~EditableBezierPathSourceArchive_Node() override;
  explicit constexpr EditableBezierPathSourceArchive_Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditableBezierPathSourceArchive_Node(const EditableBezierPathSourceArchive_Node& from);
  EditableBezierPathSourceArchive_Node(EditableBezierPathSourceArchive_Node&& from) noexcept
    : EditableBezierPathSourceArchive_Node() {
    *this = ::std::move(from);
  }

  inline EditableBezierPathSourceArchive_Node& operator=(const EditableBezierPathSourceArchive_Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditableBezierPathSourceArchive_Node& operator=(EditableBezierPathSourceArchive_Node&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditableBezierPathSourceArchive_Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditableBezierPathSourceArchive_Node* internal_default_instance() {
    return reinterpret_cast<const EditableBezierPathSourceArchive_Node*>(
               &_EditableBezierPathSourceArchive_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EditableBezierPathSourceArchive_Node& a, EditableBezierPathSourceArchive_Node& b) {
    a.Swap(&b);
  }
  inline void Swap(EditableBezierPathSourceArchive_Node* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditableBezierPathSourceArchive_Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EditableBezierPathSourceArchive_Node* New() const final {
    return CreateMaybeMessage<EditableBezierPathSourceArchive_Node>(nullptr);
  }

  EditableBezierPathSourceArchive_Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EditableBezierPathSourceArchive_Node>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EditableBezierPathSourceArchive_Node& from);
  void MergeFrom(const EditableBezierPathSourceArchive_Node& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditableBezierPathSourceArchive_Node* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.EditableBezierPathSourceArchive.Node";
  }
  protected:
  explicit EditableBezierPathSourceArchive_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInControlPointFieldNumber = 1,
    kNodePointFieldNumber = 2,
    kOutControlPointFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // required .TSP.Point inControlPoint = 1;
  bool has_incontrolpoint() const;
  private:
  bool _internal_has_incontrolpoint() const;
  public:
  void clear_incontrolpoint();
  const ::TSP::Point& incontrolpoint() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Point* release_incontrolpoint();
  ::TSP::Point* mutable_incontrolpoint();
  void set_allocated_incontrolpoint(::TSP::Point* incontrolpoint);
  private:
  const ::TSP::Point& _internal_incontrolpoint() const;
  ::TSP::Point* _internal_mutable_incontrolpoint();
  public:
  void unsafe_arena_set_allocated_incontrolpoint(
      ::TSP::Point* incontrolpoint);
  ::TSP::Point* unsafe_arena_release_incontrolpoint();

  // required .TSP.Point nodePoint = 2;
  bool has_nodepoint() const;
  private:
  bool _internal_has_nodepoint() const;
  public:
  void clear_nodepoint();
  const ::TSP::Point& nodepoint() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Point* release_nodepoint();
  ::TSP::Point* mutable_nodepoint();
  void set_allocated_nodepoint(::TSP::Point* nodepoint);
  private:
  const ::TSP::Point& _internal_nodepoint() const;
  ::TSP::Point* _internal_mutable_nodepoint();
  public:
  void unsafe_arena_set_allocated_nodepoint(
      ::TSP::Point* nodepoint);
  ::TSP::Point* unsafe_arena_release_nodepoint();

  // required .TSP.Point outControlPoint = 3;
  bool has_outcontrolpoint() const;
  private:
  bool _internal_has_outcontrolpoint() const;
  public:
  void clear_outcontrolpoint();
  const ::TSP::Point& outcontrolpoint() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Point* release_outcontrolpoint();
  ::TSP::Point* mutable_outcontrolpoint();
  void set_allocated_outcontrolpoint(::TSP::Point* outcontrolpoint);
  private:
  const ::TSP::Point& _internal_outcontrolpoint() const;
  ::TSP::Point* _internal_mutable_outcontrolpoint();
  public:
  void unsafe_arena_set_allocated_outcontrolpoint(
      ::TSP::Point* outcontrolpoint);
  ::TSP::Point* unsafe_arena_release_outcontrolpoint();

  // required .TSD.EditableBezierPathSourceArchive.NodeType type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::EditableBezierPathSourceArchive_NodeType type() const;
  void set_type(::TSD::EditableBezierPathSourceArchive_NodeType value);
  private:
  ::TSD::EditableBezierPathSourceArchive_NodeType _internal_type() const;
  void _internal_set_type(::TSD::EditableBezierPathSourceArchive_NodeType value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.EditableBezierPathSourceArchive.Node)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Point* incontrolpoint_;
  ::TSP::Point* nodepoint_;
  ::TSP::Point* outcontrolpoint_;
  int type_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class EditableBezierPathSourceArchive_Subpath PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.EditableBezierPathSourceArchive.Subpath) */ {
 public:
  inline EditableBezierPathSourceArchive_Subpath() : EditableBezierPathSourceArchive_Subpath(nullptr) {}
  ~EditableBezierPathSourceArchive_Subpath() override;
  explicit constexpr EditableBezierPathSourceArchive_Subpath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditableBezierPathSourceArchive_Subpath(const EditableBezierPathSourceArchive_Subpath& from);
  EditableBezierPathSourceArchive_Subpath(EditableBezierPathSourceArchive_Subpath&& from) noexcept
    : EditableBezierPathSourceArchive_Subpath() {
    *this = ::std::move(from);
  }

  inline EditableBezierPathSourceArchive_Subpath& operator=(const EditableBezierPathSourceArchive_Subpath& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditableBezierPathSourceArchive_Subpath& operator=(EditableBezierPathSourceArchive_Subpath&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditableBezierPathSourceArchive_Subpath& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditableBezierPathSourceArchive_Subpath* internal_default_instance() {
    return reinterpret_cast<const EditableBezierPathSourceArchive_Subpath*>(
               &_EditableBezierPathSourceArchive_Subpath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EditableBezierPathSourceArchive_Subpath& a, EditableBezierPathSourceArchive_Subpath& b) {
    a.Swap(&b);
  }
  inline void Swap(EditableBezierPathSourceArchive_Subpath* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditableBezierPathSourceArchive_Subpath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EditableBezierPathSourceArchive_Subpath* New() const final {
    return CreateMaybeMessage<EditableBezierPathSourceArchive_Subpath>(nullptr);
  }

  EditableBezierPathSourceArchive_Subpath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EditableBezierPathSourceArchive_Subpath>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EditableBezierPathSourceArchive_Subpath& from);
  void MergeFrom(const EditableBezierPathSourceArchive_Subpath& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditableBezierPathSourceArchive_Subpath* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.EditableBezierPathSourceArchive.Subpath";
  }
  protected:
  explicit EditableBezierPathSourceArchive_Subpath(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
    kClosedFieldNumber = 2,
  };
  // repeated .TSD.EditableBezierPathSourceArchive.Node nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::TSD::EditableBezierPathSourceArchive_Node* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node >*
      mutable_nodes();
  private:
  const ::TSD::EditableBezierPathSourceArchive_Node& _internal_nodes(int index) const;
  ::TSD::EditableBezierPathSourceArchive_Node* _internal_add_nodes();
  public:
  const ::TSD::EditableBezierPathSourceArchive_Node& nodes(int index) const;
  ::TSD::EditableBezierPathSourceArchive_Node* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node >&
      nodes() const;

  // required bool closed = 2;
  bool has_closed() const;
  private:
  bool _internal_has_closed() const;
  public:
  void clear_closed();
  bool closed() const;
  void set_closed(bool value);
  private:
  bool _internal_closed() const;
  void _internal_set_closed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.EditableBezierPathSourceArchive.Subpath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node > nodes_;
  bool closed_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class EditableBezierPathSourceArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.EditableBezierPathSourceArchive) */ {
 public:
  inline EditableBezierPathSourceArchive() : EditableBezierPathSourceArchive(nullptr) {}
  ~EditableBezierPathSourceArchive() override;
  explicit constexpr EditableBezierPathSourceArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditableBezierPathSourceArchive(const EditableBezierPathSourceArchive& from);
  EditableBezierPathSourceArchive(EditableBezierPathSourceArchive&& from) noexcept
    : EditableBezierPathSourceArchive() {
    *this = ::std::move(from);
  }

  inline EditableBezierPathSourceArchive& operator=(const EditableBezierPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditableBezierPathSourceArchive& operator=(EditableBezierPathSourceArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditableBezierPathSourceArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditableBezierPathSourceArchive* internal_default_instance() {
    return reinterpret_cast<const EditableBezierPathSourceArchive*>(
               &_EditableBezierPathSourceArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EditableBezierPathSourceArchive& a, EditableBezierPathSourceArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(EditableBezierPathSourceArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditableBezierPathSourceArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EditableBezierPathSourceArchive* New() const final {
    return CreateMaybeMessage<EditableBezierPathSourceArchive>(nullptr);
  }

  EditableBezierPathSourceArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EditableBezierPathSourceArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EditableBezierPathSourceArchive& from);
  void MergeFrom(const EditableBezierPathSourceArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditableBezierPathSourceArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.EditableBezierPathSourceArchive";
  }
  protected:
  explicit EditableBezierPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EditableBezierPathSourceArchive_Node Node;
  typedef EditableBezierPathSourceArchive_Subpath Subpath;

  typedef EditableBezierPathSourceArchive_NodeType NodeType;
  static constexpr NodeType sharp =
    EditableBezierPathSourceArchive_NodeType_sharp;
  static constexpr NodeType bezier =
    EditableBezierPathSourceArchive_NodeType_bezier;
  static constexpr NodeType smooth =
    EditableBezierPathSourceArchive_NodeType_smooth;
  static inline bool NodeType_IsValid(int value) {
    return EditableBezierPathSourceArchive_NodeType_IsValid(value);
  }
  static constexpr NodeType NodeType_MIN =
    EditableBezierPathSourceArchive_NodeType_NodeType_MIN;
  static constexpr NodeType NodeType_MAX =
    EditableBezierPathSourceArchive_NodeType_NodeType_MAX;
  static constexpr int NodeType_ARRAYSIZE =
    EditableBezierPathSourceArchive_NodeType_NodeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NodeType_descriptor() {
    return EditableBezierPathSourceArchive_NodeType_descriptor();
  }
  template<typename T>
  static inline const std::string& NodeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NodeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NodeType_Name.");
    return EditableBezierPathSourceArchive_NodeType_Name(enum_t_value);
  }
  static inline bool NodeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NodeType* value) {
    return EditableBezierPathSourceArchive_NodeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSubpathsFieldNumber = 1,
    kNaturalSizeFieldNumber = 2,
  };
  // repeated .TSD.EditableBezierPathSourceArchive.Subpath subpaths = 1;
  int subpaths_size() const;
  private:
  int _internal_subpaths_size() const;
  public:
  void clear_subpaths();
  ::TSD::EditableBezierPathSourceArchive_Subpath* mutable_subpaths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath >*
      mutable_subpaths();
  private:
  const ::TSD::EditableBezierPathSourceArchive_Subpath& _internal_subpaths(int index) const;
  ::TSD::EditableBezierPathSourceArchive_Subpath* _internal_add_subpaths();
  public:
  const ::TSD::EditableBezierPathSourceArchive_Subpath& subpaths(int index) const;
  ::TSD::EditableBezierPathSourceArchive_Subpath* add_subpaths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath >&
      subpaths() const;

  // optional .TSP.Size naturalSize = 2;
  bool has_naturalsize() const;
  private:
  bool _internal_has_naturalsize() const;
  public:
  void clear_naturalsize();
  const ::TSP::Size& naturalsize() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_naturalsize();
  ::TSP::Size* mutable_naturalsize();
  void set_allocated_naturalsize(::TSP::Size* naturalsize);
  private:
  const ::TSP::Size& _internal_naturalsize() const;
  ::TSP::Size* _internal_mutable_naturalsize();
  public:
  void unsafe_arena_set_allocated_naturalsize(
      ::TSP::Size* naturalsize);
  ::TSP::Size* unsafe_arena_release_naturalsize();

  // @@protoc_insertion_point(class_scope:TSD.EditableBezierPathSourceArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath > subpaths_;
  ::TSP::Size* naturalsize_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class PathSourceArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.PathSourceArchive) */ {
 public:
  inline PathSourceArchive() : PathSourceArchive(nullptr) {}
  ~PathSourceArchive() override;
  explicit constexpr PathSourceArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathSourceArchive(const PathSourceArchive& from);
  PathSourceArchive(PathSourceArchive&& from) noexcept
    : PathSourceArchive() {
    *this = ::std::move(from);
  }

  inline PathSourceArchive& operator=(const PathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathSourceArchive& operator=(PathSourceArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathSourceArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathSourceArchive* internal_default_instance() {
    return reinterpret_cast<const PathSourceArchive*>(
               &_PathSourceArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PathSourceArchive& a, PathSourceArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PathSourceArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathSourceArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PathSourceArchive* New() const final {
    return CreateMaybeMessage<PathSourceArchive>(nullptr);
  }

  PathSourceArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PathSourceArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PathSourceArchive& from);
  void MergeFrom(const PathSourceArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathSourceArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.PathSourceArchive";
  }
  protected:
  explicit PathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalizationKeyFieldNumber = 9,
    kUserDefinedNameFieldNumber = 10,
    kPointPathSourceFieldNumber = 3,
    kScalarPathSourceFieldNumber = 4,
    kBezierPathSourceFieldNumber = 5,
    kCalloutPathSourceFieldNumber = 6,
    kConnectionLinePathSourceFieldNumber = 7,
    kEditableBezierPathSourceFieldNumber = 8,
    kHorizontalFlipFieldNumber = 1,
    kVerticalFlipFieldNumber = 2,
  };
  // optional string localizationKey = 9;
  bool has_localizationkey() const;
  private:
  bool _internal_has_localizationkey() const;
  public:
  void clear_localizationkey();
  const std::string& localizationkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_localizationkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_localizationkey();
  std::string* release_localizationkey();
  void set_allocated_localizationkey(std::string* localizationkey);
  private:
  const std::string& _internal_localizationkey() const;
  void _internal_set_localizationkey(const std::string& value);
  std::string* _internal_mutable_localizationkey();
  public:

  // optional string userDefinedName = 10;
  bool has_userdefinedname() const;
  private:
  bool _internal_has_userdefinedname() const;
  public:
  void clear_userdefinedname();
  const std::string& userdefinedname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userdefinedname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userdefinedname();
  std::string* release_userdefinedname();
  void set_allocated_userdefinedname(std::string* userdefinedname);
  private:
  const std::string& _internal_userdefinedname() const;
  void _internal_set_userdefinedname(const std::string& value);
  std::string* _internal_mutable_userdefinedname();
  public:

  // optional .TSD.PointPathSourceArchive point_path_source = 3;
  bool has_point_path_source() const;
  private:
  bool _internal_has_point_path_source() const;
  public:
  void clear_point_path_source();
  const ::TSD::PointPathSourceArchive& point_path_source() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::PointPathSourceArchive* release_point_path_source();
  ::TSD::PointPathSourceArchive* mutable_point_path_source();
  void set_allocated_point_path_source(::TSD::PointPathSourceArchive* point_path_source);
  private:
  const ::TSD::PointPathSourceArchive& _internal_point_path_source() const;
  ::TSD::PointPathSourceArchive* _internal_mutable_point_path_source();
  public:
  void unsafe_arena_set_allocated_point_path_source(
      ::TSD::PointPathSourceArchive* point_path_source);
  ::TSD::PointPathSourceArchive* unsafe_arena_release_point_path_source();

  // optional .TSD.ScalarPathSourceArchive scalar_path_source = 4;
  bool has_scalar_path_source() const;
  private:
  bool _internal_has_scalar_path_source() const;
  public:
  void clear_scalar_path_source();
  const ::TSD::ScalarPathSourceArchive& scalar_path_source() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::ScalarPathSourceArchive* release_scalar_path_source();
  ::TSD::ScalarPathSourceArchive* mutable_scalar_path_source();
  void set_allocated_scalar_path_source(::TSD::ScalarPathSourceArchive* scalar_path_source);
  private:
  const ::TSD::ScalarPathSourceArchive& _internal_scalar_path_source() const;
  ::TSD::ScalarPathSourceArchive* _internal_mutable_scalar_path_source();
  public:
  void unsafe_arena_set_allocated_scalar_path_source(
      ::TSD::ScalarPathSourceArchive* scalar_path_source);
  ::TSD::ScalarPathSourceArchive* unsafe_arena_release_scalar_path_source();

  // optional .TSD.BezierPathSourceArchive bezier_path_source = 5;
  bool has_bezier_path_source() const;
  private:
  bool _internal_has_bezier_path_source() const;
  public:
  void clear_bezier_path_source();
  const ::TSD::BezierPathSourceArchive& bezier_path_source() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::BezierPathSourceArchive* release_bezier_path_source();
  ::TSD::BezierPathSourceArchive* mutable_bezier_path_source();
  void set_allocated_bezier_path_source(::TSD::BezierPathSourceArchive* bezier_path_source);
  private:
  const ::TSD::BezierPathSourceArchive& _internal_bezier_path_source() const;
  ::TSD::BezierPathSourceArchive* _internal_mutable_bezier_path_source();
  public:
  void unsafe_arena_set_allocated_bezier_path_source(
      ::TSD::BezierPathSourceArchive* bezier_path_source);
  ::TSD::BezierPathSourceArchive* unsafe_arena_release_bezier_path_source();

  // optional .TSD.CalloutPathSourceArchive callout_path_source = 6;
  bool has_callout_path_source() const;
  private:
  bool _internal_has_callout_path_source() const;
  public:
  void clear_callout_path_source();
  const ::TSD::CalloutPathSourceArchive& callout_path_source() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::CalloutPathSourceArchive* release_callout_path_source();
  ::TSD::CalloutPathSourceArchive* mutable_callout_path_source();
  void set_allocated_callout_path_source(::TSD::CalloutPathSourceArchive* callout_path_source);
  private:
  const ::TSD::CalloutPathSourceArchive& _internal_callout_path_source() const;
  ::TSD::CalloutPathSourceArchive* _internal_mutable_callout_path_source();
  public:
  void unsafe_arena_set_allocated_callout_path_source(
      ::TSD::CalloutPathSourceArchive* callout_path_source);
  ::TSD::CalloutPathSourceArchive* unsafe_arena_release_callout_path_source();

  // optional .TSD.ConnectionLinePathSourceArchive connection_line_path_source = 7;
  bool has_connection_line_path_source() const;
  private:
  bool _internal_has_connection_line_path_source() const;
  public:
  void clear_connection_line_path_source();
  const ::TSD::ConnectionLinePathSourceArchive& connection_line_path_source() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::ConnectionLinePathSourceArchive* release_connection_line_path_source();
  ::TSD::ConnectionLinePathSourceArchive* mutable_connection_line_path_source();
  void set_allocated_connection_line_path_source(::TSD::ConnectionLinePathSourceArchive* connection_line_path_source);
  private:
  const ::TSD::ConnectionLinePathSourceArchive& _internal_connection_line_path_source() const;
  ::TSD::ConnectionLinePathSourceArchive* _internal_mutable_connection_line_path_source();
  public:
  void unsafe_arena_set_allocated_connection_line_path_source(
      ::TSD::ConnectionLinePathSourceArchive* connection_line_path_source);
  ::TSD::ConnectionLinePathSourceArchive* unsafe_arena_release_connection_line_path_source();

  // optional .TSD.EditableBezierPathSourceArchive editable_bezier_path_source = 8;
  bool has_editable_bezier_path_source() const;
  private:
  bool _internal_has_editable_bezier_path_source() const;
  public:
  void clear_editable_bezier_path_source();
  const ::TSD::EditableBezierPathSourceArchive& editable_bezier_path_source() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::EditableBezierPathSourceArchive* release_editable_bezier_path_source();
  ::TSD::EditableBezierPathSourceArchive* mutable_editable_bezier_path_source();
  void set_allocated_editable_bezier_path_source(::TSD::EditableBezierPathSourceArchive* editable_bezier_path_source);
  private:
  const ::TSD::EditableBezierPathSourceArchive& _internal_editable_bezier_path_source() const;
  ::TSD::EditableBezierPathSourceArchive* _internal_mutable_editable_bezier_path_source();
  public:
  void unsafe_arena_set_allocated_editable_bezier_path_source(
      ::TSD::EditableBezierPathSourceArchive* editable_bezier_path_source);
  ::TSD::EditableBezierPathSourceArchive* unsafe_arena_release_editable_bezier_path_source();

  // optional bool horizontalFlip = 1;
  bool has_horizontalflip() const;
  private:
  bool _internal_has_horizontalflip() const;
  public:
  void clear_horizontalflip();
  bool horizontalflip() const;
  void set_horizontalflip(bool value);
  private:
  bool _internal_horizontalflip() const;
  void _internal_set_horizontalflip(bool value);
  public:

  // optional bool verticalFlip = 2;
  bool has_verticalflip() const;
  private:
  bool _internal_has_verticalflip() const;
  public:
  void clear_verticalflip();
  bool verticalflip() const;
  void set_verticalflip(bool value);
  private:
  bool _internal_verticalflip() const;
  void _internal_set_verticalflip(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.PathSourceArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr localizationkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userdefinedname_;
  ::TSD::PointPathSourceArchive* point_path_source_;
  ::TSD::ScalarPathSourceArchive* scalar_path_source_;
  ::TSD::BezierPathSourceArchive* bezier_path_source_;
  ::TSD::CalloutPathSourceArchive* callout_path_source_;
  ::TSD::ConnectionLinePathSourceArchive* connection_line_path_source_;
  ::TSD::EditableBezierPathSourceArchive* editable_bezier_path_source_;
  bool horizontalflip_;
  bool verticalflip_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class AngleGradientArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.AngleGradientArchive) */ {
 public:
  inline AngleGradientArchive() : AngleGradientArchive(nullptr) {}
  ~AngleGradientArchive() override;
  explicit constexpr AngleGradientArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AngleGradientArchive(const AngleGradientArchive& from);
  AngleGradientArchive(AngleGradientArchive&& from) noexcept
    : AngleGradientArchive() {
    *this = ::std::move(from);
  }

  inline AngleGradientArchive& operator=(const AngleGradientArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline AngleGradientArchive& operator=(AngleGradientArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AngleGradientArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const AngleGradientArchive* internal_default_instance() {
    return reinterpret_cast<const AngleGradientArchive*>(
               &_AngleGradientArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AngleGradientArchive& a, AngleGradientArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(AngleGradientArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AngleGradientArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AngleGradientArchive* New() const final {
    return CreateMaybeMessage<AngleGradientArchive>(nullptr);
  }

  AngleGradientArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AngleGradientArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AngleGradientArchive& from);
  void MergeFrom(const AngleGradientArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AngleGradientArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.AngleGradientArchive";
  }
  protected:
  explicit AngleGradientArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGradientangleFieldNumber = 2,
  };
  // optional float gradientangle = 2;
  bool has_gradientangle() const;
  private:
  bool _internal_has_gradientangle() const;
  public:
  void clear_gradientangle();
  float gradientangle() const;
  void set_gradientangle(float value);
  private:
  float _internal_gradientangle() const;
  void _internal_set_gradientangle(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.AngleGradientArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float gradientangle_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class TransformGradientArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.TransformGradientArchive) */ {
 public:
  inline TransformGradientArchive() : TransformGradientArchive(nullptr) {}
  ~TransformGradientArchive() override;
  explicit constexpr TransformGradientArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransformGradientArchive(const TransformGradientArchive& from);
  TransformGradientArchive(TransformGradientArchive&& from) noexcept
    : TransformGradientArchive() {
    *this = ::std::move(from);
  }

  inline TransformGradientArchive& operator=(const TransformGradientArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransformGradientArchive& operator=(TransformGradientArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransformGradientArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransformGradientArchive* internal_default_instance() {
    return reinterpret_cast<const TransformGradientArchive*>(
               &_TransformGradientArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TransformGradientArchive& a, TransformGradientArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(TransformGradientArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransformGradientArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransformGradientArchive* New() const final {
    return CreateMaybeMessage<TransformGradientArchive>(nullptr);
  }

  TransformGradientArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransformGradientArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransformGradientArchive& from);
  void MergeFrom(const TransformGradientArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformGradientArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.TransformGradientArchive";
  }
  protected:
  explicit TransformGradientArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
    kBaseNaturalSizeFieldNumber = 3,
  };
  // optional .TSP.Point start = 1;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::TSP::Point& start() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Point* release_start();
  ::TSP::Point* mutable_start();
  void set_allocated_start(::TSP::Point* start);
  private:
  const ::TSP::Point& _internal_start() const;
  ::TSP::Point* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::TSP::Point* start);
  ::TSP::Point* unsafe_arena_release_start();

  // optional .TSP.Point end = 2;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::TSP::Point& end() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Point* release_end();
  ::TSP::Point* mutable_end();
  void set_allocated_end(::TSP::Point* end);
  private:
  const ::TSP::Point& _internal_end() const;
  ::TSP::Point* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::TSP::Point* end);
  ::TSP::Point* unsafe_arena_release_end();

  // optional .TSP.Size baseNaturalSize = 3;
  bool has_basenaturalsize() const;
  private:
  bool _internal_has_basenaturalsize() const;
  public:
  void clear_basenaturalsize();
  const ::TSP::Size& basenaturalsize() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_basenaturalsize();
  ::TSP::Size* mutable_basenaturalsize();
  void set_allocated_basenaturalsize(::TSP::Size* basenaturalsize);
  private:
  const ::TSP::Size& _internal_basenaturalsize() const;
  ::TSP::Size* _internal_mutable_basenaturalsize();
  public:
  void unsafe_arena_set_allocated_basenaturalsize(
      ::TSP::Size* basenaturalsize);
  ::TSP::Size* unsafe_arena_release_basenaturalsize();

  // @@protoc_insertion_point(class_scope:TSD.TransformGradientArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Point* start_;
  ::TSP::Point* end_;
  ::TSP::Size* basenaturalsize_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class GradientArchive_GradientStop PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.GradientArchive.GradientStop) */ {
 public:
  inline GradientArchive_GradientStop() : GradientArchive_GradientStop(nullptr) {}
  ~GradientArchive_GradientStop() override;
  explicit constexpr GradientArchive_GradientStop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GradientArchive_GradientStop(const GradientArchive_GradientStop& from);
  GradientArchive_GradientStop(GradientArchive_GradientStop&& from) noexcept
    : GradientArchive_GradientStop() {
    *this = ::std::move(from);
  }

  inline GradientArchive_GradientStop& operator=(const GradientArchive_GradientStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline GradientArchive_GradientStop& operator=(GradientArchive_GradientStop&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GradientArchive_GradientStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const GradientArchive_GradientStop* internal_default_instance() {
    return reinterpret_cast<const GradientArchive_GradientStop*>(
               &_GradientArchive_GradientStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GradientArchive_GradientStop& a, GradientArchive_GradientStop& b) {
    a.Swap(&b);
  }
  inline void Swap(GradientArchive_GradientStop* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GradientArchive_GradientStop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GradientArchive_GradientStop* New() const final {
    return CreateMaybeMessage<GradientArchive_GradientStop>(nullptr);
  }

  GradientArchive_GradientStop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GradientArchive_GradientStop>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GradientArchive_GradientStop& from);
  void MergeFrom(const GradientArchive_GradientStop& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GradientArchive_GradientStop* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.GradientArchive.GradientStop";
  }
  protected:
  explicit GradientArchive_GradientStop(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kFractionFieldNumber = 2,
    kInflectionFieldNumber = 3,
  };
  // optional .TSP.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::TSP::Color& color() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_color();
  ::TSP::Color* mutable_color();
  void set_allocated_color(::TSP::Color* color);
  private:
  const ::TSP::Color& _internal_color() const;
  ::TSP::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::TSP::Color* color);
  ::TSP::Color* unsafe_arena_release_color();

  // optional float fraction = 2;
  bool has_fraction() const;
  private:
  bool _internal_has_fraction() const;
  public:
  void clear_fraction();
  float fraction() const;
  void set_fraction(float value);
  private:
  float _internal_fraction() const;
  void _internal_set_fraction(float value);
  public:

  // optional float inflection = 3;
  bool has_inflection() const;
  private:
  bool _internal_has_inflection() const;
  public:
  void clear_inflection();
  float inflection() const;
  void set_inflection(float value);
  private:
  float _internal_inflection() const;
  void _internal_set_inflection(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.GradientArchive.GradientStop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Color* color_;
  float fraction_;
  float inflection_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class GradientArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.GradientArchive) */ {
 public:
  inline GradientArchive() : GradientArchive(nullptr) {}
  ~GradientArchive() override;
  explicit constexpr GradientArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GradientArchive(const GradientArchive& from);
  GradientArchive(GradientArchive&& from) noexcept
    : GradientArchive() {
    *this = ::std::move(from);
  }

  inline GradientArchive& operator=(const GradientArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline GradientArchive& operator=(GradientArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GradientArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const GradientArchive* internal_default_instance() {
    return reinterpret_cast<const GradientArchive*>(
               &_GradientArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GradientArchive& a, GradientArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(GradientArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GradientArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GradientArchive* New() const final {
    return CreateMaybeMessage<GradientArchive>(nullptr);
  }

  GradientArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GradientArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GradientArchive& from);
  void MergeFrom(const GradientArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GradientArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.GradientArchive";
  }
  protected:
  explicit GradientArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GradientArchive_GradientStop GradientStop;

  typedef GradientArchive_GradientType GradientType;
  static constexpr GradientType Linear =
    GradientArchive_GradientType_Linear;
  static constexpr GradientType Radial =
    GradientArchive_GradientType_Radial;
  static inline bool GradientType_IsValid(int value) {
    return GradientArchive_GradientType_IsValid(value);
  }
  static constexpr GradientType GradientType_MIN =
    GradientArchive_GradientType_GradientType_MIN;
  static constexpr GradientType GradientType_MAX =
    GradientArchive_GradientType_GradientType_MAX;
  static constexpr int GradientType_ARRAYSIZE =
    GradientArchive_GradientType_GradientType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GradientType_descriptor() {
    return GradientArchive_GradientType_descriptor();
  }
  template<typename T>
  static inline const std::string& GradientType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GradientType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GradientType_Name.");
    return GradientArchive_GradientType_Name(enum_t_value);
  }
  static inline bool GradientType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GradientType* value) {
    return GradientArchive_GradientType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStopsFieldNumber = 2,
    kAnglegradientFieldNumber = 5,
    kTransformgradientFieldNumber = 6,
    kTypeFieldNumber = 1,
    kOpacityFieldNumber = 3,
    kAdvancedGradientFieldNumber = 4,
  };
  // repeated .TSD.GradientArchive.GradientStop stops = 2;
  int stops_size() const;
  private:
  int _internal_stops_size() const;
  public:
  void clear_stops();
  ::TSD::GradientArchive_GradientStop* mutable_stops(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::GradientArchive_GradientStop >*
      mutable_stops();
  private:
  const ::TSD::GradientArchive_GradientStop& _internal_stops(int index) const;
  ::TSD::GradientArchive_GradientStop* _internal_add_stops();
  public:
  const ::TSD::GradientArchive_GradientStop& stops(int index) const;
  ::TSD::GradientArchive_GradientStop* add_stops();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::GradientArchive_GradientStop >&
      stops() const;

  // optional .TSD.AngleGradientArchive anglegradient = 5;
  bool has_anglegradient() const;
  private:
  bool _internal_has_anglegradient() const;
  public:
  void clear_anglegradient();
  const ::TSD::AngleGradientArchive& anglegradient() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::AngleGradientArchive* release_anglegradient();
  ::TSD::AngleGradientArchive* mutable_anglegradient();
  void set_allocated_anglegradient(::TSD::AngleGradientArchive* anglegradient);
  private:
  const ::TSD::AngleGradientArchive& _internal_anglegradient() const;
  ::TSD::AngleGradientArchive* _internal_mutable_anglegradient();
  public:
  void unsafe_arena_set_allocated_anglegradient(
      ::TSD::AngleGradientArchive* anglegradient);
  ::TSD::AngleGradientArchive* unsafe_arena_release_anglegradient();

  // optional .TSD.TransformGradientArchive transformgradient = 6;
  bool has_transformgradient() const;
  private:
  bool _internal_has_transformgradient() const;
  public:
  void clear_transformgradient();
  const ::TSD::TransformGradientArchive& transformgradient() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::TransformGradientArchive* release_transformgradient();
  ::TSD::TransformGradientArchive* mutable_transformgradient();
  void set_allocated_transformgradient(::TSD::TransformGradientArchive* transformgradient);
  private:
  const ::TSD::TransformGradientArchive& _internal_transformgradient() const;
  ::TSD::TransformGradientArchive* _internal_mutable_transformgradient();
  public:
  void unsafe_arena_set_allocated_transformgradient(
      ::TSD::TransformGradientArchive* transformgradient);
  ::TSD::TransformGradientArchive* unsafe_arena_release_transformgradient();

  // optional .TSD.GradientArchive.GradientType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::GradientArchive_GradientType type() const;
  void set_type(::TSD::GradientArchive_GradientType value);
  private:
  ::TSD::GradientArchive_GradientType _internal_type() const;
  void _internal_set_type(::TSD::GradientArchive_GradientType value);
  public:

  // optional float opacity = 3;
  bool has_opacity() const;
  private:
  bool _internal_has_opacity() const;
  public:
  void clear_opacity();
  float opacity() const;
  void set_opacity(float value);
  private:
  float _internal_opacity() const;
  void _internal_set_opacity(float value);
  public:

  // optional bool advancedGradient = 4;
  bool has_advancedgradient() const;
  private:
  bool _internal_has_advancedgradient() const;
  public:
  void clear_advancedgradient();
  bool advancedgradient() const;
  void set_advancedgradient(bool value);
  private:
  bool _internal_advancedgradient() const;
  void _internal_set_advancedgradient(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.GradientArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::GradientArchive_GradientStop > stops_;
  ::TSD::AngleGradientArchive* anglegradient_;
  ::TSD::TransformGradientArchive* transformgradient_;
  int type_;
  float opacity_;
  bool advancedgradient_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ImageFillArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ImageFillArchive) */ {
 public:
  inline ImageFillArchive() : ImageFillArchive(nullptr) {}
  ~ImageFillArchive() override;
  explicit constexpr ImageFillArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageFillArchive(const ImageFillArchive& from);
  ImageFillArchive(ImageFillArchive&& from) noexcept
    : ImageFillArchive() {
    *this = ::std::move(from);
  }

  inline ImageFillArchive& operator=(const ImageFillArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageFillArchive& operator=(ImageFillArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageFillArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageFillArchive* internal_default_instance() {
    return reinterpret_cast<const ImageFillArchive*>(
               &_ImageFillArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ImageFillArchive& a, ImageFillArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageFillArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageFillArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageFillArchive* New() const final {
    return CreateMaybeMessage<ImageFillArchive>(nullptr);
  }

  ImageFillArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageFillArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageFillArchive& from);
  void MergeFrom(const ImageFillArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageFillArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ImageFillArchive";
  }
  protected:
  explicit ImageFillArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ImageFillArchive_ImageFillTechnique ImageFillTechnique;
  static constexpr ImageFillTechnique NaturalSize =
    ImageFillArchive_ImageFillTechnique_NaturalSize;
  static constexpr ImageFillTechnique Stretch =
    ImageFillArchive_ImageFillTechnique_Stretch;
  static constexpr ImageFillTechnique Tile =
    ImageFillArchive_ImageFillTechnique_Tile;
  static constexpr ImageFillTechnique ScaleToFill =
    ImageFillArchive_ImageFillTechnique_ScaleToFill;
  static constexpr ImageFillTechnique ScaleToFit =
    ImageFillArchive_ImageFillTechnique_ScaleToFit;
  static inline bool ImageFillTechnique_IsValid(int value) {
    return ImageFillArchive_ImageFillTechnique_IsValid(value);
  }
  static constexpr ImageFillTechnique ImageFillTechnique_MIN =
    ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MIN;
  static constexpr ImageFillTechnique ImageFillTechnique_MAX =
    ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MAX;
  static constexpr int ImageFillTechnique_ARRAYSIZE =
    ImageFillArchive_ImageFillTechnique_ImageFillTechnique_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ImageFillTechnique_descriptor() {
    return ImageFillArchive_ImageFillTechnique_descriptor();
  }
  template<typename T>
  static inline const std::string& ImageFillTechnique_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ImageFillTechnique>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ImageFillTechnique_Name.");
    return ImageFillArchive_ImageFillTechnique_Name(enum_t_value);
  }
  static inline bool ImageFillTechnique_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ImageFillTechnique* value) {
    return ImageFillArchive_ImageFillTechnique_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseImagedataFieldNumber = 1,
    kTintFieldNumber = 3,
    kFillsizeFieldNumber = 4,
    kDatabaseOriginalimagedataFieldNumber = 5,
    kImagedataFieldNumber = 6,
    kOriginalimagedataFieldNumber = 7,
    kReferencecolorFieldNumber = 9,
    kTechniqueFieldNumber = 2,
    kInterpretsUntaggedImageDataAsGenericFieldNumber = 8,
  };
  // optional .TSP.Reference database_imagedata = 1;
  bool has_database_imagedata() const;
  private:
  bool _internal_has_database_imagedata() const;
  public:
  void clear_database_imagedata();
  const ::TSP::Reference& database_imagedata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_database_imagedata();
  ::TSP::Reference* mutable_database_imagedata();
  void set_allocated_database_imagedata(::TSP::Reference* database_imagedata);
  private:
  const ::TSP::Reference& _internal_database_imagedata() const;
  ::TSP::Reference* _internal_mutable_database_imagedata();
  public:
  void unsafe_arena_set_allocated_database_imagedata(
      ::TSP::Reference* database_imagedata);
  ::TSP::Reference* unsafe_arena_release_database_imagedata();

  // optional .TSP.Color tint = 3;
  bool has_tint() const;
  private:
  bool _internal_has_tint() const;
  public:
  void clear_tint();
  const ::TSP::Color& tint() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_tint();
  ::TSP::Color* mutable_tint();
  void set_allocated_tint(::TSP::Color* tint);
  private:
  const ::TSP::Color& _internal_tint() const;
  ::TSP::Color* _internal_mutable_tint();
  public:
  void unsafe_arena_set_allocated_tint(
      ::TSP::Color* tint);
  ::TSP::Color* unsafe_arena_release_tint();

  // optional .TSP.Size fillsize = 4;
  bool has_fillsize() const;
  private:
  bool _internal_has_fillsize() const;
  public:
  void clear_fillsize();
  const ::TSP::Size& fillsize() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_fillsize();
  ::TSP::Size* mutable_fillsize();
  void set_allocated_fillsize(::TSP::Size* fillsize);
  private:
  const ::TSP::Size& _internal_fillsize() const;
  ::TSP::Size* _internal_mutable_fillsize();
  public:
  void unsafe_arena_set_allocated_fillsize(
      ::TSP::Size* fillsize);
  ::TSP::Size* unsafe_arena_release_fillsize();

  // optional .TSP.Reference database_originalimagedata = 5;
  bool has_database_originalimagedata() const;
  private:
  bool _internal_has_database_originalimagedata() const;
  public:
  void clear_database_originalimagedata();
  const ::TSP::Reference& database_originalimagedata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_database_originalimagedata();
  ::TSP::Reference* mutable_database_originalimagedata();
  void set_allocated_database_originalimagedata(::TSP::Reference* database_originalimagedata);
  private:
  const ::TSP::Reference& _internal_database_originalimagedata() const;
  ::TSP::Reference* _internal_mutable_database_originalimagedata();
  public:
  void unsafe_arena_set_allocated_database_originalimagedata(
      ::TSP::Reference* database_originalimagedata);
  ::TSP::Reference* unsafe_arena_release_database_originalimagedata();

  // optional .TSP.DataReference imagedata = 6;
  bool has_imagedata() const;
  private:
  bool _internal_has_imagedata() const;
  public:
  void clear_imagedata();
  const ::TSP::DataReference& imagedata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::DataReference* release_imagedata();
  ::TSP::DataReference* mutable_imagedata();
  void set_allocated_imagedata(::TSP::DataReference* imagedata);
  private:
  const ::TSP::DataReference& _internal_imagedata() const;
  ::TSP::DataReference* _internal_mutable_imagedata();
  public:
  void unsafe_arena_set_allocated_imagedata(
      ::TSP::DataReference* imagedata);
  ::TSP::DataReference* unsafe_arena_release_imagedata();

  // optional .TSP.DataReference originalimagedata = 7 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_originalimagedata() const;
  private:
  bool _internal_has_originalimagedata() const;
  public:
  PROTOBUF_DEPRECATED void clear_originalimagedata();
  PROTOBUF_DEPRECATED const ::TSP::DataReference& originalimagedata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_DEPRECATED ::TSP::DataReference* release_originalimagedata();
  PROTOBUF_DEPRECATED ::TSP::DataReference* mutable_originalimagedata();
  PROTOBUF_DEPRECATED void set_allocated_originalimagedata(::TSP::DataReference* originalimagedata);
  private:
  const ::TSP::DataReference& _internal_originalimagedata() const;
  ::TSP::DataReference* _internal_mutable_originalimagedata();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_originalimagedata(
      ::TSP::DataReference* originalimagedata);
  PROTOBUF_DEPRECATED ::TSP::DataReference* unsafe_arena_release_originalimagedata();

  // optional .TSP.Color referencecolor = 9;
  bool has_referencecolor() const;
  private:
  bool _internal_has_referencecolor() const;
  public:
  void clear_referencecolor();
  const ::TSP::Color& referencecolor() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_referencecolor();
  ::TSP::Color* mutable_referencecolor();
  void set_allocated_referencecolor(::TSP::Color* referencecolor);
  private:
  const ::TSP::Color& _internal_referencecolor() const;
  ::TSP::Color* _internal_mutable_referencecolor();
  public:
  void unsafe_arena_set_allocated_referencecolor(
      ::TSP::Color* referencecolor);
  ::TSP::Color* unsafe_arena_release_referencecolor();

  // optional .TSD.ImageFillArchive.ImageFillTechnique technique = 2 [default = NaturalSize];
  bool has_technique() const;
  private:
  bool _internal_has_technique() const;
  public:
  void clear_technique();
  ::TSD::ImageFillArchive_ImageFillTechnique technique() const;
  void set_technique(::TSD::ImageFillArchive_ImageFillTechnique value);
  private:
  ::TSD::ImageFillArchive_ImageFillTechnique _internal_technique() const;
  void _internal_set_technique(::TSD::ImageFillArchive_ImageFillTechnique value);
  public:

  // optional bool interpretsUntaggedImageDataAsGeneric = 8;
  bool has_interpretsuntaggedimagedataasgeneric() const;
  private:
  bool _internal_has_interpretsuntaggedimagedataasgeneric() const;
  public:
  void clear_interpretsuntaggedimagedataasgeneric();
  bool interpretsuntaggedimagedataasgeneric() const;
  void set_interpretsuntaggedimagedataasgeneric(bool value);
  private:
  bool _internal_interpretsuntaggedimagedataasgeneric() const;
  void _internal_set_interpretsuntaggedimagedataasgeneric(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ImageFillArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Reference* database_imagedata_;
  ::TSP::Color* tint_;
  ::TSP::Size* fillsize_;
  ::TSP::Reference* database_originalimagedata_;
  ::TSP::DataReference* imagedata_;
  ::TSP::DataReference* originalimagedata_;
  ::TSP::Color* referencecolor_;
  int technique_;
  bool interpretsuntaggedimagedataasgeneric_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class FillArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.FillArchive) */ {
 public:
  inline FillArchive() : FillArchive(nullptr) {}
  ~FillArchive() override;
  explicit constexpr FillArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FillArchive(const FillArchive& from);
  FillArchive(FillArchive&& from) noexcept
    : FillArchive() {
    *this = ::std::move(from);
  }

  inline FillArchive& operator=(const FillArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FillArchive& operator=(FillArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FillArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FillArchive* internal_default_instance() {
    return reinterpret_cast<const FillArchive*>(
               &_FillArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(FillArchive& a, FillArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FillArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FillArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FillArchive* New() const final {
    return CreateMaybeMessage<FillArchive>(nullptr);
  }

  FillArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FillArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FillArchive& from);
  void MergeFrom(const FillArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FillArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.FillArchive";
  }
  protected:
  explicit FillArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kGradientFieldNumber = 2,
    kImageFieldNumber = 3,
  };
  // optional .TSP.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::TSP::Color& color() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_color();
  ::TSP::Color* mutable_color();
  void set_allocated_color(::TSP::Color* color);
  private:
  const ::TSP::Color& _internal_color() const;
  ::TSP::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::TSP::Color* color);
  ::TSP::Color* unsafe_arena_release_color();

  // optional .TSD.GradientArchive gradient = 2;
  bool has_gradient() const;
  private:
  bool _internal_has_gradient() const;
  public:
  void clear_gradient();
  const ::TSD::GradientArchive& gradient() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::GradientArchive* release_gradient();
  ::TSD::GradientArchive* mutable_gradient();
  void set_allocated_gradient(::TSD::GradientArchive* gradient);
  private:
  const ::TSD::GradientArchive& _internal_gradient() const;
  ::TSD::GradientArchive* _internal_mutable_gradient();
  public:
  void unsafe_arena_set_allocated_gradient(
      ::TSD::GradientArchive* gradient);
  ::TSD::GradientArchive* unsafe_arena_release_gradient();

  // optional .TSD.ImageFillArchive image = 3;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::TSD::ImageFillArchive& image() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::ImageFillArchive* release_image();
  ::TSD::ImageFillArchive* mutable_image();
  void set_allocated_image(::TSD::ImageFillArchive* image);
  private:
  const ::TSD::ImageFillArchive& _internal_image() const;
  ::TSD::ImageFillArchive* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::TSD::ImageFillArchive* image);
  ::TSD::ImageFillArchive* unsafe_arena_release_image();

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(FillArchive)
  // @@protoc_insertion_point(class_scope:TSD.FillArchive)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Color* color_;
  ::TSD::GradientArchive* gradient_;
  ::TSD::ImageFillArchive* image_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class StrokePatternArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.StrokePatternArchive) */ {
 public:
  inline StrokePatternArchive() : StrokePatternArchive(nullptr) {}
  ~StrokePatternArchive() override;
  explicit constexpr StrokePatternArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrokePatternArchive(const StrokePatternArchive& from);
  StrokePatternArchive(StrokePatternArchive&& from) noexcept
    : StrokePatternArchive() {
    *this = ::std::move(from);
  }

  inline StrokePatternArchive& operator=(const StrokePatternArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrokePatternArchive& operator=(StrokePatternArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrokePatternArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrokePatternArchive* internal_default_instance() {
    return reinterpret_cast<const StrokePatternArchive*>(
               &_StrokePatternArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(StrokePatternArchive& a, StrokePatternArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StrokePatternArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrokePatternArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StrokePatternArchive* New() const final {
    return CreateMaybeMessage<StrokePatternArchive>(nullptr);
  }

  StrokePatternArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StrokePatternArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StrokePatternArchive& from);
  void MergeFrom(const StrokePatternArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrokePatternArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.StrokePatternArchive";
  }
  protected:
  explicit StrokePatternArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StrokePatternArchive_StrokePatternType StrokePatternType;
  static constexpr StrokePatternType TSDPattern =
    StrokePatternArchive_StrokePatternType_TSDPattern;
  static constexpr StrokePatternType TSDSolidPattern =
    StrokePatternArchive_StrokePatternType_TSDSolidPattern;
  static constexpr StrokePatternType TSDEmptyPattern =
    StrokePatternArchive_StrokePatternType_TSDEmptyPattern;
  static inline bool StrokePatternType_IsValid(int value) {
    return StrokePatternArchive_StrokePatternType_IsValid(value);
  }
  static constexpr StrokePatternType StrokePatternType_MIN =
    StrokePatternArchive_StrokePatternType_StrokePatternType_MIN;
  static constexpr StrokePatternType StrokePatternType_MAX =
    StrokePatternArchive_StrokePatternType_StrokePatternType_MAX;
  static constexpr int StrokePatternType_ARRAYSIZE =
    StrokePatternArchive_StrokePatternType_StrokePatternType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StrokePatternType_descriptor() {
    return StrokePatternArchive_StrokePatternType_descriptor();
  }
  template<typename T>
  static inline const std::string& StrokePatternType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StrokePatternType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StrokePatternType_Name.");
    return StrokePatternArchive_StrokePatternType_Name(enum_t_value);
  }
  static inline bool StrokePatternType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StrokePatternType* value) {
    return StrokePatternArchive_StrokePatternType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPatternFieldNumber = 4,
    kTypeFieldNumber = 1,
    kPhaseFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // repeated float pattern = 4;
  int pattern_size() const;
  private:
  int _internal_pattern_size() const;
  public:
  void clear_pattern();
  private:
  float _internal_pattern(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_pattern() const;
  void _internal_add_pattern(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_pattern();
  public:
  float pattern(int index) const;
  void set_pattern(int index, float value);
  void add_pattern(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      pattern() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_pattern();

  // optional .TSD.StrokePatternArchive.StrokePatternType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::StrokePatternArchive_StrokePatternType type() const;
  void set_type(::TSD::StrokePatternArchive_StrokePatternType value);
  private:
  ::TSD::StrokePatternArchive_StrokePatternType _internal_type() const;
  void _internal_set_type(::TSD::StrokePatternArchive_StrokePatternType value);
  public:

  // optional float phase = 2;
  bool has_phase() const;
  private:
  bool _internal_has_phase() const;
  public:
  void clear_phase();
  float phase() const;
  void set_phase(float value);
  private:
  float _internal_phase() const;
  void _internal_set_phase(float value);
  public:

  // optional uint32 count = 3;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.StrokePatternArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > pattern_;
  int type_;
  float phase_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class StrokeArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.StrokeArchive) */ {
 public:
  inline StrokeArchive() : StrokeArchive(nullptr) {}
  ~StrokeArchive() override;
  explicit constexpr StrokeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrokeArchive(const StrokeArchive& from);
  StrokeArchive(StrokeArchive&& from) noexcept
    : StrokeArchive() {
    *this = ::std::move(from);
  }

  inline StrokeArchive& operator=(const StrokeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrokeArchive& operator=(StrokeArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrokeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrokeArchive* internal_default_instance() {
    return reinterpret_cast<const StrokeArchive*>(
               &_StrokeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(StrokeArchive& a, StrokeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StrokeArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrokeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StrokeArchive* New() const final {
    return CreateMaybeMessage<StrokeArchive>(nullptr);
  }

  StrokeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StrokeArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StrokeArchive& from);
  void MergeFrom(const StrokeArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrokeArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.StrokeArchive";
  }
  protected:
  explicit StrokeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StrokeArchive_LineCap LineCap;
  static constexpr LineCap ButtCap =
    StrokeArchive_LineCap_ButtCap;
  static constexpr LineCap RoundCap =
    StrokeArchive_LineCap_RoundCap;
  static constexpr LineCap SquareCap =
    StrokeArchive_LineCap_SquareCap;
  static inline bool LineCap_IsValid(int value) {
    return StrokeArchive_LineCap_IsValid(value);
  }
  static constexpr LineCap LineCap_MIN =
    StrokeArchive_LineCap_LineCap_MIN;
  static constexpr LineCap LineCap_MAX =
    StrokeArchive_LineCap_LineCap_MAX;
  static constexpr int LineCap_ARRAYSIZE =
    StrokeArchive_LineCap_LineCap_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LineCap_descriptor() {
    return StrokeArchive_LineCap_descriptor();
  }
  template<typename T>
  static inline const std::string& LineCap_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LineCap>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LineCap_Name.");
    return StrokeArchive_LineCap_Name(enum_t_value);
  }
  static inline bool LineCap_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LineCap* value) {
    return StrokeArchive_LineCap_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kPatternFieldNumber = 6,
    kSmartStrokeFieldNumber = 7,
    kFrameFieldNumber = 8,
    kPatternedStrokeFieldNumber = 9,
    kWidthFieldNumber = 2,
    kCapFieldNumber = 3,
    kJoinFieldNumber = 4,
    kMiterLimitFieldNumber = 5,
  };
  // optional .TSP.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::TSP::Color& color() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_color();
  ::TSP::Color* mutable_color();
  void set_allocated_color(::TSP::Color* color);
  private:
  const ::TSP::Color& _internal_color() const;
  ::TSP::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::TSP::Color* color);
  ::TSP::Color* unsafe_arena_release_color();

  // optional .TSD.StrokePatternArchive pattern = 6;
  bool has_pattern() const;
  private:
  bool _internal_has_pattern() const;
  public:
  void clear_pattern();
  const ::TSD::StrokePatternArchive& pattern() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::StrokePatternArchive* release_pattern();
  ::TSD::StrokePatternArchive* mutable_pattern();
  void set_allocated_pattern(::TSD::StrokePatternArchive* pattern);
  private:
  const ::TSD::StrokePatternArchive& _internal_pattern() const;
  ::TSD::StrokePatternArchive* _internal_mutable_pattern();
  public:
  void unsafe_arena_set_allocated_pattern(
      ::TSD::StrokePatternArchive* pattern);
  ::TSD::StrokePatternArchive* unsafe_arena_release_pattern();

  // optional .TSD.SmartStrokeArchive smart_stroke = 7;
  bool has_smart_stroke() const;
  private:
  bool _internal_has_smart_stroke() const;
  public:
  void clear_smart_stroke();
  const ::TSD::SmartStrokeArchive& smart_stroke() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::SmartStrokeArchive* release_smart_stroke();
  ::TSD::SmartStrokeArchive* mutable_smart_stroke();
  void set_allocated_smart_stroke(::TSD::SmartStrokeArchive* smart_stroke);
  private:
  const ::TSD::SmartStrokeArchive& _internal_smart_stroke() const;
  ::TSD::SmartStrokeArchive* _internal_mutable_smart_stroke();
  public:
  void unsafe_arena_set_allocated_smart_stroke(
      ::TSD::SmartStrokeArchive* smart_stroke);
  ::TSD::SmartStrokeArchive* unsafe_arena_release_smart_stroke();

  // optional .TSD.FrameArchive frame = 8;
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  const ::TSD::FrameArchive& frame() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::FrameArchive* release_frame();
  ::TSD::FrameArchive* mutable_frame();
  void set_allocated_frame(::TSD::FrameArchive* frame);
  private:
  const ::TSD::FrameArchive& _internal_frame() const;
  ::TSD::FrameArchive* _internal_mutable_frame();
  public:
  void unsafe_arena_set_allocated_frame(
      ::TSD::FrameArchive* frame);
  ::TSD::FrameArchive* unsafe_arena_release_frame();

  // optional .TSD.PatternedStrokeArchive patterned_stroke = 9;
  bool has_patterned_stroke() const;
  private:
  bool _internal_has_patterned_stroke() const;
  public:
  void clear_patterned_stroke();
  const ::TSD::PatternedStrokeArchive& patterned_stroke() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::PatternedStrokeArchive* release_patterned_stroke();
  ::TSD::PatternedStrokeArchive* mutable_patterned_stroke();
  void set_allocated_patterned_stroke(::TSD::PatternedStrokeArchive* patterned_stroke);
  private:
  const ::TSD::PatternedStrokeArchive& _internal_patterned_stroke() const;
  ::TSD::PatternedStrokeArchive* _internal_mutable_patterned_stroke();
  public:
  void unsafe_arena_set_allocated_patterned_stroke(
      ::TSD::PatternedStrokeArchive* patterned_stroke);
  ::TSD::PatternedStrokeArchive* unsafe_arena_release_patterned_stroke();

  // optional float width = 2;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // optional .TSD.StrokeArchive.LineCap cap = 3;
  bool has_cap() const;
  private:
  bool _internal_has_cap() const;
  public:
  void clear_cap();
  ::TSD::StrokeArchive_LineCap cap() const;
  void set_cap(::TSD::StrokeArchive_LineCap value);
  private:
  ::TSD::StrokeArchive_LineCap _internal_cap() const;
  void _internal_set_cap(::TSD::StrokeArchive_LineCap value);
  public:

  // optional .TSD.LineJoin join = 4;
  bool has_join() const;
  private:
  bool _internal_has_join() const;
  public:
  void clear_join();
  ::TSD::LineJoin join() const;
  void set_join(::TSD::LineJoin value);
  private:
  ::TSD::LineJoin _internal_join() const;
  void _internal_set_join(::TSD::LineJoin value);
  public:

  // optional float miter_limit = 5;
  bool has_miter_limit() const;
  private:
  bool _internal_has_miter_limit() const;
  public:
  void clear_miter_limit();
  float miter_limit() const;
  void set_miter_limit(float value);
  private:
  float _internal_miter_limit() const;
  void _internal_set_miter_limit(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.StrokeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Color* color_;
  ::TSD::StrokePatternArchive* pattern_;
  ::TSD::SmartStrokeArchive* smart_stroke_;
  ::TSD::FrameArchive* frame_;
  ::TSD::PatternedStrokeArchive* patterned_stroke_;
  float width_;
  int cap_;
  int join_;
  float miter_limit_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SmartStrokeArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SmartStrokeArchive) */ {
 public:
  inline SmartStrokeArchive() : SmartStrokeArchive(nullptr) {}
  ~SmartStrokeArchive() override;
  explicit constexpr SmartStrokeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartStrokeArchive(const SmartStrokeArchive& from);
  SmartStrokeArchive(SmartStrokeArchive&& from) noexcept
    : SmartStrokeArchive() {
    *this = ::std::move(from);
  }

  inline SmartStrokeArchive& operator=(const SmartStrokeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartStrokeArchive& operator=(SmartStrokeArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartStrokeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartStrokeArchive* internal_default_instance() {
    return reinterpret_cast<const SmartStrokeArchive*>(
               &_SmartStrokeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SmartStrokeArchive& a, SmartStrokeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartStrokeArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartStrokeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SmartStrokeArchive* New() const final {
    return CreateMaybeMessage<SmartStrokeArchive>(nullptr);
  }

  SmartStrokeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SmartStrokeArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SmartStrokeArchive& from);
  void MergeFrom(const SmartStrokeArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartStrokeArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SmartStrokeArchive";
  }
  protected:
  explicit SmartStrokeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrokeNameFieldNumber = 2,
    kParameterValuesFieldNumber = 4,
    kPatternOffsetDistanceFieldNumber = 5,
    kRandomSeedFieldNumber = 3,
  };
  // optional string stroke_name = 2;
  bool has_stroke_name() const;
  private:
  bool _internal_has_stroke_name() const;
  public:
  void clear_stroke_name();
  const std::string& stroke_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stroke_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stroke_name();
  std::string* release_stroke_name();
  void set_allocated_stroke_name(std::string* stroke_name);
  private:
  const std::string& _internal_stroke_name() const;
  void _internal_set_stroke_name(const std::string& value);
  std::string* _internal_mutable_stroke_name();
  public:

  // optional .TSP.ReferenceDictionary parameterValues = 4;
  bool has_parametervalues() const;
  private:
  bool _internal_has_parametervalues() const;
  public:
  void clear_parametervalues();
  const ::TSP::ReferenceDictionary& parametervalues() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::ReferenceDictionary* release_parametervalues();
  ::TSP::ReferenceDictionary* mutable_parametervalues();
  void set_allocated_parametervalues(::TSP::ReferenceDictionary* parametervalues);
  private:
  const ::TSP::ReferenceDictionary& _internal_parametervalues() const;
  ::TSP::ReferenceDictionary* _internal_mutable_parametervalues();
  public:
  void unsafe_arena_set_allocated_parametervalues(
      ::TSP::ReferenceDictionary* parametervalues);
  ::TSP::ReferenceDictionary* unsafe_arena_release_parametervalues();

  // optional double pattern_offset_distance = 5;
  bool has_pattern_offset_distance() const;
  private:
  bool _internal_has_pattern_offset_distance() const;
  public:
  void clear_pattern_offset_distance();
  double pattern_offset_distance() const;
  void set_pattern_offset_distance(double value);
  private:
  double _internal_pattern_offset_distance() const;
  void _internal_set_pattern_offset_distance(double value);
  public:

  // optional uint32 random_seed = 3;
  bool has_random_seed() const;
  private:
  bool _internal_has_random_seed() const;
  public:
  void clear_random_seed();
  ::PROTOBUF_NAMESPACE_ID::uint32 random_seed() const;
  void set_random_seed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_random_seed() const;
  void _internal_set_random_seed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.SmartStrokeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stroke_name_;
  ::TSP::ReferenceDictionary* parametervalues_;
  double pattern_offset_distance_;
  ::PROTOBUF_NAMESPACE_ID::uint32 random_seed_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class FrameArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.FrameArchive) */ {
 public:
  inline FrameArchive() : FrameArchive(nullptr) {}
  ~FrameArchive() override;
  explicit constexpr FrameArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameArchive(const FrameArchive& from);
  FrameArchive(FrameArchive&& from) noexcept
    : FrameArchive() {
    *this = ::std::move(from);
  }

  inline FrameArchive& operator=(const FrameArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameArchive& operator=(FrameArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameArchive* internal_default_instance() {
    return reinterpret_cast<const FrameArchive*>(
               &_FrameArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(FrameArchive& a, FrameArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FrameArchive* New() const final {
    return CreateMaybeMessage<FrameArchive>(nullptr);
  }

  FrameArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FrameArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FrameArchive& from);
  void MergeFrom(const FrameArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.FrameArchive";
  }
  protected:
  explicit FrameArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 2,
    kAssetScaleFieldNumber = 3,
  };
  // optional string frameName = 2;
  bool has_framename() const;
  private:
  bool _internal_has_framename() const;
  public:
  void clear_framename();
  const std::string& framename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_framename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_framename();
  std::string* release_framename();
  void set_allocated_framename(std::string* framename);
  private:
  const std::string& _internal_framename() const;
  void _internal_set_framename(const std::string& value);
  std::string* _internal_mutable_framename();
  public:

  // optional float assetScale = 3;
  bool has_assetscale() const;
  private:
  bool _internal_has_assetscale() const;
  public:
  void clear_assetscale();
  float assetscale() const;
  void set_assetscale(float value);
  private:
  float _internal_assetscale() const;
  void _internal_set_assetscale(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.FrameArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr framename_;
  float assetscale_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class PatternedStrokeArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.PatternedStrokeArchive) */ {
 public:
  inline PatternedStrokeArchive() : PatternedStrokeArchive(nullptr) {}
  ~PatternedStrokeArchive() override;
  explicit constexpr PatternedStrokeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PatternedStrokeArchive(const PatternedStrokeArchive& from);
  PatternedStrokeArchive(PatternedStrokeArchive&& from) noexcept
    : PatternedStrokeArchive() {
    *this = ::std::move(from);
  }

  inline PatternedStrokeArchive& operator=(const PatternedStrokeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatternedStrokeArchive& operator=(PatternedStrokeArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatternedStrokeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatternedStrokeArchive* internal_default_instance() {
    return reinterpret_cast<const PatternedStrokeArchive*>(
               &_PatternedStrokeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PatternedStrokeArchive& a, PatternedStrokeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PatternedStrokeArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatternedStrokeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PatternedStrokeArchive* New() const final {
    return CreateMaybeMessage<PatternedStrokeArchive>(nullptr);
  }

  PatternedStrokeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PatternedStrokeArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PatternedStrokeArchive& from);
  void MergeFrom(const PatternedStrokeArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PatternedStrokeArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.PatternedStrokeArchive";
  }
  protected:
  explicit PatternedStrokeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPatternNameFieldNumber = 2,
  };
  // optional string pattern_name = 2;
  bool has_pattern_name() const;
  private:
  bool _internal_has_pattern_name() const;
  public:
  void clear_pattern_name();
  const std::string& pattern_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pattern_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pattern_name();
  std::string* release_pattern_name();
  void set_allocated_pattern_name(std::string* pattern_name);
  private:
  const std::string& _internal_pattern_name() const;
  void _internal_set_pattern_name(const std::string& value);
  std::string* _internal_mutable_pattern_name();
  public:

  // @@protoc_insertion_point(class_scope:TSD.PatternedStrokeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pattern_name_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class LineEndArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.LineEndArchive) */ {
 public:
  inline LineEndArchive() : LineEndArchive(nullptr) {}
  ~LineEndArchive() override;
  explicit constexpr LineEndArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LineEndArchive(const LineEndArchive& from);
  LineEndArchive(LineEndArchive&& from) noexcept
    : LineEndArchive() {
    *this = ::std::move(from);
  }

  inline LineEndArchive& operator=(const LineEndArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineEndArchive& operator=(LineEndArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LineEndArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const LineEndArchive* internal_default_instance() {
    return reinterpret_cast<const LineEndArchive*>(
               &_LineEndArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(LineEndArchive& a, LineEndArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(LineEndArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineEndArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LineEndArchive* New() const final {
    return CreateMaybeMessage<LineEndArchive>(nullptr);
  }

  LineEndArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LineEndArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LineEndArchive& from);
  void MergeFrom(const LineEndArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineEndArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.LineEndArchive";
  }
  protected:
  explicit LineEndArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 5,
    kPathFieldNumber = 1,
    kEndPointFieldNumber = 3,
    kLineJoinFieldNumber = 2,
    kIsFilledFieldNumber = 4,
  };
  // optional string identifier = 5;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional .TSP.Path path = 1;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::TSP::Path& path() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Path* release_path();
  ::TSP::Path* mutable_path();
  void set_allocated_path(::TSP::Path* path);
  private:
  const ::TSP::Path& _internal_path() const;
  ::TSP::Path* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::TSP::Path* path);
  ::TSP::Path* unsafe_arena_release_path();

  // optional .TSP.Point end_point = 3;
  bool has_end_point() const;
  private:
  bool _internal_has_end_point() const;
  public:
  void clear_end_point();
  const ::TSP::Point& end_point() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Point* release_end_point();
  ::TSP::Point* mutable_end_point();
  void set_allocated_end_point(::TSP::Point* end_point);
  private:
  const ::TSP::Point& _internal_end_point() const;
  ::TSP::Point* _internal_mutable_end_point();
  public:
  void unsafe_arena_set_allocated_end_point(
      ::TSP::Point* end_point);
  ::TSP::Point* unsafe_arena_release_end_point();

  // optional .TSD.LineJoin line_join = 2 [default = MiterJoin];
  bool has_line_join() const;
  private:
  bool _internal_has_line_join() const;
  public:
  void clear_line_join();
  ::TSD::LineJoin line_join() const;
  void set_line_join(::TSD::LineJoin value);
  private:
  ::TSD::LineJoin _internal_line_join() const;
  void _internal_set_line_join(::TSD::LineJoin value);
  public:

  // optional bool is_filled = 4;
  bool has_is_filled() const;
  private:
  bool _internal_has_is_filled() const;
  public:
  void clear_is_filled();
  bool is_filled() const;
  void set_is_filled(bool value);
  private:
  bool _internal_is_filled() const;
  void _internal_set_is_filled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.LineEndArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::TSP::Path* path_;
  ::TSP::Point* end_point_;
  int line_join_;
  bool is_filled_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ShadowArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ShadowArchive) */ {
 public:
  inline ShadowArchive() : ShadowArchive(nullptr) {}
  ~ShadowArchive() override;
  explicit constexpr ShadowArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShadowArchive(const ShadowArchive& from);
  ShadowArchive(ShadowArchive&& from) noexcept
    : ShadowArchive() {
    *this = ::std::move(from);
  }

  inline ShadowArchive& operator=(const ShadowArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShadowArchive& operator=(ShadowArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShadowArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShadowArchive* internal_default_instance() {
    return reinterpret_cast<const ShadowArchive*>(
               &_ShadowArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ShadowArchive& a, ShadowArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ShadowArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShadowArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShadowArchive* New() const final {
    return CreateMaybeMessage<ShadowArchive>(nullptr);
  }

  ShadowArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShadowArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShadowArchive& from);
  void MergeFrom(const ShadowArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShadowArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ShadowArchive";
  }
  protected:
  explicit ShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ShadowArchive_ShadowType ShadowType;
  static constexpr ShadowType TSDDropShadow =
    ShadowArchive_ShadowType_TSDDropShadow;
  static constexpr ShadowType TSDContactShadow =
    ShadowArchive_ShadowType_TSDContactShadow;
  static constexpr ShadowType TSDCurvedShadow =
    ShadowArchive_ShadowType_TSDCurvedShadow;
  static inline bool ShadowType_IsValid(int value) {
    return ShadowArchive_ShadowType_IsValid(value);
  }
  static constexpr ShadowType ShadowType_MIN =
    ShadowArchive_ShadowType_ShadowType_MIN;
  static constexpr ShadowType ShadowType_MAX =
    ShadowArchive_ShadowType_ShadowType_MAX;
  static constexpr int ShadowType_ARRAYSIZE =
    ShadowArchive_ShadowType_ShadowType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ShadowType_descriptor() {
    return ShadowArchive_ShadowType_descriptor();
  }
  template<typename T>
  static inline const std::string& ShadowType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ShadowType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ShadowType_Name.");
    return ShadowArchive_ShadowType_Name(enum_t_value);
  }
  static inline bool ShadowType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ShadowType* value) {
    return ShadowArchive_ShadowType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kDropShadowFieldNumber = 8,
    kContactShadowFieldNumber = 9,
    kCurvedShadowFieldNumber = 10,
    kTypeFieldNumber = 7,
    kIsEnabledFieldNumber = 6,
    kAngleFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kRadiusFieldNumber = 4,
    kOpacityFieldNumber = 5,
  };
  // optional .TSP.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::TSP::Color& color() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_color();
  ::TSP::Color* mutable_color();
  void set_allocated_color(::TSP::Color* color);
  private:
  const ::TSP::Color& _internal_color() const;
  ::TSP::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::TSP::Color* color);
  ::TSP::Color* unsafe_arena_release_color();

  // optional .TSD.DropShadowArchive dropShadow = 8;
  bool has_dropshadow() const;
  private:
  bool _internal_has_dropshadow() const;
  public:
  void clear_dropshadow();
  const ::TSD::DropShadowArchive& dropshadow() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::DropShadowArchive* release_dropshadow();
  ::TSD::DropShadowArchive* mutable_dropshadow();
  void set_allocated_dropshadow(::TSD::DropShadowArchive* dropshadow);
  private:
  const ::TSD::DropShadowArchive& _internal_dropshadow() const;
  ::TSD::DropShadowArchive* _internal_mutable_dropshadow();
  public:
  void unsafe_arena_set_allocated_dropshadow(
      ::TSD::DropShadowArchive* dropshadow);
  ::TSD::DropShadowArchive* unsafe_arena_release_dropshadow();

  // optional .TSD.ContactShadowArchive contactShadow = 9;
  bool has_contactshadow() const;
  private:
  bool _internal_has_contactshadow() const;
  public:
  void clear_contactshadow();
  const ::TSD::ContactShadowArchive& contactshadow() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::ContactShadowArchive* release_contactshadow();
  ::TSD::ContactShadowArchive* mutable_contactshadow();
  void set_allocated_contactshadow(::TSD::ContactShadowArchive* contactshadow);
  private:
  const ::TSD::ContactShadowArchive& _internal_contactshadow() const;
  ::TSD::ContactShadowArchive* _internal_mutable_contactshadow();
  public:
  void unsafe_arena_set_allocated_contactshadow(
      ::TSD::ContactShadowArchive* contactshadow);
  ::TSD::ContactShadowArchive* unsafe_arena_release_contactshadow();

  // optional .TSD.CurvedShadowArchive curvedShadow = 10;
  bool has_curvedshadow() const;
  private:
  bool _internal_has_curvedshadow() const;
  public:
  void clear_curvedshadow();
  const ::TSD::CurvedShadowArchive& curvedshadow() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::CurvedShadowArchive* release_curvedshadow();
  ::TSD::CurvedShadowArchive* mutable_curvedshadow();
  void set_allocated_curvedshadow(::TSD::CurvedShadowArchive* curvedshadow);
  private:
  const ::TSD::CurvedShadowArchive& _internal_curvedshadow() const;
  ::TSD::CurvedShadowArchive* _internal_mutable_curvedshadow();
  public:
  void unsafe_arena_set_allocated_curvedshadow(
      ::TSD::CurvedShadowArchive* curvedshadow);
  ::TSD::CurvedShadowArchive* unsafe_arena_release_curvedshadow();

  // optional .TSD.ShadowArchive.ShadowType type = 7 [default = TSDDropShadow];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::ShadowArchive_ShadowType type() const;
  void set_type(::TSD::ShadowArchive_ShadowType value);
  private:
  ::TSD::ShadowArchive_ShadowType _internal_type() const;
  void _internal_set_type(::TSD::ShadowArchive_ShadowType value);
  public:

  // optional bool is_enabled = 6 [default = true];
  bool has_is_enabled() const;
  private:
  bool _internal_has_is_enabled() const;
  public:
  void clear_is_enabled();
  bool is_enabled() const;
  void set_is_enabled(bool value);
  private:
  bool _internal_is_enabled() const;
  void _internal_set_is_enabled(bool value);
  public:

  // optional float angle = 2 [default = 315];
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // optional float offset = 3 [default = 5];
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // optional int32 radius = 4 [default = 1];
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  ::PROTOBUF_NAMESPACE_ID::int32 radius() const;
  void set_radius(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_radius() const;
  void _internal_set_radius(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float opacity = 5 [default = 1];
  bool has_opacity() const;
  private:
  bool _internal_has_opacity() const;
  public:
  void clear_opacity();
  float opacity() const;
  void set_opacity(float value);
  private:
  float _internal_opacity() const;
  void _internal_set_opacity(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ShadowArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Color* color_;
  ::TSD::DropShadowArchive* dropshadow_;
  ::TSD::ContactShadowArchive* contactshadow_;
  ::TSD::CurvedShadowArchive* curvedshadow_;
  int type_;
  bool is_enabled_;
  float angle_;
  float offset_;
  ::PROTOBUF_NAMESPACE_ID::int32 radius_;
  float opacity_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class DropShadowArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.DropShadowArchive) */ {
 public:
  inline DropShadowArchive() : DropShadowArchive(nullptr) {}
  ~DropShadowArchive() override;
  explicit constexpr DropShadowArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropShadowArchive(const DropShadowArchive& from);
  DropShadowArchive(DropShadowArchive&& from) noexcept
    : DropShadowArchive() {
    *this = ::std::move(from);
  }

  inline DropShadowArchive& operator=(const DropShadowArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropShadowArchive& operator=(DropShadowArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropShadowArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropShadowArchive* internal_default_instance() {
    return reinterpret_cast<const DropShadowArchive*>(
               &_DropShadowArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DropShadowArchive& a, DropShadowArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DropShadowArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropShadowArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DropShadowArchive* New() const final {
    return CreateMaybeMessage<DropShadowArchive>(nullptr);
  }

  DropShadowArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DropShadowArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DropShadowArchive& from);
  void MergeFrom(const DropShadowArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropShadowArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.DropShadowArchive";
  }
  protected:
  explicit DropShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TSD.DropShadowArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ContactShadowArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ContactShadowArchive) */ {
 public:
  inline ContactShadowArchive() : ContactShadowArchive(nullptr) {}
  ~ContactShadowArchive() override;
  explicit constexpr ContactShadowArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContactShadowArchive(const ContactShadowArchive& from);
  ContactShadowArchive(ContactShadowArchive&& from) noexcept
    : ContactShadowArchive() {
    *this = ::std::move(from);
  }

  inline ContactShadowArchive& operator=(const ContactShadowArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContactShadowArchive& operator=(ContactShadowArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContactShadowArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContactShadowArchive* internal_default_instance() {
    return reinterpret_cast<const ContactShadowArchive*>(
               &_ContactShadowArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ContactShadowArchive& a, ContactShadowArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ContactShadowArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContactShadowArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContactShadowArchive* New() const final {
    return CreateMaybeMessage<ContactShadowArchive>(nullptr);
  }

  ContactShadowArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContactShadowArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContactShadowArchive& from);
  void MergeFrom(const ContactShadowArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContactShadowArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ContactShadowArchive";
  }
  protected:
  explicit ContactShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 4,
    kHeightFieldNumber = 2,
  };
  // optional float offset = 4 [default = 0];
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // optional float height = 2 [default = 0.2];
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ContactShadowArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float offset_;
  float height_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class CurvedShadowArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.CurvedShadowArchive) */ {
 public:
  inline CurvedShadowArchive() : CurvedShadowArchive(nullptr) {}
  ~CurvedShadowArchive() override;
  explicit constexpr CurvedShadowArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurvedShadowArchive(const CurvedShadowArchive& from);
  CurvedShadowArchive(CurvedShadowArchive&& from) noexcept
    : CurvedShadowArchive() {
    *this = ::std::move(from);
  }

  inline CurvedShadowArchive& operator=(const CurvedShadowArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurvedShadowArchive& operator=(CurvedShadowArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurvedShadowArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurvedShadowArchive* internal_default_instance() {
    return reinterpret_cast<const CurvedShadowArchive*>(
               &_CurvedShadowArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CurvedShadowArchive& a, CurvedShadowArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CurvedShadowArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurvedShadowArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CurvedShadowArchive* New() const final {
    return CreateMaybeMessage<CurvedShadowArchive>(nullptr);
  }

  CurvedShadowArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CurvedShadowArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CurvedShadowArchive& from);
  void MergeFrom(const CurvedShadowArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurvedShadowArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.CurvedShadowArchive";
  }
  protected:
  explicit CurvedShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurveFieldNumber = 1,
  };
  // optional float curve = 1 [default = 0.6];
  bool has_curve() const;
  private:
  bool _internal_has_curve() const;
  public:
  void clear_curve();
  float curve() const;
  void set_curve(float value);
  private:
  float _internal_curve() const;
  void _internal_set_curve(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.CurvedShadowArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float curve_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ReflectionArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ReflectionArchive) */ {
 public:
  inline ReflectionArchive() : ReflectionArchive(nullptr) {}
  ~ReflectionArchive() override;
  explicit constexpr ReflectionArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReflectionArchive(const ReflectionArchive& from);
  ReflectionArchive(ReflectionArchive&& from) noexcept
    : ReflectionArchive() {
    *this = ::std::move(from);
  }

  inline ReflectionArchive& operator=(const ReflectionArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReflectionArchive& operator=(ReflectionArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReflectionArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReflectionArchive* internal_default_instance() {
    return reinterpret_cast<const ReflectionArchive*>(
               &_ReflectionArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ReflectionArchive& a, ReflectionArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ReflectionArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReflectionArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReflectionArchive* New() const final {
    return CreateMaybeMessage<ReflectionArchive>(nullptr);
  }

  ReflectionArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReflectionArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReflectionArchive& from);
  void MergeFrom(const ReflectionArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReflectionArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ReflectionArchive";
  }
  protected:
  explicit ReflectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpacityFieldNumber = 1,
  };
  // optional float opacity = 1 [default = 0.5];
  bool has_opacity() const;
  private:
  bool _internal_has_opacity() const;
  public:
  void clear_opacity();
  float opacity() const;
  void set_opacity(float value);
  private:
  float _internal_opacity() const;
  void _internal_set_opacity(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ReflectionArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float opacity_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ImageAdjustmentsArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ImageAdjustmentsArchive) */ {
 public:
  inline ImageAdjustmentsArchive() : ImageAdjustmentsArchive(nullptr) {}
  ~ImageAdjustmentsArchive() override;
  explicit constexpr ImageAdjustmentsArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageAdjustmentsArchive(const ImageAdjustmentsArchive& from);
  ImageAdjustmentsArchive(ImageAdjustmentsArchive&& from) noexcept
    : ImageAdjustmentsArchive() {
    *this = ::std::move(from);
  }

  inline ImageAdjustmentsArchive& operator=(const ImageAdjustmentsArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageAdjustmentsArchive& operator=(ImageAdjustmentsArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageAdjustmentsArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageAdjustmentsArchive* internal_default_instance() {
    return reinterpret_cast<const ImageAdjustmentsArchive*>(
               &_ImageAdjustmentsArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ImageAdjustmentsArchive& a, ImageAdjustmentsArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageAdjustmentsArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageAdjustmentsArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageAdjustmentsArchive* New() const final {
    return CreateMaybeMessage<ImageAdjustmentsArchive>(nullptr);
  }

  ImageAdjustmentsArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageAdjustmentsArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageAdjustmentsArchive& from);
  void MergeFrom(const ImageAdjustmentsArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageAdjustmentsArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ImageAdjustmentsArchive";
  }
  protected:
  explicit ImageAdjustmentsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExposureFieldNumber = 1,
    kSaturationFieldNumber = 2,
    kContrastFieldNumber = 3,
    kHighlightsFieldNumber = 4,
    kShadowsFieldNumber = 5,
    kSharpnessFieldNumber = 6,
    kDenoiseFieldNumber = 7,
    kTemperatureFieldNumber = 8,
    kTintFieldNumber = 9,
    kBottomLevelFieldNumber = 10,
    kGammaFieldNumber = 12,
    kEnhanceFieldNumber = 13,
    kRepresentsSageAdjustmentsFieldNumber = 14,
    kTopLevelFieldNumber = 11,
  };
  // optional float exposure = 1;
  bool has_exposure() const;
  private:
  bool _internal_has_exposure() const;
  public:
  void clear_exposure();
  float exposure() const;
  void set_exposure(float value);
  private:
  float _internal_exposure() const;
  void _internal_set_exposure(float value);
  public:

  // optional float saturation = 2;
  bool has_saturation() const;
  private:
  bool _internal_has_saturation() const;
  public:
  void clear_saturation();
  float saturation() const;
  void set_saturation(float value);
  private:
  float _internal_saturation() const;
  void _internal_set_saturation(float value);
  public:

  // optional float contrast = 3;
  bool has_contrast() const;
  private:
  bool _internal_has_contrast() const;
  public:
  void clear_contrast();
  float contrast() const;
  void set_contrast(float value);
  private:
  float _internal_contrast() const;
  void _internal_set_contrast(float value);
  public:

  // optional float highlights = 4;
  bool has_highlights() const;
  private:
  bool _internal_has_highlights() const;
  public:
  void clear_highlights();
  float highlights() const;
  void set_highlights(float value);
  private:
  float _internal_highlights() const;
  void _internal_set_highlights(float value);
  public:

  // optional float shadows = 5;
  bool has_shadows() const;
  private:
  bool _internal_has_shadows() const;
  public:
  void clear_shadows();
  float shadows() const;
  void set_shadows(float value);
  private:
  float _internal_shadows() const;
  void _internal_set_shadows(float value);
  public:

  // optional float sharpness = 6;
  bool has_sharpness() const;
  private:
  bool _internal_has_sharpness() const;
  public:
  void clear_sharpness();
  float sharpness() const;
  void set_sharpness(float value);
  private:
  float _internal_sharpness() const;
  void _internal_set_sharpness(float value);
  public:

  // optional float denoise = 7;
  bool has_denoise() const;
  private:
  bool _internal_has_denoise() const;
  public:
  void clear_denoise();
  float denoise() const;
  void set_denoise(float value);
  private:
  float _internal_denoise() const;
  void _internal_set_denoise(float value);
  public:

  // optional float temperature = 8;
  bool has_temperature() const;
  private:
  bool _internal_has_temperature() const;
  public:
  void clear_temperature();
  float temperature() const;
  void set_temperature(float value);
  private:
  float _internal_temperature() const;
  void _internal_set_temperature(float value);
  public:

  // optional float tint = 9;
  bool has_tint() const;
  private:
  bool _internal_has_tint() const;
  public:
  void clear_tint();
  float tint() const;
  void set_tint(float value);
  private:
  float _internal_tint() const;
  void _internal_set_tint(float value);
  public:

  // optional float bottom_level = 10;
  bool has_bottom_level() const;
  private:
  bool _internal_has_bottom_level() const;
  public:
  void clear_bottom_level();
  float bottom_level() const;
  void set_bottom_level(float value);
  private:
  float _internal_bottom_level() const;
  void _internal_set_bottom_level(float value);
  public:

  // optional float gamma = 12;
  bool has_gamma() const;
  private:
  bool _internal_has_gamma() const;
  public:
  void clear_gamma();
  float gamma() const;
  void set_gamma(float value);
  private:
  float _internal_gamma() const;
  void _internal_set_gamma(float value);
  public:

  // optional bool enhance = 13 [default = false];
  bool has_enhance() const;
  private:
  bool _internal_has_enhance() const;
  public:
  void clear_enhance();
  bool enhance() const;
  void set_enhance(bool value);
  private:
  bool _internal_enhance() const;
  void _internal_set_enhance(bool value);
  public:

  // optional bool represents_sage_adjustments = 14 [default = false];
  bool has_represents_sage_adjustments() const;
  private:
  bool _internal_has_represents_sage_adjustments() const;
  public:
  void clear_represents_sage_adjustments();
  bool represents_sage_adjustments() const;
  void set_represents_sage_adjustments(bool value);
  private:
  bool _internal_represents_sage_adjustments() const;
  void _internal_set_represents_sage_adjustments(bool value);
  public:

  // optional float top_level = 11 [default = 1];
  bool has_top_level() const;
  private:
  bool _internal_has_top_level() const;
  public:
  void clear_top_level();
  float top_level() const;
  void set_top_level(float value);
  private:
  float _internal_top_level() const;
  void _internal_set_top_level(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ImageAdjustmentsArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float exposure_;
  float saturation_;
  float contrast_;
  float highlights_;
  float shadows_;
  float sharpness_;
  float denoise_;
  float temperature_;
  float tint_;
  float bottom_level_;
  float gamma_;
  bool enhance_;
  bool represents_sage_adjustments_;
  float top_level_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ShapeStylePropertiesArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ShapeStylePropertiesArchive) */ {
 public:
  inline ShapeStylePropertiesArchive() : ShapeStylePropertiesArchive(nullptr) {}
  ~ShapeStylePropertiesArchive() override;
  explicit constexpr ShapeStylePropertiesArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShapeStylePropertiesArchive(const ShapeStylePropertiesArchive& from);
  ShapeStylePropertiesArchive(ShapeStylePropertiesArchive&& from) noexcept
    : ShapeStylePropertiesArchive() {
    *this = ::std::move(from);
  }

  inline ShapeStylePropertiesArchive& operator=(const ShapeStylePropertiesArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeStylePropertiesArchive& operator=(ShapeStylePropertiesArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShapeStylePropertiesArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShapeStylePropertiesArchive* internal_default_instance() {
    return reinterpret_cast<const ShapeStylePropertiesArchive*>(
               &_ShapeStylePropertiesArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ShapeStylePropertiesArchive& a, ShapeStylePropertiesArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeStylePropertiesArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeStylePropertiesArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShapeStylePropertiesArchive* New() const final {
    return CreateMaybeMessage<ShapeStylePropertiesArchive>(nullptr);
  }

  ShapeStylePropertiesArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShapeStylePropertiesArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShapeStylePropertiesArchive& from);
  void MergeFrom(const ShapeStylePropertiesArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeStylePropertiesArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ShapeStylePropertiesArchive";
  }
  protected:
  explicit ShapeStylePropertiesArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFillFieldNumber = 1,
    kStrokeFieldNumber = 2,
    kShadowFieldNumber = 4,
    kReflectionFieldNumber = 5,
    kHeadLineEndFieldNumber = 6,
    kTailLineEndFieldNumber = 7,
    kOpacityFieldNumber = 3,
  };
  // optional .TSD.FillArchive fill = 1;
  bool has_fill() const;
  private:
  bool _internal_has_fill() const;
  public:
  void clear_fill();
  const ::TSD::FillArchive& fill() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::FillArchive* release_fill();
  ::TSD::FillArchive* mutable_fill();
  void set_allocated_fill(::TSD::FillArchive* fill);
  private:
  const ::TSD::FillArchive& _internal_fill() const;
  ::TSD::FillArchive* _internal_mutable_fill();
  public:
  void unsafe_arena_set_allocated_fill(
      ::TSD::FillArchive* fill);
  ::TSD::FillArchive* unsafe_arena_release_fill();

  // optional .TSD.StrokeArchive stroke = 2;
  bool has_stroke() const;
  private:
  bool _internal_has_stroke() const;
  public:
  void clear_stroke();
  const ::TSD::StrokeArchive& stroke() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::StrokeArchive* release_stroke();
  ::TSD::StrokeArchive* mutable_stroke();
  void set_allocated_stroke(::TSD::StrokeArchive* stroke);
  private:
  const ::TSD::StrokeArchive& _internal_stroke() const;
  ::TSD::StrokeArchive* _internal_mutable_stroke();
  public:
  void unsafe_arena_set_allocated_stroke(
      ::TSD::StrokeArchive* stroke);
  ::TSD::StrokeArchive* unsafe_arena_release_stroke();

  // optional .TSD.ShadowArchive shadow = 4;
  bool has_shadow() const;
  private:
  bool _internal_has_shadow() const;
  public:
  void clear_shadow();
  const ::TSD::ShadowArchive& shadow() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::ShadowArchive* release_shadow();
  ::TSD::ShadowArchive* mutable_shadow();
  void set_allocated_shadow(::TSD::ShadowArchive* shadow);
  private:
  const ::TSD::ShadowArchive& _internal_shadow() const;
  ::TSD::ShadowArchive* _internal_mutable_shadow();
  public:
  void unsafe_arena_set_allocated_shadow(
      ::TSD::ShadowArchive* shadow);
  ::TSD::ShadowArchive* unsafe_arena_release_shadow();

  // optional .TSD.ReflectionArchive reflection = 5;
  bool has_reflection() const;
  private:
  bool _internal_has_reflection() const;
  public:
  void clear_reflection();
  const ::TSD::ReflectionArchive& reflection() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::ReflectionArchive* release_reflection();
  ::TSD::ReflectionArchive* mutable_reflection();
  void set_allocated_reflection(::TSD::ReflectionArchive* reflection);
  private:
  const ::TSD::ReflectionArchive& _internal_reflection() const;
  ::TSD::ReflectionArchive* _internal_mutable_reflection();
  public:
  void unsafe_arena_set_allocated_reflection(
      ::TSD::ReflectionArchive* reflection);
  ::TSD::ReflectionArchive* unsafe_arena_release_reflection();

  // optional .TSD.LineEndArchive head_line_end = 6;
  bool has_head_line_end() const;
  private:
  bool _internal_has_head_line_end() const;
  public:
  void clear_head_line_end();
  const ::TSD::LineEndArchive& head_line_end() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::LineEndArchive* release_head_line_end();
  ::TSD::LineEndArchive* mutable_head_line_end();
  void set_allocated_head_line_end(::TSD::LineEndArchive* head_line_end);
  private:
  const ::TSD::LineEndArchive& _internal_head_line_end() const;
  ::TSD::LineEndArchive* _internal_mutable_head_line_end();
  public:
  void unsafe_arena_set_allocated_head_line_end(
      ::TSD::LineEndArchive* head_line_end);
  ::TSD::LineEndArchive* unsafe_arena_release_head_line_end();

  // optional .TSD.LineEndArchive tail_line_end = 7;
  bool has_tail_line_end() const;
  private:
  bool _internal_has_tail_line_end() const;
  public:
  void clear_tail_line_end();
  const ::TSD::LineEndArchive& tail_line_end() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::LineEndArchive* release_tail_line_end();
  ::TSD::LineEndArchive* mutable_tail_line_end();
  void set_allocated_tail_line_end(::TSD::LineEndArchive* tail_line_end);
  private:
  const ::TSD::LineEndArchive& _internal_tail_line_end() const;
  ::TSD::LineEndArchive* _internal_mutable_tail_line_end();
  public:
  void unsafe_arena_set_allocated_tail_line_end(
      ::TSD::LineEndArchive* tail_line_end);
  ::TSD::LineEndArchive* unsafe_arena_release_tail_line_end();

  // optional float opacity = 3;
  bool has_opacity() const;
  private:
  bool _internal_has_opacity() const;
  public:
  void clear_opacity();
  float opacity() const;
  void set_opacity(float value);
  private:
  float _internal_opacity() const;
  void _internal_set_opacity(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ShapeStylePropertiesArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSD::FillArchive* fill_;
  ::TSD::StrokeArchive* stroke_;
  ::TSD::ShadowArchive* shadow_;
  ::TSD::ReflectionArchive* reflection_;
  ::TSD::LineEndArchive* head_line_end_;
  ::TSD::LineEndArchive* tail_line_end_;
  float opacity_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ShapeStyleArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ShapeStyleArchive) */ {
 public:
  inline ShapeStyleArchive() : ShapeStyleArchive(nullptr) {}
  ~ShapeStyleArchive() override;
  explicit constexpr ShapeStyleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShapeStyleArchive(const ShapeStyleArchive& from);
  ShapeStyleArchive(ShapeStyleArchive&& from) noexcept
    : ShapeStyleArchive() {
    *this = ::std::move(from);
  }

  inline ShapeStyleArchive& operator=(const ShapeStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeStyleArchive& operator=(ShapeStyleArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShapeStyleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShapeStyleArchive* internal_default_instance() {
    return reinterpret_cast<const ShapeStyleArchive*>(
               &_ShapeStyleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ShapeStyleArchive& a, ShapeStyleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeStyleArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeStyleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShapeStyleArchive* New() const final {
    return CreateMaybeMessage<ShapeStyleArchive>(nullptr);
  }

  ShapeStyleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShapeStyleArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShapeStyleArchive& from);
  void MergeFrom(const ShapeStyleArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeStyleArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ShapeStyleArchive";
  }
  protected:
  explicit ShapeStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kShapePropertiesFieldNumber = 11,
    kOverrideCountFieldNumber = 10,
  };
  // required .TSS.StyleArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleArchive& super() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSS::StyleArchive* release_super();
  ::TSS::StyleArchive* mutable_super();
  void set_allocated_super(::TSS::StyleArchive* super);
  private:
  const ::TSS::StyleArchive& _internal_super() const;
  ::TSS::StyleArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleArchive* super);
  ::TSS::StyleArchive* unsafe_arena_release_super();

  // optional .TSD.ShapeStylePropertiesArchive shape_properties = 11;
  bool has_shape_properties() const;
  private:
  bool _internal_has_shape_properties() const;
  public:
  void clear_shape_properties();
  const ::TSD::ShapeStylePropertiesArchive& shape_properties() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::ShapeStylePropertiesArchive* release_shape_properties();
  ::TSD::ShapeStylePropertiesArchive* mutable_shape_properties();
  void set_allocated_shape_properties(::TSD::ShapeStylePropertiesArchive* shape_properties);
  private:
  const ::TSD::ShapeStylePropertiesArchive& _internal_shape_properties() const;
  ::TSD::ShapeStylePropertiesArchive* _internal_mutable_shape_properties();
  public:
  void unsafe_arena_set_allocated_shape_properties(
      ::TSD::ShapeStylePropertiesArchive* shape_properties);
  ::TSD::ShapeStylePropertiesArchive* unsafe_arena_release_shape_properties();

  // optional uint32 override_count = 10 [default = 0];
  bool has_override_count() const;
  private:
  bool _internal_has_override_count() const;
  public:
  void clear_override_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 override_count() const;
  void set_override_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_override_count() const;
  void _internal_set_override_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ShapeStyleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSS::StyleArchive* super_;
  ::TSD::ShapeStylePropertiesArchive* shape_properties_;
  ::PROTOBUF_NAMESPACE_ID::uint32 override_count_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class MediaStylePropertiesArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.MediaStylePropertiesArchive) */ {
 public:
  inline MediaStylePropertiesArchive() : MediaStylePropertiesArchive(nullptr) {}
  ~MediaStylePropertiesArchive() override;
  explicit constexpr MediaStylePropertiesArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MediaStylePropertiesArchive(const MediaStylePropertiesArchive& from);
  MediaStylePropertiesArchive(MediaStylePropertiesArchive&& from) noexcept
    : MediaStylePropertiesArchive() {
    *this = ::std::move(from);
  }

  inline MediaStylePropertiesArchive& operator=(const MediaStylePropertiesArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaStylePropertiesArchive& operator=(MediaStylePropertiesArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaStylePropertiesArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaStylePropertiesArchive* internal_default_instance() {
    return reinterpret_cast<const MediaStylePropertiesArchive*>(
               &_MediaStylePropertiesArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(MediaStylePropertiesArchive& a, MediaStylePropertiesArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaStylePropertiesArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaStylePropertiesArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MediaStylePropertiesArchive* New() const final {
    return CreateMaybeMessage<MediaStylePropertiesArchive>(nullptr);
  }

  MediaStylePropertiesArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MediaStylePropertiesArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MediaStylePropertiesArchive& from);
  void MergeFrom(const MediaStylePropertiesArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaStylePropertiesArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.MediaStylePropertiesArchive";
  }
  protected:
  explicit MediaStylePropertiesArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrokeFieldNumber = 1,
    kShadowFieldNumber = 3,
    kReflectionFieldNumber = 4,
    kOpacityFieldNumber = 2,
  };
  // optional .TSD.StrokeArchive stroke = 1;
  bool has_stroke() const;
  private:
  bool _internal_has_stroke() const;
  public:
  void clear_stroke();
  const ::TSD::StrokeArchive& stroke() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::StrokeArchive* release_stroke();
  ::TSD::StrokeArchive* mutable_stroke();
  void set_allocated_stroke(::TSD::StrokeArchive* stroke);
  private:
  const ::TSD::StrokeArchive& _internal_stroke() const;
  ::TSD::StrokeArchive* _internal_mutable_stroke();
  public:
  void unsafe_arena_set_allocated_stroke(
      ::TSD::StrokeArchive* stroke);
  ::TSD::StrokeArchive* unsafe_arena_release_stroke();

  // optional .TSD.ShadowArchive shadow = 3;
  bool has_shadow() const;
  private:
  bool _internal_has_shadow() const;
  public:
  void clear_shadow();
  const ::TSD::ShadowArchive& shadow() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::ShadowArchive* release_shadow();
  ::TSD::ShadowArchive* mutable_shadow();
  void set_allocated_shadow(::TSD::ShadowArchive* shadow);
  private:
  const ::TSD::ShadowArchive& _internal_shadow() const;
  ::TSD::ShadowArchive* _internal_mutable_shadow();
  public:
  void unsafe_arena_set_allocated_shadow(
      ::TSD::ShadowArchive* shadow);
  ::TSD::ShadowArchive* unsafe_arena_release_shadow();

  // optional .TSD.ReflectionArchive reflection = 4;
  bool has_reflection() const;
  private:
  bool _internal_has_reflection() const;
  public:
  void clear_reflection();
  const ::TSD::ReflectionArchive& reflection() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::ReflectionArchive* release_reflection();
  ::TSD::ReflectionArchive* mutable_reflection();
  void set_allocated_reflection(::TSD::ReflectionArchive* reflection);
  private:
  const ::TSD::ReflectionArchive& _internal_reflection() const;
  ::TSD::ReflectionArchive* _internal_mutable_reflection();
  public:
  void unsafe_arena_set_allocated_reflection(
      ::TSD::ReflectionArchive* reflection);
  ::TSD::ReflectionArchive* unsafe_arena_release_reflection();

  // optional float opacity = 2;
  bool has_opacity() const;
  private:
  bool _internal_has_opacity() const;
  public:
  void clear_opacity();
  float opacity() const;
  void set_opacity(float value);
  private:
  float _internal_opacity() const;
  void _internal_set_opacity(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.MediaStylePropertiesArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSD::StrokeArchive* stroke_;
  ::TSD::ShadowArchive* shadow_;
  ::TSD::ReflectionArchive* reflection_;
  float opacity_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class MediaStyleArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.MediaStyleArchive) */ {
 public:
  inline MediaStyleArchive() : MediaStyleArchive(nullptr) {}
  ~MediaStyleArchive() override;
  explicit constexpr MediaStyleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MediaStyleArchive(const MediaStyleArchive& from);
  MediaStyleArchive(MediaStyleArchive&& from) noexcept
    : MediaStyleArchive() {
    *this = ::std::move(from);
  }

  inline MediaStyleArchive& operator=(const MediaStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaStyleArchive& operator=(MediaStyleArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaStyleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaStyleArchive* internal_default_instance() {
    return reinterpret_cast<const MediaStyleArchive*>(
               &_MediaStyleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(MediaStyleArchive& a, MediaStyleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaStyleArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaStyleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MediaStyleArchive* New() const final {
    return CreateMaybeMessage<MediaStyleArchive>(nullptr);
  }

  MediaStyleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MediaStyleArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MediaStyleArchive& from);
  void MergeFrom(const MediaStyleArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaStyleArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.MediaStyleArchive";
  }
  protected:
  explicit MediaStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kMediaPropertiesFieldNumber = 11,
    kOverrideCountFieldNumber = 10,
  };
  // required .TSS.StyleArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleArchive& super() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSS::StyleArchive* release_super();
  ::TSS::StyleArchive* mutable_super();
  void set_allocated_super(::TSS::StyleArchive* super);
  private:
  const ::TSS::StyleArchive& _internal_super() const;
  ::TSS::StyleArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleArchive* super);
  ::TSS::StyleArchive* unsafe_arena_release_super();

  // optional .TSD.MediaStylePropertiesArchive media_properties = 11;
  bool has_media_properties() const;
  private:
  bool _internal_has_media_properties() const;
  public:
  void clear_media_properties();
  const ::TSD::MediaStylePropertiesArchive& media_properties() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::MediaStylePropertiesArchive* release_media_properties();
  ::TSD::MediaStylePropertiesArchive* mutable_media_properties();
  void set_allocated_media_properties(::TSD::MediaStylePropertiesArchive* media_properties);
  private:
  const ::TSD::MediaStylePropertiesArchive& _internal_media_properties() const;
  ::TSD::MediaStylePropertiesArchive* _internal_mutable_media_properties();
  public:
  void unsafe_arena_set_allocated_media_properties(
      ::TSD::MediaStylePropertiesArchive* media_properties);
  ::TSD::MediaStylePropertiesArchive* unsafe_arena_release_media_properties();

  // optional uint32 override_count = 10 [default = 0];
  bool has_override_count() const;
  private:
  bool _internal_has_override_count() const;
  public:
  void clear_override_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 override_count() const;
  void set_override_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_override_count() const;
  void _internal_set_override_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.MediaStyleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSS::StyleArchive* super_;
  ::TSD::MediaStylePropertiesArchive* media_properties_;
  ::PROTOBUF_NAMESPACE_ID::uint32 override_count_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ThemePresetsArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ThemePresetsArchive) */ {
 public:
  inline ThemePresetsArchive() : ThemePresetsArchive(nullptr) {}
  ~ThemePresetsArchive() override;
  explicit constexpr ThemePresetsArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThemePresetsArchive(const ThemePresetsArchive& from);
  ThemePresetsArchive(ThemePresetsArchive&& from) noexcept
    : ThemePresetsArchive() {
    *this = ::std::move(from);
  }

  inline ThemePresetsArchive& operator=(const ThemePresetsArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThemePresetsArchive& operator=(ThemePresetsArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThemePresetsArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThemePresetsArchive* internal_default_instance() {
    return reinterpret_cast<const ThemePresetsArchive*>(
               &_ThemePresetsArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ThemePresetsArchive& a, ThemePresetsArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ThemePresetsArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThemePresetsArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThemePresetsArchive* New() const final {
    return CreateMaybeMessage<ThemePresetsArchive>(nullptr);
  }

  ThemePresetsArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThemePresetsArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ThemePresetsArchive& from);
  void MergeFrom(const ThemePresetsArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThemePresetsArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ThemePresetsArchive";
  }
  protected:
  explicit ThemePresetsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGradientFillPresetsFieldNumber = 1,
    kImageFillPresetsFieldNumber = 2,
    kShadowPresetsFieldNumber = 3,
    kLineStylePresetsFieldNumber = 4,
    kShapeStylePresetsFieldNumber = 5,
    kTextboxStylePresetsFieldNumber = 6,
    kImageStylePresetsFieldNumber = 7,
    kMovieStylePresetsFieldNumber = 8,
    kDrawingLineStylePresetsFieldNumber = 9,
  };
  // repeated .TSD.FillArchive gradient_fill_presets = 1;
  int gradient_fill_presets_size() const;
  private:
  int _internal_gradient_fill_presets_size() const;
  public:
  void clear_gradient_fill_presets();
  ::TSD::FillArchive* mutable_gradient_fill_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >*
      mutable_gradient_fill_presets();
  private:
  const ::TSD::FillArchive& _internal_gradient_fill_presets(int index) const;
  ::TSD::FillArchive* _internal_add_gradient_fill_presets();
  public:
  const ::TSD::FillArchive& gradient_fill_presets(int index) const;
  ::TSD::FillArchive* add_gradient_fill_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >&
      gradient_fill_presets() const;

  // repeated .TSD.FillArchive image_fill_presets = 2;
  int image_fill_presets_size() const;
  private:
  int _internal_image_fill_presets_size() const;
  public:
  void clear_image_fill_presets();
  ::TSD::FillArchive* mutable_image_fill_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >*
      mutable_image_fill_presets();
  private:
  const ::TSD::FillArchive& _internal_image_fill_presets(int index) const;
  ::TSD::FillArchive* _internal_add_image_fill_presets();
  public:
  const ::TSD::FillArchive& image_fill_presets(int index) const;
  ::TSD::FillArchive* add_image_fill_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >&
      image_fill_presets() const;

  // repeated .TSD.ShadowArchive shadow_presets = 3;
  int shadow_presets_size() const;
  private:
  int _internal_shadow_presets_size() const;
  public:
  void clear_shadow_presets();
  ::TSD::ShadowArchive* mutable_shadow_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::ShadowArchive >*
      mutable_shadow_presets();
  private:
  const ::TSD::ShadowArchive& _internal_shadow_presets(int index) const;
  ::TSD::ShadowArchive* _internal_add_shadow_presets();
  public:
  const ::TSD::ShadowArchive& shadow_presets(int index) const;
  ::TSD::ShadowArchive* add_shadow_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::ShadowArchive >&
      shadow_presets() const;

  // repeated .TSP.Reference line_style_presets = 4;
  int line_style_presets_size() const;
  private:
  int _internal_line_style_presets_size() const;
  public:
  void clear_line_style_presets();
  ::TSP::Reference* mutable_line_style_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_line_style_presets();
  private:
  const ::TSP::Reference& _internal_line_style_presets(int index) const;
  ::TSP::Reference* _internal_add_line_style_presets();
  public:
  const ::TSP::Reference& line_style_presets(int index) const;
  ::TSP::Reference* add_line_style_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      line_style_presets() const;

  // repeated .TSP.Reference shape_style_presets = 5;
  int shape_style_presets_size() const;
  private:
  int _internal_shape_style_presets_size() const;
  public:
  void clear_shape_style_presets();
  ::TSP::Reference* mutable_shape_style_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_shape_style_presets();
  private:
  const ::TSP::Reference& _internal_shape_style_presets(int index) const;
  ::TSP::Reference* _internal_add_shape_style_presets();
  public:
  const ::TSP::Reference& shape_style_presets(int index) const;
  ::TSP::Reference* add_shape_style_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      shape_style_presets() const;

  // repeated .TSP.Reference textbox_style_presets = 6;
  int textbox_style_presets_size() const;
  private:
  int _internal_textbox_style_presets_size() const;
  public:
  void clear_textbox_style_presets();
  ::TSP::Reference* mutable_textbox_style_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_textbox_style_presets();
  private:
  const ::TSP::Reference& _internal_textbox_style_presets(int index) const;
  ::TSP::Reference* _internal_add_textbox_style_presets();
  public:
  const ::TSP::Reference& textbox_style_presets(int index) const;
  ::TSP::Reference* add_textbox_style_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      textbox_style_presets() const;

  // repeated .TSP.Reference image_style_presets = 7;
  int image_style_presets_size() const;
  private:
  int _internal_image_style_presets_size() const;
  public:
  void clear_image_style_presets();
  ::TSP::Reference* mutable_image_style_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_image_style_presets();
  private:
  const ::TSP::Reference& _internal_image_style_presets(int index) const;
  ::TSP::Reference* _internal_add_image_style_presets();
  public:
  const ::TSP::Reference& image_style_presets(int index) const;
  ::TSP::Reference* add_image_style_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      image_style_presets() const;

  // repeated .TSP.Reference movie_style_presets = 8;
  int movie_style_presets_size() const;
  private:
  int _internal_movie_style_presets_size() const;
  public:
  void clear_movie_style_presets();
  ::TSP::Reference* mutable_movie_style_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_movie_style_presets();
  private:
  const ::TSP::Reference& _internal_movie_style_presets(int index) const;
  ::TSP::Reference* _internal_add_movie_style_presets();
  public:
  const ::TSP::Reference& movie_style_presets(int index) const;
  ::TSP::Reference* add_movie_style_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      movie_style_presets() const;

  // repeated .TSP.Reference drawing_line_style_presets = 9;
  int drawing_line_style_presets_size() const;
  private:
  int _internal_drawing_line_style_presets_size() const;
  public:
  void clear_drawing_line_style_presets();
  ::TSP::Reference* mutable_drawing_line_style_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_drawing_line_style_presets();
  private:
  const ::TSP::Reference& _internal_drawing_line_style_presets(int index) const;
  ::TSP::Reference* _internal_add_drawing_line_style_presets();
  public:
  const ::TSP::Reference& drawing_line_style_presets(int index) const;
  ::TSP::Reference* add_drawing_line_style_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      drawing_line_style_presets() const;

  static const int kExtensionFieldNumber = 100;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::TSS::ThemeArchive,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::TSD::ThemePresetsArchive >, 11, false >
    extension;
  // @@protoc_insertion_point(class_scope:TSD.ThemePresetsArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive > gradient_fill_presets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive > image_fill_presets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::ShadowArchive > shadow_presets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > line_style_presets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > shape_style_presets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > textbox_style_presets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > image_style_presets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > movie_style_presets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > drawing_line_style_presets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ThemeReplaceFillPresetCommandArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ThemeReplaceFillPresetCommandArchive) */ {
 public:
  inline ThemeReplaceFillPresetCommandArchive() : ThemeReplaceFillPresetCommandArchive(nullptr) {}
  ~ThemeReplaceFillPresetCommandArchive() override;
  explicit constexpr ThemeReplaceFillPresetCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThemeReplaceFillPresetCommandArchive(const ThemeReplaceFillPresetCommandArchive& from);
  ThemeReplaceFillPresetCommandArchive(ThemeReplaceFillPresetCommandArchive&& from) noexcept
    : ThemeReplaceFillPresetCommandArchive() {
    *this = ::std::move(from);
  }

  inline ThemeReplaceFillPresetCommandArchive& operator=(const ThemeReplaceFillPresetCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThemeReplaceFillPresetCommandArchive& operator=(ThemeReplaceFillPresetCommandArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThemeReplaceFillPresetCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThemeReplaceFillPresetCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ThemeReplaceFillPresetCommandArchive*>(
               &_ThemeReplaceFillPresetCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ThemeReplaceFillPresetCommandArchive& a, ThemeReplaceFillPresetCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ThemeReplaceFillPresetCommandArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThemeReplaceFillPresetCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThemeReplaceFillPresetCommandArchive* New() const final {
    return CreateMaybeMessage<ThemeReplaceFillPresetCommandArchive>(nullptr);
  }

  ThemeReplaceFillPresetCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThemeReplaceFillPresetCommandArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ThemeReplaceFillPresetCommandArchive& from);
  void MergeFrom(const ThemeReplaceFillPresetCommandArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThemeReplaceFillPresetCommandArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ThemeReplaceFillPresetCommandArchive";
  }
  protected:
  explicit ThemeReplaceFillPresetCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kThemeFieldNumber = 2,
    kFillFieldNumber = 3,
    kOldFillFieldNumber = 4,
    kIndexFieldNumber = 5,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // required .TSP.Reference theme = 2;
  bool has_theme() const;
  private:
  bool _internal_has_theme() const;
  public:
  void clear_theme();
  const ::TSP::Reference& theme() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_theme();
  ::TSP::Reference* mutable_theme();
  void set_allocated_theme(::TSP::Reference* theme);
  private:
  const ::TSP::Reference& _internal_theme() const;
  ::TSP::Reference* _internal_mutable_theme();
  public:
  void unsafe_arena_set_allocated_theme(
      ::TSP::Reference* theme);
  ::TSP::Reference* unsafe_arena_release_theme();

  // required .TSD.FillArchive fill = 3;
  bool has_fill() const;
  private:
  bool _internal_has_fill() const;
  public:
  void clear_fill();
  const ::TSD::FillArchive& fill() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::FillArchive* release_fill();
  ::TSD::FillArchive* mutable_fill();
  void set_allocated_fill(::TSD::FillArchive* fill);
  private:
  const ::TSD::FillArchive& _internal_fill() const;
  ::TSD::FillArchive* _internal_mutable_fill();
  public:
  void unsafe_arena_set_allocated_fill(
      ::TSD::FillArchive* fill);
  ::TSD::FillArchive* unsafe_arena_release_fill();

  // required .TSD.FillArchive old_fill = 4;
  bool has_old_fill() const;
  private:
  bool _internal_has_old_fill() const;
  public:
  void clear_old_fill();
  const ::TSD::FillArchive& old_fill() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::FillArchive* release_old_fill();
  ::TSD::FillArchive* mutable_old_fill();
  void set_allocated_old_fill(::TSD::FillArchive* old_fill);
  private:
  const ::TSD::FillArchive& _internal_old_fill() const;
  ::TSD::FillArchive* _internal_mutable_old_fill();
  public:
  void unsafe_arena_set_allocated_old_fill(
      ::TSD::FillArchive* old_fill);
  ::TSD::FillArchive* unsafe_arena_release_old_fill();

  // required uint32 index = 5;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ThemeReplaceFillPresetCommandArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSK::CommandArchive* super_;
  ::TSP::Reference* theme_;
  ::TSD::FillArchive* fill_;
  ::TSD::FillArchive* old_fill_;
  ::PROTOBUF_NAMESPACE_ID::uint32 index_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class DrawableArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.DrawableArchive) */ {
 public:
  inline DrawableArchive() : DrawableArchive(nullptr) {}
  ~DrawableArchive() override;
  explicit constexpr DrawableArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawableArchive(const DrawableArchive& from);
  DrawableArchive(DrawableArchive&& from) noexcept
    : DrawableArchive() {
    *this = ::std::move(from);
  }

  inline DrawableArchive& operator=(const DrawableArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawableArchive& operator=(DrawableArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawableArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawableArchive* internal_default_instance() {
    return reinterpret_cast<const DrawableArchive*>(
               &_DrawableArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(DrawableArchive& a, DrawableArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawableArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawableArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DrawableArchive* New() const final {
    return CreateMaybeMessage<DrawableArchive>(nullptr);
  }

  DrawableArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DrawableArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DrawableArchive& from);
  void MergeFrom(const DrawableArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawableArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.DrawableArchive";
  }
  protected:
  explicit DrawableArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPencilAnnotationsFieldNumber = 9,
    kHyperlinkUrlFieldNumber = 4,
    kAccessibilityDescriptionFieldNumber = 8,
    kGeometryFieldNumber = 1,
    kParentFieldNumber = 2,
    kExteriorTextWrapFieldNumber = 3,
    kCommentFieldNumber = 6,
    kTitleFieldNumber = 10,
    kCaptionFieldNumber = 11,
    kLockedFieldNumber = 5,
    kAspectRatioLockedFieldNumber = 7,
    kTitleHiddenFieldNumber = 12,
    kCaptionHiddenFieldNumber = 13,
  };
  // repeated .TSP.Reference pencil_annotations = 9;
  int pencil_annotations_size() const;
  private:
  int _internal_pencil_annotations_size() const;
  public:
  void clear_pencil_annotations();
  ::TSP::Reference* mutable_pencil_annotations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_pencil_annotations();
  private:
  const ::TSP::Reference& _internal_pencil_annotations(int index) const;
  ::TSP::Reference* _internal_add_pencil_annotations();
  public:
  const ::TSP::Reference& pencil_annotations(int index) const;
  ::TSP::Reference* add_pencil_annotations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      pencil_annotations() const;

  // optional string hyperlink_url = 4;
  bool has_hyperlink_url() const;
  private:
  bool _internal_has_hyperlink_url() const;
  public:
  void clear_hyperlink_url();
  const std::string& hyperlink_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hyperlink_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hyperlink_url();
  std::string* release_hyperlink_url();
  void set_allocated_hyperlink_url(std::string* hyperlink_url);
  private:
  const std::string& _internal_hyperlink_url() const;
  void _internal_set_hyperlink_url(const std::string& value);
  std::string* _internal_mutable_hyperlink_url();
  public:

  // optional string accessibility_description = 8;
  bool has_accessibility_description() const;
  private:
  bool _internal_has_accessibility_description() const;
  public:
  void clear_accessibility_description();
  const std::string& accessibility_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accessibility_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accessibility_description();
  std::string* release_accessibility_description();
  void set_allocated_accessibility_description(std::string* accessibility_description);
  private:
  const std::string& _internal_accessibility_description() const;
  void _internal_set_accessibility_description(const std::string& value);
  std::string* _internal_mutable_accessibility_description();
  public:

  // optional .TSD.GeometryArchive geometry = 1;
  bool has_geometry() const;
  private:
  bool _internal_has_geometry() const;
  public:
  void clear_geometry();
  const ::TSD::GeometryArchive& geometry() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::GeometryArchive* release_geometry();
  ::TSD::GeometryArchive* mutable_geometry();
  void set_allocated_geometry(::TSD::GeometryArchive* geometry);
  private:
  const ::TSD::GeometryArchive& _internal_geometry() const;
  ::TSD::GeometryArchive* _internal_mutable_geometry();
  public:
  void unsafe_arena_set_allocated_geometry(
      ::TSD::GeometryArchive* geometry);
  ::TSD::GeometryArchive* unsafe_arena_release_geometry();

  // optional .TSP.Reference parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::TSP::Reference& parent() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_parent();
  ::TSP::Reference* mutable_parent();
  void set_allocated_parent(::TSP::Reference* parent);
  private:
  const ::TSP::Reference& _internal_parent() const;
  ::TSP::Reference* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::TSP::Reference* parent);
  ::TSP::Reference* unsafe_arena_release_parent();

  // optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 3;
  bool has_exterior_text_wrap() const;
  private:
  bool _internal_has_exterior_text_wrap() const;
  public:
  void clear_exterior_text_wrap();
  const ::TSD::ExteriorTextWrapArchive& exterior_text_wrap() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::ExteriorTextWrapArchive* release_exterior_text_wrap();
  ::TSD::ExteriorTextWrapArchive* mutable_exterior_text_wrap();
  void set_allocated_exterior_text_wrap(::TSD::ExteriorTextWrapArchive* exterior_text_wrap);
  private:
  const ::TSD::ExteriorTextWrapArchive& _internal_exterior_text_wrap() const;
  ::TSD::ExteriorTextWrapArchive* _internal_mutable_exterior_text_wrap();
  public:
  void unsafe_arena_set_allocated_exterior_text_wrap(
      ::TSD::ExteriorTextWrapArchive* exterior_text_wrap);
  ::TSD::ExteriorTextWrapArchive* unsafe_arena_release_exterior_text_wrap();

  // optional .TSP.Reference comment = 6;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const ::TSP::Reference& comment() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_comment();
  ::TSP::Reference* mutable_comment();
  void set_allocated_comment(::TSP::Reference* comment);
  private:
  const ::TSP::Reference& _internal_comment() const;
  ::TSP::Reference* _internal_mutable_comment();
  public:
  void unsafe_arena_set_allocated_comment(
      ::TSP::Reference* comment);
  ::TSP::Reference* unsafe_arena_release_comment();

  // optional .TSP.Reference title = 10;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const ::TSP::Reference& title() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_title();
  ::TSP::Reference* mutable_title();
  void set_allocated_title(::TSP::Reference* title);
  private:
  const ::TSP::Reference& _internal_title() const;
  ::TSP::Reference* _internal_mutable_title();
  public:
  void unsafe_arena_set_allocated_title(
      ::TSP::Reference* title);
  ::TSP::Reference* unsafe_arena_release_title();

  // optional .TSP.Reference caption = 11;
  bool has_caption() const;
  private:
  bool _internal_has_caption() const;
  public:
  void clear_caption();
  const ::TSP::Reference& caption() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_caption();
  ::TSP::Reference* mutable_caption();
  void set_allocated_caption(::TSP::Reference* caption);
  private:
  const ::TSP::Reference& _internal_caption() const;
  ::TSP::Reference* _internal_mutable_caption();
  public:
  void unsafe_arena_set_allocated_caption(
      ::TSP::Reference* caption);
  ::TSP::Reference* unsafe_arena_release_caption();

  // optional bool locked = 5;
  bool has_locked() const;
  private:
  bool _internal_has_locked() const;
  public:
  void clear_locked();
  bool locked() const;
  void set_locked(bool value);
  private:
  bool _internal_locked() const;
  void _internal_set_locked(bool value);
  public:

  // optional bool aspect_ratio_locked = 7;
  bool has_aspect_ratio_locked() const;
  private:
  bool _internal_has_aspect_ratio_locked() const;
  public:
  void clear_aspect_ratio_locked();
  bool aspect_ratio_locked() const;
  void set_aspect_ratio_locked(bool value);
  private:
  bool _internal_aspect_ratio_locked() const;
  void _internal_set_aspect_ratio_locked(bool value);
  public:

  // optional bool title_hidden = 12;
  bool has_title_hidden() const;
  private:
  bool _internal_has_title_hidden() const;
  public:
  void clear_title_hidden();
  bool title_hidden() const;
  void set_title_hidden(bool value);
  private:
  bool _internal_title_hidden() const;
  void _internal_set_title_hidden(bool value);
  public:

  // optional bool caption_hidden = 13;
  bool has_caption_hidden() const;
  private:
  bool _internal_has_caption_hidden() const;
  public:
  void clear_caption_hidden();
  bool caption_hidden() const;
  void set_caption_hidden(bool value);
  private:
  bool _internal_caption_hidden() const;
  void _internal_set_caption_hidden(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.DrawableArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > pencil_annotations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hyperlink_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accessibility_description_;
  ::TSD::GeometryArchive* geometry_;
  ::TSP::Reference* parent_;
  ::TSD::ExteriorTextWrapArchive* exterior_text_wrap_;
  ::TSP::Reference* comment_;
  ::TSP::Reference* title_;
  ::TSP::Reference* caption_;
  bool locked_;
  bool aspect_ratio_locked_;
  bool title_hidden_;
  bool caption_hidden_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ContainerArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ContainerArchive) */ {
 public:
  inline ContainerArchive() : ContainerArchive(nullptr) {}
  ~ContainerArchive() override;
  explicit constexpr ContainerArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContainerArchive(const ContainerArchive& from);
  ContainerArchive(ContainerArchive&& from) noexcept
    : ContainerArchive() {
    *this = ::std::move(from);
  }

  inline ContainerArchive& operator=(const ContainerArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContainerArchive& operator=(ContainerArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContainerArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContainerArchive* internal_default_instance() {
    return reinterpret_cast<const ContainerArchive*>(
               &_ContainerArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ContainerArchive& a, ContainerArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ContainerArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContainerArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContainerArchive* New() const final {
    return CreateMaybeMessage<ContainerArchive>(nullptr);
  }

  ContainerArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContainerArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContainerArchive& from);
  void MergeFrom(const ContainerArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContainerArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ContainerArchive";
  }
  protected:
  explicit ContainerArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 3,
    kGeometryFieldNumber = 1,
    kParentFieldNumber = 2,
  };
  // repeated .TSP.Reference children = 3;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::TSP::Reference* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_children();
  private:
  const ::TSP::Reference& _internal_children(int index) const;
  ::TSP::Reference* _internal_add_children();
  public:
  const ::TSP::Reference& children(int index) const;
  ::TSP::Reference* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      children() const;

  // optional .TSD.GeometryArchive geometry = 1;
  bool has_geometry() const;
  private:
  bool _internal_has_geometry() const;
  public:
  void clear_geometry();
  const ::TSD::GeometryArchive& geometry() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::GeometryArchive* release_geometry();
  ::TSD::GeometryArchive* mutable_geometry();
  void set_allocated_geometry(::TSD::GeometryArchive* geometry);
  private:
  const ::TSD::GeometryArchive& _internal_geometry() const;
  ::TSD::GeometryArchive* _internal_mutable_geometry();
  public:
  void unsafe_arena_set_allocated_geometry(
      ::TSD::GeometryArchive* geometry);
  ::TSD::GeometryArchive* unsafe_arena_release_geometry();

  // optional .TSP.Reference parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::TSP::Reference& parent() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_parent();
  ::TSP::Reference* mutable_parent();
  void set_allocated_parent(::TSP::Reference* parent);
  private:
  const ::TSP::Reference& _internal_parent() const;
  ::TSP::Reference* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::TSP::Reference* parent);
  ::TSP::Reference* unsafe_arena_release_parent();

  // @@protoc_insertion_point(class_scope:TSD.ContainerArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > children_;
  ::TSD::GeometryArchive* geometry_;
  ::TSP::Reference* parent_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class GroupArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.GroupArchive) */ {
 public:
  inline GroupArchive() : GroupArchive(nullptr) {}
  ~GroupArchive() override;
  explicit constexpr GroupArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupArchive(const GroupArchive& from);
  GroupArchive(GroupArchive&& from) noexcept
    : GroupArchive() {
    *this = ::std::move(from);
  }

  inline GroupArchive& operator=(const GroupArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupArchive& operator=(GroupArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupArchive* internal_default_instance() {
    return reinterpret_cast<const GroupArchive*>(
               &_GroupArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GroupArchive& a, GroupArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GroupArchive* New() const final {
    return CreateMaybeMessage<GroupArchive>(nullptr);
  }

  GroupArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GroupArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GroupArchive& from);
  void MergeFrom(const GroupArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.GroupArchive";
  }
  protected:
  explicit GroupArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 2,
    kSuperFieldNumber = 1,
    kFakeShapeForEmptyGroupFieldNumber = 3,
  };
  // repeated .TSP.Reference children = 2;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::TSP::Reference* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_children();
  private:
  const ::TSP::Reference& _internal_children(int index) const;
  ::TSP::Reference* _internal_add_children();
  public:
  const ::TSP::Reference& children(int index) const;
  ::TSP::Reference* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      children() const;

  // required .TSD.DrawableArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::DrawableArchive& super() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::DrawableArchive* release_super();
  ::TSD::DrawableArchive* mutable_super();
  void set_allocated_super(::TSD::DrawableArchive* super);
  private:
  const ::TSD::DrawableArchive& _internal_super() const;
  ::TSD::DrawableArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::DrawableArchive* super);
  ::TSD::DrawableArchive* unsafe_arena_release_super();

  // optional .TSP.Reference fake_shape_for_empty_group = 3;
  bool has_fake_shape_for_empty_group() const;
  private:
  bool _internal_has_fake_shape_for_empty_group() const;
  public:
  void clear_fake_shape_for_empty_group();
  const ::TSP::Reference& fake_shape_for_empty_group() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_fake_shape_for_empty_group();
  ::TSP::Reference* mutable_fake_shape_for_empty_group();
  void set_allocated_fake_shape_for_empty_group(::TSP::Reference* fake_shape_for_empty_group);
  private:
  const ::TSP::Reference& _internal_fake_shape_for_empty_group() const;
  ::TSP::Reference* _internal_mutable_fake_shape_for_empty_group();
  public:
  void unsafe_arena_set_allocated_fake_shape_for_empty_group(
      ::TSP::Reference* fake_shape_for_empty_group);
  ::TSP::Reference* unsafe_arena_release_fake_shape_for_empty_group();

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(GroupArchive)
  // @@protoc_insertion_point(class_scope:TSD.GroupArchive)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > children_;
  ::TSD::DrawableArchive* super_;
  ::TSP::Reference* fake_shape_for_empty_group_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class FreehandDrawingAnimationArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.FreehandDrawingAnimationArchive) */ {
 public:
  inline FreehandDrawingAnimationArchive() : FreehandDrawingAnimationArchive(nullptr) {}
  ~FreehandDrawingAnimationArchive() override;
  explicit constexpr FreehandDrawingAnimationArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreehandDrawingAnimationArchive(const FreehandDrawingAnimationArchive& from);
  FreehandDrawingAnimationArchive(FreehandDrawingAnimationArchive&& from) noexcept
    : FreehandDrawingAnimationArchive() {
    *this = ::std::move(from);
  }

  inline FreehandDrawingAnimationArchive& operator=(const FreehandDrawingAnimationArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreehandDrawingAnimationArchive& operator=(FreehandDrawingAnimationArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreehandDrawingAnimationArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreehandDrawingAnimationArchive* internal_default_instance() {
    return reinterpret_cast<const FreehandDrawingAnimationArchive*>(
               &_FreehandDrawingAnimationArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(FreehandDrawingAnimationArchive& a, FreehandDrawingAnimationArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FreehandDrawingAnimationArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreehandDrawingAnimationArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FreehandDrawingAnimationArchive* New() const final {
    return CreateMaybeMessage<FreehandDrawingAnimationArchive>(nullptr);
  }

  FreehandDrawingAnimationArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FreehandDrawingAnimationArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FreehandDrawingAnimationArchive& from);
  void MergeFrom(const FreehandDrawingAnimationArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreehandDrawingAnimationArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.FreehandDrawingAnimationArchive";
  }
  protected:
  explicit FreehandDrawingAnimationArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 1,
    kShouldLoopFieldNumber = 2,
  };
  // optional double duration = 1;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  double duration() const;
  void set_duration(double value);
  private:
  double _internal_duration() const;
  void _internal_set_duration(double value);
  public:

  // optional bool should_loop = 2;
  bool has_should_loop() const;
  private:
  bool _internal_has_should_loop() const;
  public:
  void clear_should_loop();
  bool should_loop() const;
  void set_should_loop(bool value);
  private:
  bool _internal_should_loop() const;
  void _internal_set_should_loop(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.FreehandDrawingAnimationArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double duration_;
  bool should_loop_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class FreehandDrawingArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.FreehandDrawingArchive) */ {
 public:
  inline FreehandDrawingArchive() : FreehandDrawingArchive(nullptr) {}
  ~FreehandDrawingArchive() override;
  explicit constexpr FreehandDrawingArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreehandDrawingArchive(const FreehandDrawingArchive& from);
  FreehandDrawingArchive(FreehandDrawingArchive&& from) noexcept
    : FreehandDrawingArchive() {
    *this = ::std::move(from);
  }

  inline FreehandDrawingArchive& operator=(const FreehandDrawingArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreehandDrawingArchive& operator=(FreehandDrawingArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreehandDrawingArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreehandDrawingArchive* internal_default_instance() {
    return reinterpret_cast<const FreehandDrawingArchive*>(
               &_FreehandDrawingArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(FreehandDrawingArchive& a, FreehandDrawingArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FreehandDrawingArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreehandDrawingArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FreehandDrawingArchive* New() const final {
    return CreateMaybeMessage<FreehandDrawingArchive>(nullptr);
  }

  FreehandDrawingArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FreehandDrawingArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FreehandDrawingArchive& from);
  void MergeFrom(const FreehandDrawingArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreehandDrawingArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.FreehandDrawingArchive";
  }
  protected:
  explicit FreehandDrawingArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpacerShapeFieldNumber = 1,
    kAnimationFieldNumber = 3,
    kOpacityFieldNumber = 2,
  };
  // optional .TSP.Reference spacer_shape = 1;
  bool has_spacer_shape() const;
  private:
  bool _internal_has_spacer_shape() const;
  public:
  void clear_spacer_shape();
  const ::TSP::Reference& spacer_shape() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_spacer_shape();
  ::TSP::Reference* mutable_spacer_shape();
  void set_allocated_spacer_shape(::TSP::Reference* spacer_shape);
  private:
  const ::TSP::Reference& _internal_spacer_shape() const;
  ::TSP::Reference* _internal_mutable_spacer_shape();
  public:
  void unsafe_arena_set_allocated_spacer_shape(
      ::TSP::Reference* spacer_shape);
  ::TSP::Reference* unsafe_arena_release_spacer_shape();

  // optional .TSD.FreehandDrawingAnimationArchive animation = 3;
  bool has_animation() const;
  private:
  bool _internal_has_animation() const;
  public:
  void clear_animation();
  const ::TSD::FreehandDrawingAnimationArchive& animation() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::FreehandDrawingAnimationArchive* release_animation();
  ::TSD::FreehandDrawingAnimationArchive* mutable_animation();
  void set_allocated_animation(::TSD::FreehandDrawingAnimationArchive* animation);
  private:
  const ::TSD::FreehandDrawingAnimationArchive& _internal_animation() const;
  ::TSD::FreehandDrawingAnimationArchive* _internal_mutable_animation();
  public:
  void unsafe_arena_set_allocated_animation(
      ::TSD::FreehandDrawingAnimationArchive* animation);
  ::TSD::FreehandDrawingAnimationArchive* unsafe_arena_release_animation();

  // optional double opacity = 2;
  bool has_opacity() const;
  private:
  bool _internal_has_opacity() const;
  public:
  void clear_opacity();
  double opacity() const;
  void set_opacity(double value);
  private:
  double _internal_opacity() const;
  void _internal_set_opacity(double value);
  public:

  static const int kFreehandDrawingArchiveFieldNumber = 100;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::TSD::GroupArchive,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::TSD::FreehandDrawingArchive >, 11, false >
    freehand_drawing_archive;
  // @@protoc_insertion_point(class_scope:TSD.FreehandDrawingArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Reference* spacer_shape_;
  ::TSD::FreehandDrawingAnimationArchive* animation_;
  double opacity_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ShapeArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ShapeArchive) */ {
 public:
  inline ShapeArchive() : ShapeArchive(nullptr) {}
  ~ShapeArchive() override;
  explicit constexpr ShapeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShapeArchive(const ShapeArchive& from);
  ShapeArchive(ShapeArchive&& from) noexcept
    : ShapeArchive() {
    *this = ::std::move(from);
  }

  inline ShapeArchive& operator=(const ShapeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeArchive& operator=(ShapeArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShapeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShapeArchive* internal_default_instance() {
    return reinterpret_cast<const ShapeArchive*>(
               &_ShapeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ShapeArchive& a, ShapeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShapeArchive* New() const final {
    return CreateMaybeMessage<ShapeArchive>(nullptr);
  }

  ShapeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShapeArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShapeArchive& from);
  void MergeFrom(const ShapeArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ShapeArchive";
  }
  protected:
  explicit ShapeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStyleFieldNumber = 2,
    kPathsourceFieldNumber = 3,
    kHeadLineEndFieldNumber = 4,
    kTailLineEndFieldNumber = 5,
    kStrokePatternOffsetDistanceFieldNumber = 6,
  };
  // required .TSD.DrawableArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::DrawableArchive& super() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::DrawableArchive* release_super();
  ::TSD::DrawableArchive* mutable_super();
  void set_allocated_super(::TSD::DrawableArchive* super);
  private:
  const ::TSD::DrawableArchive& _internal_super() const;
  ::TSD::DrawableArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::DrawableArchive* super);
  ::TSD::DrawableArchive* unsafe_arena_release_super();

  // optional .TSP.Reference style = 2;
  bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  void clear_style();
  const ::TSP::Reference& style() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_style();
  ::TSP::Reference* mutable_style();
  void set_allocated_style(::TSP::Reference* style);
  private:
  const ::TSP::Reference& _internal_style() const;
  ::TSP::Reference* _internal_mutable_style();
  public:
  void unsafe_arena_set_allocated_style(
      ::TSP::Reference* style);
  ::TSP::Reference* unsafe_arena_release_style();

  // optional .TSD.PathSourceArchive pathsource = 3;
  bool has_pathsource() const;
  private:
  bool _internal_has_pathsource() const;
  public:
  void clear_pathsource();
  const ::TSD::PathSourceArchive& pathsource() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::PathSourceArchive* release_pathsource();
  ::TSD::PathSourceArchive* mutable_pathsource();
  void set_allocated_pathsource(::TSD::PathSourceArchive* pathsource);
  private:
  const ::TSD::PathSourceArchive& _internal_pathsource() const;
  ::TSD::PathSourceArchive* _internal_mutable_pathsource();
  public:
  void unsafe_arena_set_allocated_pathsource(
      ::TSD::PathSourceArchive* pathsource);
  ::TSD::PathSourceArchive* unsafe_arena_release_pathsource();

  // optional .TSD.LineEndArchive head_line_end = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_head_line_end() const;
  private:
  bool _internal_has_head_line_end() const;
  public:
  PROTOBUF_DEPRECATED void clear_head_line_end();
  PROTOBUF_DEPRECATED const ::TSD::LineEndArchive& head_line_end() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_DEPRECATED ::TSD::LineEndArchive* release_head_line_end();
  PROTOBUF_DEPRECATED ::TSD::LineEndArchive* mutable_head_line_end();
  PROTOBUF_DEPRECATED void set_allocated_head_line_end(::TSD::LineEndArchive* head_line_end);
  private:
  const ::TSD::LineEndArchive& _internal_head_line_end() const;
  ::TSD::LineEndArchive* _internal_mutable_head_line_end();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_head_line_end(
      ::TSD::LineEndArchive* head_line_end);
  PROTOBUF_DEPRECATED ::TSD::LineEndArchive* unsafe_arena_release_head_line_end();

  // optional .TSD.LineEndArchive tail_line_end = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_tail_line_end() const;
  private:
  bool _internal_has_tail_line_end() const;
  public:
  PROTOBUF_DEPRECATED void clear_tail_line_end();
  PROTOBUF_DEPRECATED const ::TSD::LineEndArchive& tail_line_end() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_DEPRECATED ::TSD::LineEndArchive* release_tail_line_end();
  PROTOBUF_DEPRECATED ::TSD::LineEndArchive* mutable_tail_line_end();
  PROTOBUF_DEPRECATED void set_allocated_tail_line_end(::TSD::LineEndArchive* tail_line_end);
  private:
  const ::TSD::LineEndArchive& _internal_tail_line_end() const;
  ::TSD::LineEndArchive* _internal_mutable_tail_line_end();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_tail_line_end(
      ::TSD::LineEndArchive* tail_line_end);
  PROTOBUF_DEPRECATED ::TSD::LineEndArchive* unsafe_arena_release_tail_line_end();

  // optional float strokePatternOffsetDistance = 6;
  bool has_strokepatternoffsetdistance() const;
  private:
  bool _internal_has_strokepatternoffsetdistance() const;
  public:
  void clear_strokepatternoffsetdistance();
  float strokepatternoffsetdistance() const;
  void set_strokepatternoffsetdistance(float value);
  private:
  float _internal_strokepatternoffsetdistance() const;
  void _internal_set_strokepatternoffsetdistance(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ShapeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSD::DrawableArchive* super_;
  ::TSP::Reference* style_;
  ::TSD::PathSourceArchive* pathsource_;
  ::TSD::LineEndArchive* head_line_end_;
  ::TSD::LineEndArchive* tail_line_end_;
  float strokepatternoffsetdistance_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ConnectionLineArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ConnectionLineArchive) */ {
 public:
  inline ConnectionLineArchive() : ConnectionLineArchive(nullptr) {}
  ~ConnectionLineArchive() override;
  explicit constexpr ConnectionLineArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionLineArchive(const ConnectionLineArchive& from);
  ConnectionLineArchive(ConnectionLineArchive&& from) noexcept
    : ConnectionLineArchive() {
    *this = ::std::move(from);
  }

  inline ConnectionLineArchive& operator=(const ConnectionLineArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionLineArchive& operator=(ConnectionLineArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionLineArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionLineArchive* internal_default_instance() {
    return reinterpret_cast<const ConnectionLineArchive*>(
               &_ConnectionLineArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ConnectionLineArchive& a, ConnectionLineArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionLineArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionLineArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnectionLineArchive* New() const final {
    return CreateMaybeMessage<ConnectionLineArchive>(nullptr);
  }

  ConnectionLineArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionLineArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConnectionLineArchive& from);
  void MergeFrom(const ConnectionLineArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionLineArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ConnectionLineArchive";
  }
  protected:
  explicit ConnectionLineArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kConnectedFromFieldNumber = 2,
    kConnectedToFieldNumber = 3,
    kConnectedToUuidFieldNumber = 4,
    kConnectedFromUuidFieldNumber = 5,
  };
  // required .TSD.ShapeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::ShapeArchive& super() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::ShapeArchive* release_super();
  ::TSD::ShapeArchive* mutable_super();
  void set_allocated_super(::TSD::ShapeArchive* super);
  private:
  const ::TSD::ShapeArchive& _internal_super() const;
  ::TSD::ShapeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::ShapeArchive* super);
  ::TSD::ShapeArchive* unsafe_arena_release_super();

  // optional .TSP.Reference connected_from = 2;
  bool has_connected_from() const;
  private:
  bool _internal_has_connected_from() const;
  public:
  void clear_connected_from();
  const ::TSP::Reference& connected_from() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_connected_from();
  ::TSP::Reference* mutable_connected_from();
  void set_allocated_connected_from(::TSP::Reference* connected_from);
  private:
  const ::TSP::Reference& _internal_connected_from() const;
  ::TSP::Reference* _internal_mutable_connected_from();
  public:
  void unsafe_arena_set_allocated_connected_from(
      ::TSP::Reference* connected_from);
  ::TSP::Reference* unsafe_arena_release_connected_from();

  // optional .TSP.Reference connected_to = 3;
  bool has_connected_to() const;
  private:
  bool _internal_has_connected_to() const;
  public:
  void clear_connected_to();
  const ::TSP::Reference& connected_to() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_connected_to();
  ::TSP::Reference* mutable_connected_to();
  void set_allocated_connected_to(::TSP::Reference* connected_to);
  private:
  const ::TSP::Reference& _internal_connected_to() const;
  ::TSP::Reference* _internal_mutable_connected_to();
  public:
  void unsafe_arena_set_allocated_connected_to(
      ::TSP::Reference* connected_to);
  ::TSP::Reference* unsafe_arena_release_connected_to();

  // optional .TSP.UUID connected_to_uuid = 4;
  bool has_connected_to_uuid() const;
  private:
  bool _internal_has_connected_to_uuid() const;
  public:
  void clear_connected_to_uuid();
  const ::TSP::UUID& connected_to_uuid() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::UUID* release_connected_to_uuid();
  ::TSP::UUID* mutable_connected_to_uuid();
  void set_allocated_connected_to_uuid(::TSP::UUID* connected_to_uuid);
  private:
  const ::TSP::UUID& _internal_connected_to_uuid() const;
  ::TSP::UUID* _internal_mutable_connected_to_uuid();
  public:
  void unsafe_arena_set_allocated_connected_to_uuid(
      ::TSP::UUID* connected_to_uuid);
  ::TSP::UUID* unsafe_arena_release_connected_to_uuid();

  // optional .TSP.UUID connected_from_uuid = 5;
  bool has_connected_from_uuid() const;
  private:
  bool _internal_has_connected_from_uuid() const;
  public:
  void clear_connected_from_uuid();
  const ::TSP::UUID& connected_from_uuid() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::UUID* release_connected_from_uuid();
  ::TSP::UUID* mutable_connected_from_uuid();
  void set_allocated_connected_from_uuid(::TSP::UUID* connected_from_uuid);
  private:
  const ::TSP::UUID& _internal_connected_from_uuid() const;
  ::TSP::UUID* _internal_mutable_connected_from_uuid();
  public:
  void unsafe_arena_set_allocated_connected_from_uuid(
      ::TSP::UUID* connected_from_uuid);
  ::TSP::UUID* unsafe_arena_release_connected_from_uuid();

  // @@protoc_insertion_point(class_scope:TSD.ConnectionLineArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSD::ShapeArchive* super_;
  ::TSP::Reference* connected_from_;
  ::TSP::Reference* connected_to_;
  ::TSP::UUID* connected_to_uuid_;
  ::TSP::UUID* connected_from_uuid_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ImageArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ImageArchive) */ {
 public:
  inline ImageArchive() : ImageArchive(nullptr) {}
  ~ImageArchive() override;
  explicit constexpr ImageArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageArchive(const ImageArchive& from);
  ImageArchive(ImageArchive&& from) noexcept
    : ImageArchive() {
    *this = ::std::move(from);
  }

  inline ImageArchive& operator=(const ImageArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageArchive& operator=(ImageArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageArchive* internal_default_instance() {
    return reinterpret_cast<const ImageArchive*>(
               &_ImageArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(ImageArchive& a, ImageArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageArchive* New() const final {
    return CreateMaybeMessage<ImageArchive>(nullptr);
  }

  ImageArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageArchive& from);
  void MergeFrom(const ImageArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ImageArchive";
  }
  protected:
  explicit ImageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kDatabaseDataFieldNumber = 2,
    kStyleFieldNumber = 3,
    kOriginalSizeFieldNumber = 4,
    kMaskFieldNumber = 5,
    kDatabaseThumbnailDataFieldNumber = 6,
    kDatabaseOriginalDataFieldNumber = 8,
    kNaturalSizeFieldNumber = 9,
    kInstantAlphaPathFieldNumber = 10,
    kDataFieldNumber = 11,
    kThumbnailDataFieldNumber = 12,
    kOriginalDataFieldNumber = 13,
    kImageAdjustmentsFieldNumber = 14,
    kAdjustedImageDataFieldNumber = 15,
    kThumbnailAdjustedImageDataFieldNumber = 16,
    kEnhancedImageDataFieldNumber = 17,
    kTracedPathFieldNumber = 19,
    kAttributionFieldNumber = 20,
    kFlagsFieldNumber = 7,
    kInterpretsUntaggedImageDataAsGenericFieldNumber = 18,
    kShouldTracePdfContentFieldNumber = 21,
  };
  // required .TSD.DrawableArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::DrawableArchive& super() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::DrawableArchive* release_super();
  ::TSD::DrawableArchive* mutable_super();
  void set_allocated_super(::TSD::DrawableArchive* super);
  private:
  const ::TSD::DrawableArchive& _internal_super() const;
  ::TSD::DrawableArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::DrawableArchive* super);
  ::TSD::DrawableArchive* unsafe_arena_release_super();

  // optional .TSP.Reference database_data = 2;
  bool has_database_data() const;
  private:
  bool _internal_has_database_data() const;
  public:
  void clear_database_data();
  const ::TSP::Reference& database_data() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_database_data();
  ::TSP::Reference* mutable_database_data();
  void set_allocated_database_data(::TSP::Reference* database_data);
  private:
  const ::TSP::Reference& _internal_database_data() const;
  ::TSP::Reference* _internal_mutable_database_data();
  public:
  void unsafe_arena_set_allocated_database_data(
      ::TSP::Reference* database_data);
  ::TSP::Reference* unsafe_arena_release_database_data();

  // optional .TSP.Reference style = 3;
  bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  void clear_style();
  const ::TSP::Reference& style() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_style();
  ::TSP::Reference* mutable_style();
  void set_allocated_style(::TSP::Reference* style);
  private:
  const ::TSP::Reference& _internal_style() const;
  ::TSP::Reference* _internal_mutable_style();
  public:
  void unsafe_arena_set_allocated_style(
      ::TSP::Reference* style);
  ::TSP::Reference* unsafe_arena_release_style();

  // optional .TSP.Size originalSize = 4;
  bool has_originalsize() const;
  private:
  bool _internal_has_originalsize() const;
  public:
  void clear_originalsize();
  const ::TSP::Size& originalsize() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_originalsize();
  ::TSP::Size* mutable_originalsize();
  void set_allocated_originalsize(::TSP::Size* originalsize);
  private:
  const ::TSP::Size& _internal_originalsize() const;
  ::TSP::Size* _internal_mutable_originalsize();
  public:
  void unsafe_arena_set_allocated_originalsize(
      ::TSP::Size* originalsize);
  ::TSP::Size* unsafe_arena_release_originalsize();

  // optional .TSP.Reference mask = 5;
  bool has_mask() const;
  private:
  bool _internal_has_mask() const;
  public:
  void clear_mask();
  const ::TSP::Reference& mask() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_mask();
  ::TSP::Reference* mutable_mask();
  void set_allocated_mask(::TSP::Reference* mask);
  private:
  const ::TSP::Reference& _internal_mask() const;
  ::TSP::Reference* _internal_mutable_mask();
  public:
  void unsafe_arena_set_allocated_mask(
      ::TSP::Reference* mask);
  ::TSP::Reference* unsafe_arena_release_mask();

  // optional .TSP.Reference database_thumbnailData = 6;
  bool has_database_thumbnaildata() const;
  private:
  bool _internal_has_database_thumbnaildata() const;
  public:
  void clear_database_thumbnaildata();
  const ::TSP::Reference& database_thumbnaildata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_database_thumbnaildata();
  ::TSP::Reference* mutable_database_thumbnaildata();
  void set_allocated_database_thumbnaildata(::TSP::Reference* database_thumbnaildata);
  private:
  const ::TSP::Reference& _internal_database_thumbnaildata() const;
  ::TSP::Reference* _internal_mutable_database_thumbnaildata();
  public:
  void unsafe_arena_set_allocated_database_thumbnaildata(
      ::TSP::Reference* database_thumbnaildata);
  ::TSP::Reference* unsafe_arena_release_database_thumbnaildata();

  // optional .TSP.Reference database_originalData = 8;
  bool has_database_originaldata() const;
  private:
  bool _internal_has_database_originaldata() const;
  public:
  void clear_database_originaldata();
  const ::TSP::Reference& database_originaldata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_database_originaldata();
  ::TSP::Reference* mutable_database_originaldata();
  void set_allocated_database_originaldata(::TSP::Reference* database_originaldata);
  private:
  const ::TSP::Reference& _internal_database_originaldata() const;
  ::TSP::Reference* _internal_mutable_database_originaldata();
  public:
  void unsafe_arena_set_allocated_database_originaldata(
      ::TSP::Reference* database_originaldata);
  ::TSP::Reference* unsafe_arena_release_database_originaldata();

  // optional .TSP.Size naturalSize = 9;
  bool has_naturalsize() const;
  private:
  bool _internal_has_naturalsize() const;
  public:
  void clear_naturalsize();
  const ::TSP::Size& naturalsize() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_naturalsize();
  ::TSP::Size* mutable_naturalsize();
  void set_allocated_naturalsize(::TSP::Size* naturalsize);
  private:
  const ::TSP::Size& _internal_naturalsize() const;
  ::TSP::Size* _internal_mutable_naturalsize();
  public:
  void unsafe_arena_set_allocated_naturalsize(
      ::TSP::Size* naturalsize);
  ::TSP::Size* unsafe_arena_release_naturalsize();

  // optional .TSP.Path instantAlphaPath = 10;
  bool has_instantalphapath() const;
  private:
  bool _internal_has_instantalphapath() const;
  public:
  void clear_instantalphapath();
  const ::TSP::Path& instantalphapath() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Path* release_instantalphapath();
  ::TSP::Path* mutable_instantalphapath();
  void set_allocated_instantalphapath(::TSP::Path* instantalphapath);
  private:
  const ::TSP::Path& _internal_instantalphapath() const;
  ::TSP::Path* _internal_mutable_instantalphapath();
  public:
  void unsafe_arena_set_allocated_instantalphapath(
      ::TSP::Path* instantalphapath);
  ::TSP::Path* unsafe_arena_release_instantalphapath();

  // optional .TSP.DataReference data = 11;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::TSP::DataReference& data() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::DataReference* release_data();
  ::TSP::DataReference* mutable_data();
  void set_allocated_data(::TSP::DataReference* data);
  private:
  const ::TSP::DataReference& _internal_data() const;
  ::TSP::DataReference* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::TSP::DataReference* data);
  ::TSP::DataReference* unsafe_arena_release_data();

  // optional .TSP.DataReference thumbnailData = 12;
  bool has_thumbnaildata() const;
  private:
  bool _internal_has_thumbnaildata() const;
  public:
  void clear_thumbnaildata();
  const ::TSP::DataReference& thumbnaildata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::DataReference* release_thumbnaildata();
  ::TSP::DataReference* mutable_thumbnaildata();
  void set_allocated_thumbnaildata(::TSP::DataReference* thumbnaildata);
  private:
  const ::TSP::DataReference& _internal_thumbnaildata() const;
  ::TSP::DataReference* _internal_mutable_thumbnaildata();
  public:
  void unsafe_arena_set_allocated_thumbnaildata(
      ::TSP::DataReference* thumbnaildata);
  ::TSP::DataReference* unsafe_arena_release_thumbnaildata();

  // optional .TSP.DataReference originalData = 13;
  bool has_originaldata() const;
  private:
  bool _internal_has_originaldata() const;
  public:
  void clear_originaldata();
  const ::TSP::DataReference& originaldata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::DataReference* release_originaldata();
  ::TSP::DataReference* mutable_originaldata();
  void set_allocated_originaldata(::TSP::DataReference* originaldata);
  private:
  const ::TSP::DataReference& _internal_originaldata() const;
  ::TSP::DataReference* _internal_mutable_originaldata();
  public:
  void unsafe_arena_set_allocated_originaldata(
      ::TSP::DataReference* originaldata);
  ::TSP::DataReference* unsafe_arena_release_originaldata();

  // optional .TSD.ImageAdjustmentsArchive imageAdjustments = 14;
  bool has_imageadjustments() const;
  private:
  bool _internal_has_imageadjustments() const;
  public:
  void clear_imageadjustments();
  const ::TSD::ImageAdjustmentsArchive& imageadjustments() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::ImageAdjustmentsArchive* release_imageadjustments();
  ::TSD::ImageAdjustmentsArchive* mutable_imageadjustments();
  void set_allocated_imageadjustments(::TSD::ImageAdjustmentsArchive* imageadjustments);
  private:
  const ::TSD::ImageAdjustmentsArchive& _internal_imageadjustments() const;
  ::TSD::ImageAdjustmentsArchive* _internal_mutable_imageadjustments();
  public:
  void unsafe_arena_set_allocated_imageadjustments(
      ::TSD::ImageAdjustmentsArchive* imageadjustments);
  ::TSD::ImageAdjustmentsArchive* unsafe_arena_release_imageadjustments();

  // optional .TSP.DataReference adjustedImageData = 15;
  bool has_adjustedimagedata() const;
  private:
  bool _internal_has_adjustedimagedata() const;
  public:
  void clear_adjustedimagedata();
  const ::TSP::DataReference& adjustedimagedata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::DataReference* release_adjustedimagedata();
  ::TSP::DataReference* mutable_adjustedimagedata();
  void set_allocated_adjustedimagedata(::TSP::DataReference* adjustedimagedata);
  private:
  const ::TSP::DataReference& _internal_adjustedimagedata() const;
  ::TSP::DataReference* _internal_mutable_adjustedimagedata();
  public:
  void unsafe_arena_set_allocated_adjustedimagedata(
      ::TSP::DataReference* adjustedimagedata);
  ::TSP::DataReference* unsafe_arena_release_adjustedimagedata();

  // optional .TSP.DataReference thumbnailAdjustedImageData = 16;
  bool has_thumbnailadjustedimagedata() const;
  private:
  bool _internal_has_thumbnailadjustedimagedata() const;
  public:
  void clear_thumbnailadjustedimagedata();
  const ::TSP::DataReference& thumbnailadjustedimagedata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::DataReference* release_thumbnailadjustedimagedata();
  ::TSP::DataReference* mutable_thumbnailadjustedimagedata();
  void set_allocated_thumbnailadjustedimagedata(::TSP::DataReference* thumbnailadjustedimagedata);
  private:
  const ::TSP::DataReference& _internal_thumbnailadjustedimagedata() const;
  ::TSP::DataReference* _internal_mutable_thumbnailadjustedimagedata();
  public:
  void unsafe_arena_set_allocated_thumbnailadjustedimagedata(
      ::TSP::DataReference* thumbnailadjustedimagedata);
  ::TSP::DataReference* unsafe_arena_release_thumbnailadjustedimagedata();

  // optional .TSP.DataReference enhancedImageData = 17;
  bool has_enhancedimagedata() const;
  private:
  bool _internal_has_enhancedimagedata() const;
  public:
  void clear_enhancedimagedata();
  const ::TSP::DataReference& enhancedimagedata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::DataReference* release_enhancedimagedata();
  ::TSP::DataReference* mutable_enhancedimagedata();
  void set_allocated_enhancedimagedata(::TSP::DataReference* enhancedimagedata);
  private:
  const ::TSP::DataReference& _internal_enhancedimagedata() const;
  ::TSP::DataReference* _internal_mutable_enhancedimagedata();
  public:
  void unsafe_arena_set_allocated_enhancedimagedata(
      ::TSP::DataReference* enhancedimagedata);
  ::TSP::DataReference* unsafe_arena_release_enhancedimagedata();

  // optional .TSP.Path traced_path = 19;
  bool has_traced_path() const;
  private:
  bool _internal_has_traced_path() const;
  public:
  void clear_traced_path();
  const ::TSP::Path& traced_path() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Path* release_traced_path();
  ::TSP::Path* mutable_traced_path();
  void set_allocated_traced_path(::TSP::Path* traced_path);
  private:
  const ::TSP::Path& _internal_traced_path() const;
  ::TSP::Path* _internal_mutable_traced_path();
  public:
  void unsafe_arena_set_allocated_traced_path(
      ::TSP::Path* traced_path);
  ::TSP::Path* unsafe_arena_release_traced_path();

  // optional .TSD.Attribution attribution = 20;
  bool has_attribution() const;
  private:
  bool _internal_has_attribution() const;
  public:
  void clear_attribution();
  const ::TSD::Attribution& attribution() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::Attribution* release_attribution();
  ::TSD::Attribution* mutable_attribution();
  void set_allocated_attribution(::TSD::Attribution* attribution);
  private:
  const ::TSD::Attribution& _internal_attribution() const;
  ::TSD::Attribution* _internal_mutable_attribution();
  public:
  void unsafe_arena_set_allocated_attribution(
      ::TSD::Attribution* attribution);
  ::TSD::Attribution* unsafe_arena_release_attribution();

  // optional uint32 flags = 7;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_flags() const;
  void _internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool interpretsUntaggedImageDataAsGeneric = 18;
  bool has_interpretsuntaggedimagedataasgeneric() const;
  private:
  bool _internal_has_interpretsuntaggedimagedataasgeneric() const;
  public:
  void clear_interpretsuntaggedimagedataasgeneric();
  bool interpretsuntaggedimagedataasgeneric() const;
  void set_interpretsuntaggedimagedataasgeneric(bool value);
  private:
  bool _internal_interpretsuntaggedimagedataasgeneric() const;
  void _internal_set_interpretsuntaggedimagedataasgeneric(bool value);
  public:

  // optional bool should_trace_pdf_content = 21;
  bool has_should_trace_pdf_content() const;
  private:
  bool _internal_has_should_trace_pdf_content() const;
  public:
  void clear_should_trace_pdf_content();
  bool should_trace_pdf_content() const;
  void set_should_trace_pdf_content(bool value);
  private:
  bool _internal_should_trace_pdf_content() const;
  void _internal_set_should_trace_pdf_content(bool value);
  public:

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(ImageArchive)
  // @@protoc_insertion_point(class_scope:TSD.ImageArchive)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSD::DrawableArchive* super_;
  ::TSP::Reference* database_data_;
  ::TSP::Reference* style_;
  ::TSP::Size* originalsize_;
  ::TSP::Reference* mask_;
  ::TSP::Reference* database_thumbnaildata_;
  ::TSP::Reference* database_originaldata_;
  ::TSP::Size* naturalsize_;
  ::TSP::Path* instantalphapath_;
  ::TSP::DataReference* data_;
  ::TSP::DataReference* thumbnaildata_;
  ::TSP::DataReference* originaldata_;
  ::TSD::ImageAdjustmentsArchive* imageadjustments_;
  ::TSP::DataReference* adjustedimagedata_;
  ::TSP::DataReference* thumbnailadjustedimagedata_;
  ::TSP::DataReference* enhancedimagedata_;
  ::TSP::Path* traced_path_;
  ::TSD::Attribution* attribution_;
  ::PROTOBUF_NAMESPACE_ID::uint32 flags_;
  bool interpretsuntaggedimagedataasgeneric_;
  bool should_trace_pdf_content_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class MaskArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.MaskArchive) */ {
 public:
  inline MaskArchive() : MaskArchive(nullptr) {}
  ~MaskArchive() override;
  explicit constexpr MaskArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaskArchive(const MaskArchive& from);
  MaskArchive(MaskArchive&& from) noexcept
    : MaskArchive() {
    *this = ::std::move(from);
  }

  inline MaskArchive& operator=(const MaskArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaskArchive& operator=(MaskArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaskArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaskArchive* internal_default_instance() {
    return reinterpret_cast<const MaskArchive*>(
               &_MaskArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(MaskArchive& a, MaskArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MaskArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaskArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaskArchive* New() const final {
    return CreateMaybeMessage<MaskArchive>(nullptr);
  }

  MaskArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaskArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaskArchive& from);
  void MergeFrom(const MaskArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaskArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.MaskArchive";
  }
  protected:
  explicit MaskArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kPathsourceFieldNumber = 2,
  };
  // required .TSD.DrawableArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::DrawableArchive& super() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::DrawableArchive* release_super();
  ::TSD::DrawableArchive* mutable_super();
  void set_allocated_super(::TSD::DrawableArchive* super);
  private:
  const ::TSD::DrawableArchive& _internal_super() const;
  ::TSD::DrawableArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::DrawableArchive* super);
  ::TSD::DrawableArchive* unsafe_arena_release_super();

  // optional .TSD.PathSourceArchive pathsource = 2;
  bool has_pathsource() const;
  private:
  bool _internal_has_pathsource() const;
  public:
  void clear_pathsource();
  const ::TSD::PathSourceArchive& pathsource() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::PathSourceArchive* release_pathsource();
  ::TSD::PathSourceArchive* mutable_pathsource();
  void set_allocated_pathsource(::TSD::PathSourceArchive* pathsource);
  private:
  const ::TSD::PathSourceArchive& _internal_pathsource() const;
  ::TSD::PathSourceArchive* _internal_mutable_pathsource();
  public:
  void unsafe_arena_set_allocated_pathsource(
      ::TSD::PathSourceArchive* pathsource);
  ::TSD::PathSourceArchive* unsafe_arena_release_pathsource();

  // @@protoc_insertion_point(class_scope:TSD.MaskArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSD::DrawableArchive* super_;
  ::TSD::PathSourceArchive* pathsource_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ImageDataAttributes PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ImageDataAttributes) */ {
 public:
  inline ImageDataAttributes() : ImageDataAttributes(nullptr) {}
  ~ImageDataAttributes() override;
  explicit constexpr ImageDataAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageDataAttributes(const ImageDataAttributes& from);
  ImageDataAttributes(ImageDataAttributes&& from) noexcept
    : ImageDataAttributes() {
    *this = ::std::move(from);
  }

  inline ImageDataAttributes& operator=(const ImageDataAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageDataAttributes& operator=(ImageDataAttributes&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageDataAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageDataAttributes* internal_default_instance() {
    return reinterpret_cast<const ImageDataAttributes*>(
               &_ImageDataAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ImageDataAttributes& a, ImageDataAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageDataAttributes* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageDataAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageDataAttributes* New() const final {
    return CreateMaybeMessage<ImageDataAttributes>(nullptr);
  }

  ImageDataAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageDataAttributes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageDataAttributes& from);
  void MergeFrom(const ImageDataAttributes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageDataAttributes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ImageDataAttributes";
  }
  protected:
  explicit ImageDataAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPixelSizeFieldNumber = 1,
    kImageIsSrgbFieldNumber = 2,
    kShouldBeInterpretedAsGenericIfUntaggedFieldNumber = 3,
  };
  // optional .TSP.Size pixel_size = 1;
  bool has_pixel_size() const;
  private:
  bool _internal_has_pixel_size() const;
  public:
  void clear_pixel_size();
  const ::TSP::Size& pixel_size() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_pixel_size();
  ::TSP::Size* mutable_pixel_size();
  void set_allocated_pixel_size(::TSP::Size* pixel_size);
  private:
  const ::TSP::Size& _internal_pixel_size() const;
  ::TSP::Size* _internal_mutable_pixel_size();
  public:
  void unsafe_arena_set_allocated_pixel_size(
      ::TSP::Size* pixel_size);
  ::TSP::Size* unsafe_arena_release_pixel_size();

  // optional bool image_is_srgb = 2;
  bool has_image_is_srgb() const;
  private:
  bool _internal_has_image_is_srgb() const;
  public:
  void clear_image_is_srgb();
  bool image_is_srgb() const;
  void set_image_is_srgb(bool value);
  private:
  bool _internal_image_is_srgb() const;
  void _internal_set_image_is_srgb(bool value);
  public:

  // optional bool should_be_interpreted_as_generic_if_untagged = 3;
  bool has_should_be_interpreted_as_generic_if_untagged() const;
  private:
  bool _internal_has_should_be_interpreted_as_generic_if_untagged() const;
  public:
  void clear_should_be_interpreted_as_generic_if_untagged();
  bool should_be_interpreted_as_generic_if_untagged() const;
  void set_should_be_interpreted_as_generic_if_untagged(bool value);
  private:
  bool _internal_should_be_interpreted_as_generic_if_untagged() const;
  void _internal_set_should_be_interpreted_as_generic_if_untagged(bool value);
  public:

  static const int kImageDataAttributesFieldNumber = 100;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::TSP::DataAttributes,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::TSD::ImageDataAttributes >, 11, false >
    image_data_attributes;
  // @@protoc_insertion_point(class_scope:TSD.ImageDataAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Size* pixel_size_;
  bool image_is_srgb_;
  bool should_be_interpreted_as_generic_if_untagged_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class MovieArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.MovieArchive) */ {
 public:
  inline MovieArchive() : MovieArchive(nullptr) {}
  ~MovieArchive() override;
  explicit constexpr MovieArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MovieArchive(const MovieArchive& from);
  MovieArchive(MovieArchive&& from) noexcept
    : MovieArchive() {
    *this = ::std::move(from);
  }

  inline MovieArchive& operator=(const MovieArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovieArchive& operator=(MovieArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovieArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MovieArchive* internal_default_instance() {
    return reinterpret_cast<const MovieArchive*>(
               &_MovieArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(MovieArchive& a, MovieArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MovieArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovieArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MovieArchive* New() const final {
    return CreateMaybeMessage<MovieArchive>(nullptr);
  }

  MovieArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MovieArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MovieArchive& from);
  void MergeFrom(const MovieArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovieArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.MovieArchive";
  }
  protected:
  explicit MovieArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MovieArchive_MovieLoopOption MovieLoopOption;
  static constexpr MovieLoopOption None =
    MovieArchive_MovieLoopOption_None;
  static constexpr MovieLoopOption Repeat =
    MovieArchive_MovieLoopOption_Repeat;
  static constexpr MovieLoopOption BackAndForth =
    MovieArchive_MovieLoopOption_BackAndForth;
  static inline bool MovieLoopOption_IsValid(int value) {
    return MovieArchive_MovieLoopOption_IsValid(value);
  }
  static constexpr MovieLoopOption MovieLoopOption_MIN =
    MovieArchive_MovieLoopOption_MovieLoopOption_MIN;
  static constexpr MovieLoopOption MovieLoopOption_MAX =
    MovieArchive_MovieLoopOption_MovieLoopOption_MAX;
  static constexpr int MovieLoopOption_ARRAYSIZE =
    MovieArchive_MovieLoopOption_MovieLoopOption_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MovieLoopOption_descriptor() {
    return MovieArchive_MovieLoopOption_descriptor();
  }
  template<typename T>
  static inline const std::string& MovieLoopOption_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MovieLoopOption>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MovieLoopOption_Name.");
    return MovieArchive_MovieLoopOption_Name(enum_t_value);
  }
  static inline bool MovieLoopOption_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MovieLoopOption* value) {
    return MovieArchive_MovieLoopOption_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMovieRemoteURLFieldNumber = 17,
    kImportedAuxiliaryMovieDataOriginalFilenameFieldNumber = 25,
    kSuperFieldNumber = 1,
    kDatabaseMovieDataFieldNumber = 2,
    kDatabasePosterImageDataFieldNumber = 10,
    kDatabaseAudioOnlyImageDataFieldNumber = 11,
    kMovieDataFieldNumber = 14,
    kPosterImageDataFieldNumber = 15,
    kAudioOnlyImageDataFieldNumber = 16,
    kStyleFieldNumber = 19,
    kOriginalSizeFieldNumber = 20,
    kNaturalSizeFieldNumber = 21,
    kImportedAuxiliaryMovieDataFieldNumber = 22,
    kAttributionFieldNumber = 26,
    kFingerprintFieldNumber = 29,
    kStartTimeFieldNumber = 3,
    kEndTimeFieldNumber = 4,
    kPosterTimeFieldNumber = 5,
    kLoopOptionAsIntegerFieldNumber = 6,
    kVolumeFieldNumber = 7,
    kPlayableStateFieldNumber = 12,
    kFlagsFieldNumber = 13,
    kAutoPlayFieldNumber = 8,
    kAudioOnlyFieldNumber = 9,
    kStreamingFieldNumber = 18,
    kNativeAudioRecordingFieldNumber = 27,
    kLoopOptionFieldNumber = 24,
    kPlaysAcrossSlidesFieldNumber = 28,
    kPosterImageGeneratedWithAlphaSupportFieldNumber = 23,
  };
  // optional string movieRemoteURL = 17;
  bool has_movieremoteurl() const;
  private:
  bool _internal_has_movieremoteurl() const;
  public:
  void clear_movieremoteurl();
  const std::string& movieremoteurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_movieremoteurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_movieremoteurl();
  std::string* release_movieremoteurl();
  void set_allocated_movieremoteurl(std::string* movieremoteurl);
  private:
  const std::string& _internal_movieremoteurl() const;
  void _internal_set_movieremoteurl(const std::string& value);
  std::string* _internal_mutable_movieremoteurl();
  public:

  // optional string imported_auxiliary_movie_data_original_filename = 25;
  bool has_imported_auxiliary_movie_data_original_filename() const;
  private:
  bool _internal_has_imported_auxiliary_movie_data_original_filename() const;
  public:
  void clear_imported_auxiliary_movie_data_original_filename();
  const std::string& imported_auxiliary_movie_data_original_filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imported_auxiliary_movie_data_original_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imported_auxiliary_movie_data_original_filename();
  std::string* release_imported_auxiliary_movie_data_original_filename();
  void set_allocated_imported_auxiliary_movie_data_original_filename(std::string* imported_auxiliary_movie_data_original_filename);
  private:
  const std::string& _internal_imported_auxiliary_movie_data_original_filename() const;
  void _internal_set_imported_auxiliary_movie_data_original_filename(const std::string& value);
  std::string* _internal_mutable_imported_auxiliary_movie_data_original_filename();
  public:

  // required .TSD.DrawableArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::DrawableArchive& super() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::DrawableArchive* release_super();
  ::TSD::DrawableArchive* mutable_super();
  void set_allocated_super(::TSD::DrawableArchive* super);
  private:
  const ::TSD::DrawableArchive& _internal_super() const;
  ::TSD::DrawableArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::DrawableArchive* super);
  ::TSD::DrawableArchive* unsafe_arena_release_super();

  // optional .TSP.Reference database_movieData = 2;
  bool has_database_moviedata() const;
  private:
  bool _internal_has_database_moviedata() const;
  public:
  void clear_database_moviedata();
  const ::TSP::Reference& database_moviedata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_database_moviedata();
  ::TSP::Reference* mutable_database_moviedata();
  void set_allocated_database_moviedata(::TSP::Reference* database_moviedata);
  private:
  const ::TSP::Reference& _internal_database_moviedata() const;
  ::TSP::Reference* _internal_mutable_database_moviedata();
  public:
  void unsafe_arena_set_allocated_database_moviedata(
      ::TSP::Reference* database_moviedata);
  ::TSP::Reference* unsafe_arena_release_database_moviedata();

  // optional .TSP.Reference database_posterImageData = 10;
  bool has_database_posterimagedata() const;
  private:
  bool _internal_has_database_posterimagedata() const;
  public:
  void clear_database_posterimagedata();
  const ::TSP::Reference& database_posterimagedata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_database_posterimagedata();
  ::TSP::Reference* mutable_database_posterimagedata();
  void set_allocated_database_posterimagedata(::TSP::Reference* database_posterimagedata);
  private:
  const ::TSP::Reference& _internal_database_posterimagedata() const;
  ::TSP::Reference* _internal_mutable_database_posterimagedata();
  public:
  void unsafe_arena_set_allocated_database_posterimagedata(
      ::TSP::Reference* database_posterimagedata);
  ::TSP::Reference* unsafe_arena_release_database_posterimagedata();

  // optional .TSP.Reference database_audioOnlyImageData = 11;
  bool has_database_audioonlyimagedata() const;
  private:
  bool _internal_has_database_audioonlyimagedata() const;
  public:
  void clear_database_audioonlyimagedata();
  const ::TSP::Reference& database_audioonlyimagedata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_database_audioonlyimagedata();
  ::TSP::Reference* mutable_database_audioonlyimagedata();
  void set_allocated_database_audioonlyimagedata(::TSP::Reference* database_audioonlyimagedata);
  private:
  const ::TSP::Reference& _internal_database_audioonlyimagedata() const;
  ::TSP::Reference* _internal_mutable_database_audioonlyimagedata();
  public:
  void unsafe_arena_set_allocated_database_audioonlyimagedata(
      ::TSP::Reference* database_audioonlyimagedata);
  ::TSP::Reference* unsafe_arena_release_database_audioonlyimagedata();

  // optional .TSP.DataReference movieData = 14;
  bool has_moviedata() const;
  private:
  bool _internal_has_moviedata() const;
  public:
  void clear_moviedata();
  const ::TSP::DataReference& moviedata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::DataReference* release_moviedata();
  ::TSP::DataReference* mutable_moviedata();
  void set_allocated_moviedata(::TSP::DataReference* moviedata);
  private:
  const ::TSP::DataReference& _internal_moviedata() const;
  ::TSP::DataReference* _internal_mutable_moviedata();
  public:
  void unsafe_arena_set_allocated_moviedata(
      ::TSP::DataReference* moviedata);
  ::TSP::DataReference* unsafe_arena_release_moviedata();

  // optional .TSP.DataReference posterImageData = 15;
  bool has_posterimagedata() const;
  private:
  bool _internal_has_posterimagedata() const;
  public:
  void clear_posterimagedata();
  const ::TSP::DataReference& posterimagedata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::DataReference* release_posterimagedata();
  ::TSP::DataReference* mutable_posterimagedata();
  void set_allocated_posterimagedata(::TSP::DataReference* posterimagedata);
  private:
  const ::TSP::DataReference& _internal_posterimagedata() const;
  ::TSP::DataReference* _internal_mutable_posterimagedata();
  public:
  void unsafe_arena_set_allocated_posterimagedata(
      ::TSP::DataReference* posterimagedata);
  ::TSP::DataReference* unsafe_arena_release_posterimagedata();

  // optional .TSP.DataReference audioOnlyImageData = 16;
  bool has_audioonlyimagedata() const;
  private:
  bool _internal_has_audioonlyimagedata() const;
  public:
  void clear_audioonlyimagedata();
  const ::TSP::DataReference& audioonlyimagedata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::DataReference* release_audioonlyimagedata();
  ::TSP::DataReference* mutable_audioonlyimagedata();
  void set_allocated_audioonlyimagedata(::TSP::DataReference* audioonlyimagedata);
  private:
  const ::TSP::DataReference& _internal_audioonlyimagedata() const;
  ::TSP::DataReference* _internal_mutable_audioonlyimagedata();
  public:
  void unsafe_arena_set_allocated_audioonlyimagedata(
      ::TSP::DataReference* audioonlyimagedata);
  ::TSP::DataReference* unsafe_arena_release_audioonlyimagedata();

  // optional .TSP.Reference style = 19;
  bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  void clear_style();
  const ::TSP::Reference& style() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_style();
  ::TSP::Reference* mutable_style();
  void set_allocated_style(::TSP::Reference* style);
  private:
  const ::TSP::Reference& _internal_style() const;
  ::TSP::Reference* _internal_mutable_style();
  public:
  void unsafe_arena_set_allocated_style(
      ::TSP::Reference* style);
  ::TSP::Reference* unsafe_arena_release_style();

  // optional .TSP.Size originalSize = 20;
  bool has_originalsize() const;
  private:
  bool _internal_has_originalsize() const;
  public:
  void clear_originalsize();
  const ::TSP::Size& originalsize() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_originalsize();
  ::TSP::Size* mutable_originalsize();
  void set_allocated_originalsize(::TSP::Size* originalsize);
  private:
  const ::TSP::Size& _internal_originalsize() const;
  ::TSP::Size* _internal_mutable_originalsize();
  public:
  void unsafe_arena_set_allocated_originalsize(
      ::TSP::Size* originalsize);
  ::TSP::Size* unsafe_arena_release_originalsize();

  // optional .TSP.Size naturalSize = 21;
  bool has_naturalsize() const;
  private:
  bool _internal_has_naturalsize() const;
  public:
  void clear_naturalsize();
  const ::TSP::Size& naturalsize() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_naturalsize();
  ::TSP::Size* mutable_naturalsize();
  void set_allocated_naturalsize(::TSP::Size* naturalsize);
  private:
  const ::TSP::Size& _internal_naturalsize() const;
  ::TSP::Size* _internal_mutable_naturalsize();
  public:
  void unsafe_arena_set_allocated_naturalsize(
      ::TSP::Size* naturalsize);
  ::TSP::Size* unsafe_arena_release_naturalsize();

  // optional .TSP.DataReference importedAuxiliaryMovieData = 22;
  bool has_importedauxiliarymoviedata() const;
  private:
  bool _internal_has_importedauxiliarymoviedata() const;
  public:
  void clear_importedauxiliarymoviedata();
  const ::TSP::DataReference& importedauxiliarymoviedata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::DataReference* release_importedauxiliarymoviedata();
  ::TSP::DataReference* mutable_importedauxiliarymoviedata();
  void set_allocated_importedauxiliarymoviedata(::TSP::DataReference* importedauxiliarymoviedata);
  private:
  const ::TSP::DataReference& _internal_importedauxiliarymoviedata() const;
  ::TSP::DataReference* _internal_mutable_importedauxiliarymoviedata();
  public:
  void unsafe_arena_set_allocated_importedauxiliarymoviedata(
      ::TSP::DataReference* importedauxiliarymoviedata);
  ::TSP::DataReference* unsafe_arena_release_importedauxiliarymoviedata();

  // optional .TSD.Attribution attribution = 26;
  bool has_attribution() const;
  private:
  bool _internal_has_attribution() const;
  public:
  void clear_attribution();
  const ::TSD::Attribution& attribution() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::Attribution* release_attribution();
  ::TSD::Attribution* mutable_attribution();
  void set_allocated_attribution(::TSD::Attribution* attribution);
  private:
  const ::TSD::Attribution& _internal_attribution() const;
  ::TSD::Attribution* _internal_mutable_attribution();
  public:
  void unsafe_arena_set_allocated_attribution(
      ::TSD::Attribution* attribution);
  ::TSD::Attribution* unsafe_arena_release_attribution();

  // optional .TSD.MovieFingerprint fingerprint = 29;
  bool has_fingerprint() const;
  private:
  bool _internal_has_fingerprint() const;
  public:
  void clear_fingerprint();
  const ::TSD::MovieFingerprint& fingerprint() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::MovieFingerprint* release_fingerprint();
  ::TSD::MovieFingerprint* mutable_fingerprint();
  void set_allocated_fingerprint(::TSD::MovieFingerprint* fingerprint);
  private:
  const ::TSD::MovieFingerprint& _internal_fingerprint() const;
  ::TSD::MovieFingerprint* _internal_mutable_fingerprint();
  public:
  void unsafe_arena_set_allocated_fingerprint(
      ::TSD::MovieFingerprint* fingerprint);
  ::TSD::MovieFingerprint* unsafe_arena_release_fingerprint();

  // optional float startTime = 3;
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;
  public:
  void clear_starttime();
  float starttime() const;
  void set_starttime(float value);
  private:
  float _internal_starttime() const;
  void _internal_set_starttime(float value);
  public:

  // optional float endTime = 4;
  bool has_endtime() const;
  private:
  bool _internal_has_endtime() const;
  public:
  void clear_endtime();
  float endtime() const;
  void set_endtime(float value);
  private:
  float _internal_endtime() const;
  void _internal_set_endtime(float value);
  public:

  // optional float posterTime = 5;
  bool has_postertime() const;
  private:
  bool _internal_has_postertime() const;
  public:
  void clear_postertime();
  float postertime() const;
  void set_postertime(float value);
  private:
  float _internal_postertime() const;
  void _internal_set_postertime(float value);
  public:

  // optional uint32 loopOptionAsInteger = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_loopoptionasinteger() const;
  private:
  bool _internal_has_loopoptionasinteger() const;
  public:
  PROTOBUF_DEPRECATED void clear_loopoptionasinteger();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::uint32 loopoptionasinteger() const;
  PROTOBUF_DEPRECATED void set_loopoptionasinteger(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_loopoptionasinteger() const;
  void _internal_set_loopoptionasinteger(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float volume = 7;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;
  public:
  void clear_volume();
  float volume() const;
  void set_volume(float value);
  private:
  float _internal_volume() const;
  void _internal_set_volume(float value);
  public:

  // optional uint32 playableState = 12;
  bool has_playablestate() const;
  private:
  bool _internal_has_playablestate() const;
  public:
  void clear_playablestate();
  ::PROTOBUF_NAMESPACE_ID::uint32 playablestate() const;
  void set_playablestate(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_playablestate() const;
  void _internal_set_playablestate(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 flags = 13;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_flags() const;
  void _internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool autoPlay = 8 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_autoplay() const;
  private:
  bool _internal_has_autoplay() const;
  public:
  PROTOBUF_DEPRECATED void clear_autoplay();
  PROTOBUF_DEPRECATED bool autoplay() const;
  PROTOBUF_DEPRECATED void set_autoplay(bool value);
  private:
  bool _internal_autoplay() const;
  void _internal_set_autoplay(bool value);
  public:

  // optional bool audioOnly = 9;
  bool has_audioonly() const;
  private:
  bool _internal_has_audioonly() const;
  public:
  void clear_audioonly();
  bool audioonly() const;
  void set_audioonly(bool value);
  private:
  bool _internal_audioonly() const;
  void _internal_set_audioonly(bool value);
  public:

  // optional bool streaming = 18;
  bool has_streaming() const;
  private:
  bool _internal_has_streaming() const;
  public:
  void clear_streaming();
  bool streaming() const;
  void set_streaming(bool value);
  private:
  bool _internal_streaming() const;
  void _internal_set_streaming(bool value);
  public:

  // optional bool nativeAudioRecording = 27;
  bool has_nativeaudiorecording() const;
  private:
  bool _internal_has_nativeaudiorecording() const;
  public:
  void clear_nativeaudiorecording();
  bool nativeaudiorecording() const;
  void set_nativeaudiorecording(bool value);
  private:
  bool _internal_nativeaudiorecording() const;
  void _internal_set_nativeaudiorecording(bool value);
  public:

  // optional .TSD.MovieArchive.MovieLoopOption loop_option = 24 [default = None];
  bool has_loop_option() const;
  private:
  bool _internal_has_loop_option() const;
  public:
  void clear_loop_option();
  ::TSD::MovieArchive_MovieLoopOption loop_option() const;
  void set_loop_option(::TSD::MovieArchive_MovieLoopOption value);
  private:
  ::TSD::MovieArchive_MovieLoopOption _internal_loop_option() const;
  void _internal_set_loop_option(::TSD::MovieArchive_MovieLoopOption value);
  public:

  // optional bool playsAcrossSlides = 28;
  bool has_playsacrossslides() const;
  private:
  bool _internal_has_playsacrossslides() const;
  public:
  void clear_playsacrossslides();
  bool playsacrossslides() const;
  void set_playsacrossslides(bool value);
  private:
  bool _internal_playsacrossslides() const;
  void _internal_set_playsacrossslides(bool value);
  public:

  // optional bool poster_image_generated_with_alpha_support = 23;
  bool has_poster_image_generated_with_alpha_support() const;
  private:
  bool _internal_has_poster_image_generated_with_alpha_support() const;
  public:
  void clear_poster_image_generated_with_alpha_support();
  bool poster_image_generated_with_alpha_support() const;
  void set_poster_image_generated_with_alpha_support(bool value);
  private:
  bool _internal_poster_image_generated_with_alpha_support() const;
  void _internal_set_poster_image_generated_with_alpha_support(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.MovieArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr movieremoteurl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imported_auxiliary_movie_data_original_filename_;
  ::TSD::DrawableArchive* super_;
  ::TSP::Reference* database_moviedata_;
  ::TSP::Reference* database_posterimagedata_;
  ::TSP::Reference* database_audioonlyimagedata_;
  ::TSP::DataReference* moviedata_;
  ::TSP::DataReference* posterimagedata_;
  ::TSP::DataReference* audioonlyimagedata_;
  ::TSP::Reference* style_;
  ::TSP::Size* originalsize_;
  ::TSP::Size* naturalsize_;
  ::TSP::DataReference* importedauxiliarymoviedata_;
  ::TSD::Attribution* attribution_;
  ::TSD::MovieFingerprint* fingerprint_;
  float starttime_;
  float endtime_;
  float postertime_;
  ::PROTOBUF_NAMESPACE_ID::uint32 loopoptionasinteger_;
  float volume_;
  ::PROTOBUF_NAMESPACE_ID::uint32 playablestate_;
  ::PROTOBUF_NAMESPACE_ID::uint32 flags_;
  bool autoplay_;
  bool audioonly_;
  bool streaming_;
  bool nativeaudiorecording_;
  int loop_option_;
  bool playsacrossslides_;
  bool poster_image_generated_with_alpha_support_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ExteriorTextWrapArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ExteriorTextWrapArchive) */ {
 public:
  inline ExteriorTextWrapArchive() : ExteriorTextWrapArchive(nullptr) {}
  ~ExteriorTextWrapArchive() override;
  explicit constexpr ExteriorTextWrapArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExteriorTextWrapArchive(const ExteriorTextWrapArchive& from);
  ExteriorTextWrapArchive(ExteriorTextWrapArchive&& from) noexcept
    : ExteriorTextWrapArchive() {
    *this = ::std::move(from);
  }

  inline ExteriorTextWrapArchive& operator=(const ExteriorTextWrapArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExteriorTextWrapArchive& operator=(ExteriorTextWrapArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExteriorTextWrapArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExteriorTextWrapArchive* internal_default_instance() {
    return reinterpret_cast<const ExteriorTextWrapArchive*>(
               &_ExteriorTextWrapArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ExteriorTextWrapArchive& a, ExteriorTextWrapArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ExteriorTextWrapArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExteriorTextWrapArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExteriorTextWrapArchive* New() const final {
    return CreateMaybeMessage<ExteriorTextWrapArchive>(nullptr);
  }

  ExteriorTextWrapArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExteriorTextWrapArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExteriorTextWrapArchive& from);
  void MergeFrom(const ExteriorTextWrapArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExteriorTextWrapArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ExteriorTextWrapArchive";
  }
  protected:
  explicit ExteriorTextWrapArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kDirectionFieldNumber = 2,
    kFitTypeFieldNumber = 3,
    kMarginFieldNumber = 4,
    kAlphaThresholdFieldNumber = 5,
    kIsHtmlWrapFieldNumber = 6,
  };
  // optional uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 direction = 2;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  ::PROTOBUF_NAMESPACE_ID::uint32 direction() const;
  void set_direction(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_direction() const;
  void _internal_set_direction(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 fit_type = 3;
  bool has_fit_type() const;
  private:
  bool _internal_has_fit_type() const;
  public:
  void clear_fit_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 fit_type() const;
  void set_fit_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_fit_type() const;
  void _internal_set_fit_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float margin = 4;
  bool has_margin() const;
  private:
  bool _internal_has_margin() const;
  public:
  void clear_margin();
  float margin() const;
  void set_margin(float value);
  private:
  float _internal_margin() const;
  void _internal_set_margin(float value);
  public:

  // optional float alpha_threshold = 5;
  bool has_alpha_threshold() const;
  private:
  bool _internal_has_alpha_threshold() const;
  public:
  void clear_alpha_threshold();
  float alpha_threshold() const;
  void set_alpha_threshold(float value);
  private:
  float _internal_alpha_threshold() const;
  void _internal_set_alpha_threshold(float value);
  public:

  // optional bool is_html_wrap = 6;
  bool has_is_html_wrap() const;
  private:
  bool _internal_has_is_html_wrap() const;
  public:
  void clear_is_html_wrap();
  bool is_html_wrap() const;
  void set_is_html_wrap(bool value);
  private:
  bool _internal_is_html_wrap() const;
  void _internal_set_is_html_wrap(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ExteriorTextWrapArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 direction_;
  ::PROTOBUF_NAMESPACE_ID::uint32 fit_type_;
  float margin_;
  float alpha_threshold_;
  bool is_html_wrap_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class DrawableContentDescription PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.DrawableContentDescription) */ {
 public:
  inline DrawableContentDescription() : DrawableContentDescription(nullptr) {}
  ~DrawableContentDescription() override;
  explicit constexpr DrawableContentDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawableContentDescription(const DrawableContentDescription& from);
  DrawableContentDescription(DrawableContentDescription&& from) noexcept
    : DrawableContentDescription() {
    *this = ::std::move(from);
  }

  inline DrawableContentDescription& operator=(const DrawableContentDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawableContentDescription& operator=(DrawableContentDescription&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawableContentDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawableContentDescription* internal_default_instance() {
    return reinterpret_cast<const DrawableContentDescription*>(
               &_DrawableContentDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(DrawableContentDescription& a, DrawableContentDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawableContentDescription* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawableContentDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DrawableContentDescription* New() const final {
    return CreateMaybeMessage<DrawableContentDescription>(nullptr);
  }

  DrawableContentDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DrawableContentDescription>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DrawableContentDescription& from);
  void MergeFrom(const DrawableContentDescription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawableContentDescription* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.DrawableContentDescription";
  }
  protected:
  explicit DrawableContentDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementKindFieldNumber = 1,
    kIsAnchoredToTextFieldNumber = 2,
    kIsFloatingAboveTextFieldNumber = 3,
    kIsInlineWithTextFieldNumber = 4,
  };
  // optional uint32 element_kind = 1;
  bool has_element_kind() const;
  private:
  bool _internal_has_element_kind() const;
  public:
  void clear_element_kind();
  ::PROTOBUF_NAMESPACE_ID::uint32 element_kind() const;
  void set_element_kind(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_element_kind() const;
  void _internal_set_element_kind(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool is_anchored_to_text = 2;
  bool has_is_anchored_to_text() const;
  private:
  bool _internal_has_is_anchored_to_text() const;
  public:
  void clear_is_anchored_to_text();
  bool is_anchored_to_text() const;
  void set_is_anchored_to_text(bool value);
  private:
  bool _internal_is_anchored_to_text() const;
  void _internal_set_is_anchored_to_text(bool value);
  public:

  // optional bool is_floating_above_text = 3;
  bool has_is_floating_above_text() const;
  private:
  bool _internal_has_is_floating_above_text() const;
  public:
  void clear_is_floating_above_text();
  bool is_floating_above_text() const;
  void set_is_floating_above_text(bool value);
  private:
  bool _internal_is_floating_above_text() const;
  void _internal_set_is_floating_above_text(bool value);
  public:

  // optional bool is_inline_with_text = 4;
  bool has_is_inline_with_text() const;
  private:
  bool _internal_has_is_inline_with_text() const;
  public:
  void clear_is_inline_with_text();
  bool is_inline_with_text() const;
  void set_is_inline_with_text(bool value);
  private:
  bool _internal_is_inline_with_text() const;
  void _internal_set_is_inline_with_text(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.DrawableContentDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 element_kind_;
  bool is_anchored_to_text_;
  bool is_floating_above_text_;
  bool is_inline_with_text_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class FreehandDrawingContentDescription PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.FreehandDrawingContentDescription) */ {
 public:
  inline FreehandDrawingContentDescription() : FreehandDrawingContentDescription(nullptr) {}
  ~FreehandDrawingContentDescription() override;
  explicit constexpr FreehandDrawingContentDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreehandDrawingContentDescription(const FreehandDrawingContentDescription& from);
  FreehandDrawingContentDescription(FreehandDrawingContentDescription&& from) noexcept
    : FreehandDrawingContentDescription() {
    *this = ::std::move(from);
  }

  inline FreehandDrawingContentDescription& operator=(const FreehandDrawingContentDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreehandDrawingContentDescription& operator=(FreehandDrawingContentDescription&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreehandDrawingContentDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreehandDrawingContentDescription* internal_default_instance() {
    return reinterpret_cast<const FreehandDrawingContentDescription*>(
               &_FreehandDrawingContentDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(FreehandDrawingContentDescription& a, FreehandDrawingContentDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(FreehandDrawingContentDescription* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreehandDrawingContentDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FreehandDrawingContentDescription* New() const final {
    return CreateMaybeMessage<FreehandDrawingContentDescription>(nullptr);
  }

  FreehandDrawingContentDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FreehandDrawingContentDescription>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FreehandDrawingContentDescription& from);
  void MergeFrom(const FreehandDrawingContentDescription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreehandDrawingContentDescription* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.FreehandDrawingContentDescription";
  }
  protected:
  explicit FreehandDrawingContentDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kSourceDocWantedSpacerShapeFieldNumber = 2,
  };
  // required .TSD.DrawableContentDescription super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::DrawableContentDescription& super() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::DrawableContentDescription* release_super();
  ::TSD::DrawableContentDescription* mutable_super();
  void set_allocated_super(::TSD::DrawableContentDescription* super);
  private:
  const ::TSD::DrawableContentDescription& _internal_super() const;
  ::TSD::DrawableContentDescription* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::DrawableContentDescription* super);
  ::TSD::DrawableContentDescription* unsafe_arena_release_super();

  // optional bool source_doc_wanted_spacer_shape = 2;
  bool has_source_doc_wanted_spacer_shape() const;
  private:
  bool _internal_has_source_doc_wanted_spacer_shape() const;
  public:
  void clear_source_doc_wanted_spacer_shape();
  bool source_doc_wanted_spacer_shape() const;
  void set_source_doc_wanted_spacer_shape(bool value);
  private:
  bool _internal_source_doc_wanted_spacer_shape() const;
  void _internal_set_source_doc_wanted_spacer_shape(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.FreehandDrawingContentDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSD::DrawableContentDescription* super_;
  bool source_doc_wanted_spacer_shape_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class FreehandDrawingToolkitUIState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.FreehandDrawingToolkitUIState) */ {
 public:
  inline FreehandDrawingToolkitUIState() : FreehandDrawingToolkitUIState(nullptr) {}
  ~FreehandDrawingToolkitUIState() override;
  explicit constexpr FreehandDrawingToolkitUIState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreehandDrawingToolkitUIState(const FreehandDrawingToolkitUIState& from);
  FreehandDrawingToolkitUIState(FreehandDrawingToolkitUIState&& from) noexcept
    : FreehandDrawingToolkitUIState() {
    *this = ::std::move(from);
  }

  inline FreehandDrawingToolkitUIState& operator=(const FreehandDrawingToolkitUIState& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreehandDrawingToolkitUIState& operator=(FreehandDrawingToolkitUIState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreehandDrawingToolkitUIState& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreehandDrawingToolkitUIState* internal_default_instance() {
    return reinterpret_cast<const FreehandDrawingToolkitUIState*>(
               &_FreehandDrawingToolkitUIState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(FreehandDrawingToolkitUIState& a, FreehandDrawingToolkitUIState& b) {
    a.Swap(&b);
  }
  inline void Swap(FreehandDrawingToolkitUIState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreehandDrawingToolkitUIState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FreehandDrawingToolkitUIState* New() const final {
    return CreateMaybeMessage<FreehandDrawingToolkitUIState>(nullptr);
  }

  FreehandDrawingToolkitUIState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FreehandDrawingToolkitUIState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FreehandDrawingToolkitUIState& from);
  void MergeFrom(const FreehandDrawingToolkitUIState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreehandDrawingToolkitUIState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.FreehandDrawingToolkitUIState";
  }
  protected:
  explicit FreehandDrawingToolkitUIState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FreehandDrawingToolkitUIState_FreehandDrawingToolType FreehandDrawingToolType;
  static constexpr FreehandDrawingToolType Pen =
    FreehandDrawingToolkitUIState_FreehandDrawingToolType_Pen;
  static constexpr FreehandDrawingToolType Pencil =
    FreehandDrawingToolkitUIState_FreehandDrawingToolType_Pencil;
  static constexpr FreehandDrawingToolType Crayon =
    FreehandDrawingToolkitUIState_FreehandDrawingToolType_Crayon;
  static constexpr FreehandDrawingToolType Fill =
    FreehandDrawingToolkitUIState_FreehandDrawingToolType_Fill;
  static constexpr FreehandDrawingToolType Eraser =
    FreehandDrawingToolkitUIState_FreehandDrawingToolType_Eraser;
  static constexpr FreehandDrawingToolType MarqueeSelect =
    FreehandDrawingToolkitUIState_FreehandDrawingToolType_MarqueeSelect;
  static inline bool FreehandDrawingToolType_IsValid(int value) {
    return FreehandDrawingToolkitUIState_FreehandDrawingToolType_IsValid(value);
  }
  static constexpr FreehandDrawingToolType FreehandDrawingToolType_MIN =
    FreehandDrawingToolkitUIState_FreehandDrawingToolType_FreehandDrawingToolType_MIN;
  static constexpr FreehandDrawingToolType FreehandDrawingToolType_MAX =
    FreehandDrawingToolkitUIState_FreehandDrawingToolType_FreehandDrawingToolType_MAX;
  static constexpr int FreehandDrawingToolType_ARRAYSIZE =
    FreehandDrawingToolkitUIState_FreehandDrawingToolType_FreehandDrawingToolType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FreehandDrawingToolType_descriptor() {
    return FreehandDrawingToolkitUIState_FreehandDrawingToolType_descriptor();
  }
  template<typename T>
  static inline const std::string& FreehandDrawingToolType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FreehandDrawingToolType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FreehandDrawingToolType_Name.");
    return FreehandDrawingToolkitUIState_FreehandDrawingToolType_Name(enum_t_value);
  }
  static inline bool FreehandDrawingToolType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FreehandDrawingToolType* value) {
    return FreehandDrawingToolkitUIState_FreehandDrawingToolType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentColorFieldNumber = 1,
    kPenToolColorFieldNumber = 12,
    kPencilToolColorFieldNumber = 13,
    kCrayonToolColorFieldNumber = 14,
    kFillToolColorFieldNumber = 15,
    kMostRecentRestorableToolTypeFieldNumber = 2,
    kPenToolOpacityFieldNumber = 3,
    kPenToolUnscaledWidthFieldNumber = 4,
    kPencilToolOpacityFieldNumber = 5,
    kPencilToolUnscaledWidthFieldNumber = 6,
    kCrayonToolOpacityFieldNumber = 7,
    kCrayonToolUnscaledWidthFieldNumber = 8,
    kFillToolOpacityFieldNumber = 9,
    kEraserToolScaledWidthFieldNumber = 10,
    kEraserToolErasesWholeObjectsFieldNumber = 11,
  };
  // optional .TSP.Color current_color = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_current_color() const;
  private:
  bool _internal_has_current_color() const;
  public:
  PROTOBUF_DEPRECATED void clear_current_color();
  PROTOBUF_DEPRECATED const ::TSP::Color& current_color() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_DEPRECATED ::TSP::Color* release_current_color();
  PROTOBUF_DEPRECATED ::TSP::Color* mutable_current_color();
  PROTOBUF_DEPRECATED void set_allocated_current_color(::TSP::Color* current_color);
  private:
  const ::TSP::Color& _internal_current_color() const;
  ::TSP::Color* _internal_mutable_current_color();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_current_color(
      ::TSP::Color* current_color);
  PROTOBUF_DEPRECATED ::TSP::Color* unsafe_arena_release_current_color();

  // optional .TSP.Color pen_tool_color = 12;
  bool has_pen_tool_color() const;
  private:
  bool _internal_has_pen_tool_color() const;
  public:
  void clear_pen_tool_color();
  const ::TSP::Color& pen_tool_color() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_pen_tool_color();
  ::TSP::Color* mutable_pen_tool_color();
  void set_allocated_pen_tool_color(::TSP::Color* pen_tool_color);
  private:
  const ::TSP::Color& _internal_pen_tool_color() const;
  ::TSP::Color* _internal_mutable_pen_tool_color();
  public:
  void unsafe_arena_set_allocated_pen_tool_color(
      ::TSP::Color* pen_tool_color);
  ::TSP::Color* unsafe_arena_release_pen_tool_color();

  // optional .TSP.Color pencil_tool_color = 13;
  bool has_pencil_tool_color() const;
  private:
  bool _internal_has_pencil_tool_color() const;
  public:
  void clear_pencil_tool_color();
  const ::TSP::Color& pencil_tool_color() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_pencil_tool_color();
  ::TSP::Color* mutable_pencil_tool_color();
  void set_allocated_pencil_tool_color(::TSP::Color* pencil_tool_color);
  private:
  const ::TSP::Color& _internal_pencil_tool_color() const;
  ::TSP::Color* _internal_mutable_pencil_tool_color();
  public:
  void unsafe_arena_set_allocated_pencil_tool_color(
      ::TSP::Color* pencil_tool_color);
  ::TSP::Color* unsafe_arena_release_pencil_tool_color();

  // optional .TSP.Color crayon_tool_color = 14;
  bool has_crayon_tool_color() const;
  private:
  bool _internal_has_crayon_tool_color() const;
  public:
  void clear_crayon_tool_color();
  const ::TSP::Color& crayon_tool_color() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_crayon_tool_color();
  ::TSP::Color* mutable_crayon_tool_color();
  void set_allocated_crayon_tool_color(::TSP::Color* crayon_tool_color);
  private:
  const ::TSP::Color& _internal_crayon_tool_color() const;
  ::TSP::Color* _internal_mutable_crayon_tool_color();
  public:
  void unsafe_arena_set_allocated_crayon_tool_color(
      ::TSP::Color* crayon_tool_color);
  ::TSP::Color* unsafe_arena_release_crayon_tool_color();

  // optional .TSP.Color fill_tool_color = 15;
  bool has_fill_tool_color() const;
  private:
  bool _internal_has_fill_tool_color() const;
  public:
  void clear_fill_tool_color();
  const ::TSP::Color& fill_tool_color() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_fill_tool_color();
  ::TSP::Color* mutable_fill_tool_color();
  void set_allocated_fill_tool_color(::TSP::Color* fill_tool_color);
  private:
  const ::TSP::Color& _internal_fill_tool_color() const;
  ::TSP::Color* _internal_mutable_fill_tool_color();
  public:
  void unsafe_arena_set_allocated_fill_tool_color(
      ::TSP::Color* fill_tool_color);
  ::TSP::Color* unsafe_arena_release_fill_tool_color();

  // optional .TSD.FreehandDrawingToolkitUIState.FreehandDrawingToolType most_recent_restorable_tool_type = 2 [default = Pen];
  bool has_most_recent_restorable_tool_type() const;
  private:
  bool _internal_has_most_recent_restorable_tool_type() const;
  public:
  void clear_most_recent_restorable_tool_type();
  ::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType most_recent_restorable_tool_type() const;
  void set_most_recent_restorable_tool_type(::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType value);
  private:
  ::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType _internal_most_recent_restorable_tool_type() const;
  void _internal_set_most_recent_restorable_tool_type(::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType value);
  public:

  // optional float pen_tool_opacity = 3;
  bool has_pen_tool_opacity() const;
  private:
  bool _internal_has_pen_tool_opacity() const;
  public:
  void clear_pen_tool_opacity();
  float pen_tool_opacity() const;
  void set_pen_tool_opacity(float value);
  private:
  float _internal_pen_tool_opacity() const;
  void _internal_set_pen_tool_opacity(float value);
  public:

  // optional float pen_tool_unscaled_width = 4;
  bool has_pen_tool_unscaled_width() const;
  private:
  bool _internal_has_pen_tool_unscaled_width() const;
  public:
  void clear_pen_tool_unscaled_width();
  float pen_tool_unscaled_width() const;
  void set_pen_tool_unscaled_width(float value);
  private:
  float _internal_pen_tool_unscaled_width() const;
  void _internal_set_pen_tool_unscaled_width(float value);
  public:

  // optional float pencil_tool_opacity = 5;
  bool has_pencil_tool_opacity() const;
  private:
  bool _internal_has_pencil_tool_opacity() const;
  public:
  void clear_pencil_tool_opacity();
  float pencil_tool_opacity() const;
  void set_pencil_tool_opacity(float value);
  private:
  float _internal_pencil_tool_opacity() const;
  void _internal_set_pencil_tool_opacity(float value);
  public:

  // optional float pencil_tool_unscaled_width = 6;
  bool has_pencil_tool_unscaled_width() const;
  private:
  bool _internal_has_pencil_tool_unscaled_width() const;
  public:
  void clear_pencil_tool_unscaled_width();
  float pencil_tool_unscaled_width() const;
  void set_pencil_tool_unscaled_width(float value);
  private:
  float _internal_pencil_tool_unscaled_width() const;
  void _internal_set_pencil_tool_unscaled_width(float value);
  public:

  // optional float crayon_tool_opacity = 7;
  bool has_crayon_tool_opacity() const;
  private:
  bool _internal_has_crayon_tool_opacity() const;
  public:
  void clear_crayon_tool_opacity();
  float crayon_tool_opacity() const;
  void set_crayon_tool_opacity(float value);
  private:
  float _internal_crayon_tool_opacity() const;
  void _internal_set_crayon_tool_opacity(float value);
  public:

  // optional float crayon_tool_unscaled_width = 8;
  bool has_crayon_tool_unscaled_width() const;
  private:
  bool _internal_has_crayon_tool_unscaled_width() const;
  public:
  void clear_crayon_tool_unscaled_width();
  float crayon_tool_unscaled_width() const;
  void set_crayon_tool_unscaled_width(float value);
  private:
  float _internal_crayon_tool_unscaled_width() const;
  void _internal_set_crayon_tool_unscaled_width(float value);
  public:

  // optional float fill_tool_opacity = 9;
  bool has_fill_tool_opacity() const;
  private:
  bool _internal_has_fill_tool_opacity() const;
  public:
  void clear_fill_tool_opacity();
  float fill_tool_opacity() const;
  void set_fill_tool_opacity(float value);
  private:
  float _internal_fill_tool_opacity() const;
  void _internal_set_fill_tool_opacity(float value);
  public:

  // optional float eraser_tool_scaled_width = 10;
  bool has_eraser_tool_scaled_width() const;
  private:
  bool _internal_has_eraser_tool_scaled_width() const;
  public:
  void clear_eraser_tool_scaled_width();
  float eraser_tool_scaled_width() const;
  void set_eraser_tool_scaled_width(float value);
  private:
  float _internal_eraser_tool_scaled_width() const;
  void _internal_set_eraser_tool_scaled_width(float value);
  public:

  // optional bool eraser_tool_erases_whole_objects = 11;
  bool has_eraser_tool_erases_whole_objects() const;
  private:
  bool _internal_has_eraser_tool_erases_whole_objects() const;
  public:
  void clear_eraser_tool_erases_whole_objects();
  bool eraser_tool_erases_whole_objects() const;
  void set_eraser_tool_erases_whole_objects(bool value);
  private:
  bool _internal_eraser_tool_erases_whole_objects() const;
  void _internal_set_eraser_tool_erases_whole_objects(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.FreehandDrawingToolkitUIState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Color* current_color_;
  ::TSP::Color* pen_tool_color_;
  ::TSP::Color* pencil_tool_color_;
  ::TSP::Color* crayon_tool_color_;
  ::TSP::Color* fill_tool_color_;
  int most_recent_restorable_tool_type_;
  float pen_tool_opacity_;
  float pen_tool_unscaled_width_;
  float pencil_tool_opacity_;
  float pencil_tool_unscaled_width_;
  float crayon_tool_opacity_;
  float crayon_tool_unscaled_width_;
  float fill_tool_opacity_;
  float eraser_tool_scaled_width_;
  bool eraser_tool_erases_whole_objects_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class StandinCaptionArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.StandinCaptionArchive) */ {
 public:
  inline StandinCaptionArchive() : StandinCaptionArchive(nullptr) {}
  ~StandinCaptionArchive() override;
  explicit constexpr StandinCaptionArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StandinCaptionArchive(const StandinCaptionArchive& from);
  StandinCaptionArchive(StandinCaptionArchive&& from) noexcept
    : StandinCaptionArchive() {
    *this = ::std::move(from);
  }

  inline StandinCaptionArchive& operator=(const StandinCaptionArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StandinCaptionArchive& operator=(StandinCaptionArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StandinCaptionArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StandinCaptionArchive* internal_default_instance() {
    return reinterpret_cast<const StandinCaptionArchive*>(
               &_StandinCaptionArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(StandinCaptionArchive& a, StandinCaptionArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StandinCaptionArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StandinCaptionArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StandinCaptionArchive* New() const final {
    return CreateMaybeMessage<StandinCaptionArchive>(nullptr);
  }

  StandinCaptionArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StandinCaptionArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StandinCaptionArchive& from);
  void MergeFrom(const StandinCaptionArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StandinCaptionArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.StandinCaptionArchive";
  }
  protected:
  explicit StandinCaptionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TSD.StandinCaptionArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class GuideArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.GuideArchive) */ {
 public:
  inline GuideArchive() : GuideArchive(nullptr) {}
  ~GuideArchive() override;
  explicit constexpr GuideArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GuideArchive(const GuideArchive& from);
  GuideArchive(GuideArchive&& from) noexcept
    : GuideArchive() {
    *this = ::std::move(from);
  }

  inline GuideArchive& operator=(const GuideArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuideArchive& operator=(GuideArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuideArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuideArchive* internal_default_instance() {
    return reinterpret_cast<const GuideArchive*>(
               &_GuideArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(GuideArchive& a, GuideArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(GuideArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuideArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GuideArchive* New() const final {
    return CreateMaybeMessage<GuideArchive>(nullptr);
  }

  GuideArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GuideArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GuideArchive& from);
  void MergeFrom(const GuideArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuideArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.GuideArchive";
  }
  protected:
  explicit GuideArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GuideArchive_GuideType GuideType;
  static constexpr GuideType Horizontal =
    GuideArchive_GuideType_Horizontal;
  static constexpr GuideType Vertical =
    GuideArchive_GuideType_Vertical;
  static inline bool GuideType_IsValid(int value) {
    return GuideArchive_GuideType_IsValid(value);
  }
  static constexpr GuideType GuideType_MIN =
    GuideArchive_GuideType_GuideType_MIN;
  static constexpr GuideType GuideType_MAX =
    GuideArchive_GuideType_GuideType_MAX;
  static constexpr int GuideType_ARRAYSIZE =
    GuideArchive_GuideType_GuideType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GuideType_descriptor() {
    return GuideArchive_GuideType_descriptor();
  }
  template<typename T>
  static inline const std::string& GuideType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GuideType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GuideType_Name.");
    return GuideArchive_GuideType_Name(enum_t_value);
  }
  static inline bool GuideType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GuideType* value) {
    return GuideArchive_GuideType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
    kDynamicFieldNumber = 5,
    kInfiniteFieldNumber = 6,
  };
  // optional .TSD.GuideArchive.GuideType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::GuideArchive_GuideType type() const;
  void set_type(::TSD::GuideArchive_GuideType value);
  private:
  ::TSD::GuideArchive_GuideType _internal_type() const;
  void _internal_set_type(::TSD::GuideArchive_GuideType value);
  public:

  // optional float offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // optional float start = 3;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  float start() const;
  void set_start(float value);
  private:
  float _internal_start() const;
  void _internal_set_start(float value);
  public:

  // optional float end = 4;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  float end() const;
  void set_end(float value);
  private:
  float _internal_end() const;
  void _internal_set_end(float value);
  public:

  // optional bool dynamic = 5;
  bool has_dynamic() const;
  private:
  bool _internal_has_dynamic() const;
  public:
  void clear_dynamic();
  bool dynamic() const;
  void set_dynamic(bool value);
  private:
  bool _internal_dynamic() const;
  void _internal_set_dynamic(bool value);
  public:

  // optional bool infinite = 6;
  bool has_infinite() const;
  private:
  bool _internal_has_infinite() const;
  public:
  void clear_infinite();
  bool infinite() const;
  void set_infinite(bool value);
  private:
  bool _internal_infinite() const;
  void _internal_set_infinite(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.GuideArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int type_;
  float offset_;
  float start_;
  float end_;
  bool dynamic_;
  bool infinite_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class UserDefinedGuideArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.UserDefinedGuideArchive) */ {
 public:
  inline UserDefinedGuideArchive() : UserDefinedGuideArchive(nullptr) {}
  ~UserDefinedGuideArchive() override;
  explicit constexpr UserDefinedGuideArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserDefinedGuideArchive(const UserDefinedGuideArchive& from);
  UserDefinedGuideArchive(UserDefinedGuideArchive&& from) noexcept
    : UserDefinedGuideArchive() {
    *this = ::std::move(from);
  }

  inline UserDefinedGuideArchive& operator=(const UserDefinedGuideArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserDefinedGuideArchive& operator=(UserDefinedGuideArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserDefinedGuideArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserDefinedGuideArchive* internal_default_instance() {
    return reinterpret_cast<const UserDefinedGuideArchive*>(
               &_UserDefinedGuideArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(UserDefinedGuideArchive& a, UserDefinedGuideArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(UserDefinedGuideArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserDefinedGuideArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserDefinedGuideArchive* New() const final {
    return CreateMaybeMessage<UserDefinedGuideArchive>(nullptr);
  }

  UserDefinedGuideArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserDefinedGuideArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserDefinedGuideArchive& from);
  void MergeFrom(const UserDefinedGuideArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDefinedGuideArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.UserDefinedGuideArchive";
  }
  protected:
  explicit UserDefinedGuideArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserDefinedGuideArchive_GuideType GuideType;
  static constexpr GuideType Horizontal =
    UserDefinedGuideArchive_GuideType_Horizontal;
  static constexpr GuideType Vertical =
    UserDefinedGuideArchive_GuideType_Vertical;
  static inline bool GuideType_IsValid(int value) {
    return UserDefinedGuideArchive_GuideType_IsValid(value);
  }
  static constexpr GuideType GuideType_MIN =
    UserDefinedGuideArchive_GuideType_GuideType_MIN;
  static constexpr GuideType GuideType_MAX =
    UserDefinedGuideArchive_GuideType_GuideType_MAX;
  static constexpr int GuideType_ARRAYSIZE =
    UserDefinedGuideArchive_GuideType_GuideType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GuideType_descriptor() {
    return UserDefinedGuideArchive_GuideType_descriptor();
  }
  template<typename T>
  static inline const std::string& GuideType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GuideType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GuideType_Name.");
    return UserDefinedGuideArchive_GuideType_Name(enum_t_value);
  }
  static inline bool GuideType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GuideType* value) {
    return UserDefinedGuideArchive_GuideType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kPositionFieldNumber = 2,
  };
  // optional .TSD.UserDefinedGuideArchive.GuideType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::UserDefinedGuideArchive_GuideType type() const;
  void set_type(::TSD::UserDefinedGuideArchive_GuideType value);
  private:
  ::TSD::UserDefinedGuideArchive_GuideType _internal_type() const;
  void _internal_set_type(::TSD::UserDefinedGuideArchive_GuideType value);
  public:

  // optional float position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  float position() const;
  void set_position(float value);
  private:
  float _internal_position() const;
  void _internal_set_position(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.UserDefinedGuideArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int type_;
  float position_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class GuideStorageArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.GuideStorageArchive) */ {
 public:
  inline GuideStorageArchive() : GuideStorageArchive(nullptr) {}
  ~GuideStorageArchive() override;
  explicit constexpr GuideStorageArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GuideStorageArchive(const GuideStorageArchive& from);
  GuideStorageArchive(GuideStorageArchive&& from) noexcept
    : GuideStorageArchive() {
    *this = ::std::move(from);
  }

  inline GuideStorageArchive& operator=(const GuideStorageArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuideStorageArchive& operator=(GuideStorageArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuideStorageArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuideStorageArchive* internal_default_instance() {
    return reinterpret_cast<const GuideStorageArchive*>(
               &_GuideStorageArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(GuideStorageArchive& a, GuideStorageArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(GuideStorageArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuideStorageArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GuideStorageArchive* New() const final {
    return CreateMaybeMessage<GuideStorageArchive>(nullptr);
  }

  GuideStorageArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GuideStorageArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GuideStorageArchive& from);
  void MergeFrom(const GuideStorageArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuideStorageArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.GuideStorageArchive";
  }
  protected:
  explicit GuideStorageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDefinedGuidesFieldNumber = 1,
  };
  // repeated .TSD.UserDefinedGuideArchive userDefinedGuides = 1;
  int userdefinedguides_size() const;
  private:
  int _internal_userdefinedguides_size() const;
  public:
  void clear_userdefinedguides();
  ::TSD::UserDefinedGuideArchive* mutable_userdefinedguides(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::UserDefinedGuideArchive >*
      mutable_userdefinedguides();
  private:
  const ::TSD::UserDefinedGuideArchive& _internal_userdefinedguides(int index) const;
  ::TSD::UserDefinedGuideArchive* _internal_add_userdefinedguides();
  public:
  const ::TSD::UserDefinedGuideArchive& userdefinedguides(int index) const;
  ::TSD::UserDefinedGuideArchive* add_userdefinedguides();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::UserDefinedGuideArchive >&
      userdefinedguides() const;

  // @@protoc_insertion_point(class_scope:TSD.GuideStorageArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::UserDefinedGuideArchive > userdefinedguides_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class CanvasSelectionArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.CanvasSelectionArchive) */ {
 public:
  inline CanvasSelectionArchive() : CanvasSelectionArchive(nullptr) {}
  ~CanvasSelectionArchive() override;
  explicit constexpr CanvasSelectionArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CanvasSelectionArchive(const CanvasSelectionArchive& from);
  CanvasSelectionArchive(CanvasSelectionArchive&& from) noexcept
    : CanvasSelectionArchive() {
    *this = ::std::move(from);
  }

  inline CanvasSelectionArchive& operator=(const CanvasSelectionArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CanvasSelectionArchive& operator=(CanvasSelectionArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CanvasSelectionArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CanvasSelectionArchive* internal_default_instance() {
    return reinterpret_cast<const CanvasSelectionArchive*>(
               &_CanvasSelectionArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(CanvasSelectionArchive& a, CanvasSelectionArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CanvasSelectionArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CanvasSelectionArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CanvasSelectionArchive* New() const final {
    return CreateMaybeMessage<CanvasSelectionArchive>(nullptr);
  }

  CanvasSelectionArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CanvasSelectionArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CanvasSelectionArchive& from);
  void MergeFrom(const CanvasSelectionArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CanvasSelectionArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.CanvasSelectionArchive";
  }
  protected:
  explicit CanvasSelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfosFieldNumber = 1,
    kNonInteractiveInfosFieldNumber = 3,
    kContainerFieldNumber = 2,
  };
  // repeated .TSP.Reference infos = 1;
  int infos_size() const;
  private:
  int _internal_infos_size() const;
  public:
  void clear_infos();
  ::TSP::Reference* mutable_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_infos();
  private:
  const ::TSP::Reference& _internal_infos(int index) const;
  ::TSP::Reference* _internal_add_infos();
  public:
  const ::TSP::Reference& infos(int index) const;
  ::TSP::Reference* add_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      infos() const;

  // repeated .TSP.Reference non_interactive_infos = 3;
  int non_interactive_infos_size() const;
  private:
  int _internal_non_interactive_infos_size() const;
  public:
  void clear_non_interactive_infos();
  ::TSP::Reference* mutable_non_interactive_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_non_interactive_infos();
  private:
  const ::TSP::Reference& _internal_non_interactive_infos(int index) const;
  ::TSP::Reference* _internal_add_non_interactive_infos();
  public:
  const ::TSP::Reference& non_interactive_infos(int index) const;
  ::TSP::Reference* add_non_interactive_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      non_interactive_infos() const;

  // optional .TSP.Reference container = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_container() const;
  private:
  bool _internal_has_container() const;
  public:
  PROTOBUF_DEPRECATED void clear_container();
  PROTOBUF_DEPRECATED const ::TSP::Reference& container() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_DEPRECATED ::TSP::Reference* release_container();
  PROTOBUF_DEPRECATED ::TSP::Reference* mutable_container();
  PROTOBUF_DEPRECATED void set_allocated_container(::TSP::Reference* container);
  private:
  const ::TSP::Reference& _internal_container() const;
  ::TSP::Reference* _internal_mutable_container();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_container(
      ::TSP::Reference* container);
  PROTOBUF_DEPRECATED ::TSP::Reference* unsafe_arena_release_container();

  // @@protoc_insertion_point(class_scope:TSD.CanvasSelectionArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > non_interactive_infos_;
  ::TSP::Reference* container_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class DrawableSelectionArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.DrawableSelectionArchive) */ {
 public:
  inline DrawableSelectionArchive() : DrawableSelectionArchive(nullptr) {}
  ~DrawableSelectionArchive() override;
  explicit constexpr DrawableSelectionArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawableSelectionArchive(const DrawableSelectionArchive& from);
  DrawableSelectionArchive(DrawableSelectionArchive&& from) noexcept
    : DrawableSelectionArchive() {
    *this = ::std::move(from);
  }

  inline DrawableSelectionArchive& operator=(const DrawableSelectionArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawableSelectionArchive& operator=(DrawableSelectionArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawableSelectionArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawableSelectionArchive* internal_default_instance() {
    return reinterpret_cast<const DrawableSelectionArchive*>(
               &_DrawableSelectionArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(DrawableSelectionArchive& a, DrawableSelectionArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawableSelectionArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawableSelectionArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DrawableSelectionArchive* New() const final {
    return CreateMaybeMessage<DrawableSelectionArchive>(nullptr);
  }

  DrawableSelectionArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DrawableSelectionArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DrawableSelectionArchive& from);
  void MergeFrom(const DrawableSelectionArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawableSelectionArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.DrawableSelectionArchive";
  }
  protected:
  explicit DrawableSelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfosFieldNumber = 2,
    kNonInteractiveInfosFieldNumber = 3,
  };
  // repeated .TSP.Reference infos = 2;
  int infos_size() const;
  private:
  int _internal_infos_size() const;
  public:
  void clear_infos();
  ::TSP::Reference* mutable_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_infos();
  private:
  const ::TSP::Reference& _internal_infos(int index) const;
  ::TSP::Reference* _internal_add_infos();
  public:
  const ::TSP::Reference& infos(int index) const;
  ::TSP::Reference* add_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      infos() const;

  // repeated .TSP.Reference non_interactive_infos = 3;
  int non_interactive_infos_size() const;
  private:
  int _internal_non_interactive_infos_size() const;
  public:
  void clear_non_interactive_infos();
  ::TSP::Reference* mutable_non_interactive_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_non_interactive_infos();
  private:
  const ::TSP::Reference& _internal_non_interactive_infos(int index) const;
  ::TSP::Reference* _internal_add_non_interactive_infos();
  public:
  const ::TSP::Reference& non_interactive_infos(int index) const;
  ::TSP::Reference* add_non_interactive_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      non_interactive_infos() const;

  // @@protoc_insertion_point(class_scope:TSD.DrawableSelectionArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > non_interactive_infos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class GroupSelectionArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.GroupSelectionArchive) */ {
 public:
  inline GroupSelectionArchive() : GroupSelectionArchive(nullptr) {}
  ~GroupSelectionArchive() override;
  explicit constexpr GroupSelectionArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupSelectionArchive(const GroupSelectionArchive& from);
  GroupSelectionArchive(GroupSelectionArchive&& from) noexcept
    : GroupSelectionArchive() {
    *this = ::std::move(from);
  }

  inline GroupSelectionArchive& operator=(const GroupSelectionArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupSelectionArchive& operator=(GroupSelectionArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupSelectionArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupSelectionArchive* internal_default_instance() {
    return reinterpret_cast<const GroupSelectionArchive*>(
               &_GroupSelectionArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(GroupSelectionArchive& a, GroupSelectionArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupSelectionArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupSelectionArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GroupSelectionArchive* New() const final {
    return CreateMaybeMessage<GroupSelectionArchive>(nullptr);
  }

  GroupSelectionArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GroupSelectionArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GroupSelectionArchive& from);
  void MergeFrom(const GroupSelectionArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupSelectionArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.GroupSelectionArchive";
  }
  protected:
  explicit GroupSelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kHasSelectedInfosInNonGroupContainerFieldNumber = 2,
  };
  // required .TSD.DrawableSelectionArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::DrawableSelectionArchive& super() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::DrawableSelectionArchive* release_super();
  ::TSD::DrawableSelectionArchive* mutable_super();
  void set_allocated_super(::TSD::DrawableSelectionArchive* super);
  private:
  const ::TSD::DrawableSelectionArchive& _internal_super() const;
  ::TSD::DrawableSelectionArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::DrawableSelectionArchive* super);
  ::TSD::DrawableSelectionArchive* unsafe_arena_release_super();

  // optional bool has_selected_infos_in_non_group_container = 2;
  bool has_has_selected_infos_in_non_group_container() const;
  private:
  bool _internal_has_has_selected_infos_in_non_group_container() const;
  public:
  void clear_has_selected_infos_in_non_group_container();
  bool has_selected_infos_in_non_group_container() const;
  void set_has_selected_infos_in_non_group_container(bool value);
  private:
  bool _internal_has_selected_infos_in_non_group_container() const;
  void _internal_set_has_selected_infos_in_non_group_container(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.GroupSelectionArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSD::DrawableSelectionArchive* super_;
  bool has_selected_infos_in_non_group_container_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class PathSelectionArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.PathSelectionArchive) */ {
 public:
  inline PathSelectionArchive() : PathSelectionArchive(nullptr) {}
  ~PathSelectionArchive() override;
  explicit constexpr PathSelectionArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathSelectionArchive(const PathSelectionArchive& from);
  PathSelectionArchive(PathSelectionArchive&& from) noexcept
    : PathSelectionArchive() {
    *this = ::std::move(from);
  }

  inline PathSelectionArchive& operator=(const PathSelectionArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathSelectionArchive& operator=(PathSelectionArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathSelectionArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathSelectionArchive* internal_default_instance() {
    return reinterpret_cast<const PathSelectionArchive*>(
               &_PathSelectionArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(PathSelectionArchive& a, PathSelectionArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PathSelectionArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathSelectionArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PathSelectionArchive* New() const final {
    return CreateMaybeMessage<PathSelectionArchive>(nullptr);
  }

  PathSelectionArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PathSelectionArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PathSelectionArchive& from);
  void MergeFrom(const PathSelectionArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathSelectionArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.PathSelectionArchive";
  }
  protected:
  explicit PathSelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TSD.PathSelectionArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class InfoHyperlinkSelectionArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.InfoHyperlinkSelectionArchive) */ {
 public:
  inline InfoHyperlinkSelectionArchive() : InfoHyperlinkSelectionArchive(nullptr) {}
  ~InfoHyperlinkSelectionArchive() override;
  explicit constexpr InfoHyperlinkSelectionArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InfoHyperlinkSelectionArchive(const InfoHyperlinkSelectionArchive& from);
  InfoHyperlinkSelectionArchive(InfoHyperlinkSelectionArchive&& from) noexcept
    : InfoHyperlinkSelectionArchive() {
    *this = ::std::move(from);
  }

  inline InfoHyperlinkSelectionArchive& operator=(const InfoHyperlinkSelectionArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoHyperlinkSelectionArchive& operator=(InfoHyperlinkSelectionArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InfoHyperlinkSelectionArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfoHyperlinkSelectionArchive* internal_default_instance() {
    return reinterpret_cast<const InfoHyperlinkSelectionArchive*>(
               &_InfoHyperlinkSelectionArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(InfoHyperlinkSelectionArchive& a, InfoHyperlinkSelectionArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(InfoHyperlinkSelectionArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoHyperlinkSelectionArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InfoHyperlinkSelectionArchive* New() const final {
    return CreateMaybeMessage<InfoHyperlinkSelectionArchive>(nullptr);
  }

  InfoHyperlinkSelectionArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InfoHyperlinkSelectionArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InfoHyperlinkSelectionArchive& from);
  void MergeFrom(const InfoHyperlinkSelectionArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InfoHyperlinkSelectionArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.InfoHyperlinkSelectionArchive";
  }
  protected:
  explicit InfoHyperlinkSelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TSD.InfoHyperlinkSelectionArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class CommentStorageArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.CommentStorageArchive) */ {
 public:
  inline CommentStorageArchive() : CommentStorageArchive(nullptr) {}
  ~CommentStorageArchive() override;
  explicit constexpr CommentStorageArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommentStorageArchive(const CommentStorageArchive& from);
  CommentStorageArchive(CommentStorageArchive&& from) noexcept
    : CommentStorageArchive() {
    *this = ::std::move(from);
  }

  inline CommentStorageArchive& operator=(const CommentStorageArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommentStorageArchive& operator=(CommentStorageArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommentStorageArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommentStorageArchive* internal_default_instance() {
    return reinterpret_cast<const CommentStorageArchive*>(
               &_CommentStorageArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(CommentStorageArchive& a, CommentStorageArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CommentStorageArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommentStorageArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommentStorageArchive* New() const final {
    return CreateMaybeMessage<CommentStorageArchive>(nullptr);
  }

  CommentStorageArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommentStorageArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommentStorageArchive& from);
  void MergeFrom(const CommentStorageArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommentStorageArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.CommentStorageArchive";
  }
  protected:
  explicit CommentStorageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepliesFieldNumber = 4,
    kTextFieldNumber = 1,
    kCreationDateFieldNumber = 2,
    kAuthorFieldNumber = 3,
  };
  // repeated .TSP.Reference replies = 4;
  int replies_size() const;
  private:
  int _internal_replies_size() const;
  public:
  void clear_replies();
  ::TSP::Reference* mutable_replies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_replies();
  private:
  const ::TSP::Reference& _internal_replies(int index) const;
  ::TSP::Reference* _internal_add_replies();
  public:
  const ::TSP::Reference& replies(int index) const;
  ::TSP::Reference* add_replies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      replies() const;

  // optional string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional .TSP.Date creation_date = 2;
  bool has_creation_date() const;
  private:
  bool _internal_has_creation_date() const;
  public:
  void clear_creation_date();
  const ::TSP::Date& creation_date() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Date* release_creation_date();
  ::TSP::Date* mutable_creation_date();
  void set_allocated_creation_date(::TSP::Date* creation_date);
  private:
  const ::TSP::Date& _internal_creation_date() const;
  ::TSP::Date* _internal_mutable_creation_date();
  public:
  void unsafe_arena_set_allocated_creation_date(
      ::TSP::Date* creation_date);
  ::TSP::Date* unsafe_arena_release_creation_date();

  // optional .TSP.Reference author = 3;
  bool has_author() const;
  private:
  bool _internal_has_author() const;
  public:
  void clear_author();
  const ::TSP::Reference& author() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_author();
  ::TSP::Reference* mutable_author();
  void set_allocated_author(::TSP::Reference* author);
  private:
  const ::TSP::Reference& _internal_author() const;
  ::TSP::Reference* _internal_mutable_author();
  public:
  void unsafe_arena_set_allocated_author(
      ::TSP::Reference* author);
  ::TSP::Reference* unsafe_arena_release_author();

  // @@protoc_insertion_point(class_scope:TSD.CommentStorageArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > replies_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::TSP::Date* creation_date_;
  ::TSP::Reference* author_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ReplaceAnnotationAuthorCommandArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ReplaceAnnotationAuthorCommandArchive) */ {
 public:
  inline ReplaceAnnotationAuthorCommandArchive() : ReplaceAnnotationAuthorCommandArchive(nullptr) {}
  ~ReplaceAnnotationAuthorCommandArchive() override;
  explicit constexpr ReplaceAnnotationAuthorCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplaceAnnotationAuthorCommandArchive(const ReplaceAnnotationAuthorCommandArchive& from);
  ReplaceAnnotationAuthorCommandArchive(ReplaceAnnotationAuthorCommandArchive&& from) noexcept
    : ReplaceAnnotationAuthorCommandArchive() {
    *this = ::std::move(from);
  }

  inline ReplaceAnnotationAuthorCommandArchive& operator=(const ReplaceAnnotationAuthorCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplaceAnnotationAuthorCommandArchive& operator=(ReplaceAnnotationAuthorCommandArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplaceAnnotationAuthorCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplaceAnnotationAuthorCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ReplaceAnnotationAuthorCommandArchive*>(
               &_ReplaceAnnotationAuthorCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(ReplaceAnnotationAuthorCommandArchive& a, ReplaceAnnotationAuthorCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplaceAnnotationAuthorCommandArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplaceAnnotationAuthorCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReplaceAnnotationAuthorCommandArchive* New() const final {
    return CreateMaybeMessage<ReplaceAnnotationAuthorCommandArchive>(nullptr);
  }

  ReplaceAnnotationAuthorCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReplaceAnnotationAuthorCommandArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReplaceAnnotationAuthorCommandArchive& from);
  void MergeFrom(const ReplaceAnnotationAuthorCommandArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplaceAnnotationAuthorCommandArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ReplaceAnnotationAuthorCommandArchive";
  }
  protected:
  explicit ReplaceAnnotationAuthorCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kOldAnnotationAuthorFieldNumber = 2,
    kNewAnnotationAuthorFieldNumber = 3,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference old_annotation_author = 2;
  bool has_old_annotation_author() const;
  private:
  bool _internal_has_old_annotation_author() const;
  public:
  void clear_old_annotation_author();
  const ::TSP::Reference& old_annotation_author() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_old_annotation_author();
  ::TSP::Reference* mutable_old_annotation_author();
  void set_allocated_old_annotation_author(::TSP::Reference* old_annotation_author);
  private:
  const ::TSP::Reference& _internal_old_annotation_author() const;
  ::TSP::Reference* _internal_mutable_old_annotation_author();
  public:
  void unsafe_arena_set_allocated_old_annotation_author(
      ::TSP::Reference* old_annotation_author);
  ::TSP::Reference* unsafe_arena_release_old_annotation_author();

  // optional .TSP.Reference new_annotation_author = 3;
  bool has_new_annotation_author() const;
  private:
  bool _internal_has_new_annotation_author() const;
  public:
  void clear_new_annotation_author();
  const ::TSP::Reference& new_annotation_author() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_new_annotation_author();
  ::TSP::Reference* mutable_new_annotation_author();
  void set_allocated_new_annotation_author(::TSP::Reference* new_annotation_author);
  private:
  const ::TSP::Reference& _internal_new_annotation_author() const;
  ::TSP::Reference* _internal_mutable_new_annotation_author();
  public:
  void unsafe_arena_set_allocated_new_annotation_author(
      ::TSP::Reference* new_annotation_author);
  ::TSP::Reference* unsafe_arena_release_new_annotation_author();

  // @@protoc_insertion_point(class_scope:TSD.ReplaceAnnotationAuthorCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSK::CommandArchive* super_;
  ::TSP::Reference* old_annotation_author_;
  ::TSP::Reference* new_annotation_author_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class PencilAnnotationArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.PencilAnnotationArchive) */ {
 public:
  inline PencilAnnotationArchive() : PencilAnnotationArchive(nullptr) {}
  ~PencilAnnotationArchive() override;
  explicit constexpr PencilAnnotationArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PencilAnnotationArchive(const PencilAnnotationArchive& from);
  PencilAnnotationArchive(PencilAnnotationArchive&& from) noexcept
    : PencilAnnotationArchive() {
    *this = ::std::move(from);
  }

  inline PencilAnnotationArchive& operator=(const PencilAnnotationArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PencilAnnotationArchive& operator=(PencilAnnotationArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PencilAnnotationArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PencilAnnotationArchive* internal_default_instance() {
    return reinterpret_cast<const PencilAnnotationArchive*>(
               &_PencilAnnotationArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(PencilAnnotationArchive& a, PencilAnnotationArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PencilAnnotationArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PencilAnnotationArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PencilAnnotationArchive* New() const final {
    return CreateMaybeMessage<PencilAnnotationArchive>(nullptr);
  }

  PencilAnnotationArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PencilAnnotationArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PencilAnnotationArchive& from);
  void MergeFrom(const PencilAnnotationArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PencilAnnotationArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.PencilAnnotationArchive";
  }
  protected:
  explicit PencilAnnotationArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPencilAnnotationStorageFieldNumber = 1,
  };
  // optional .TSP.Reference pencil_annotation_storage = 1;
  bool has_pencil_annotation_storage() const;
  private:
  bool _internal_has_pencil_annotation_storage() const;
  public:
  void clear_pencil_annotation_storage();
  const ::TSP::Reference& pencil_annotation_storage() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_pencil_annotation_storage();
  ::TSP::Reference* mutable_pencil_annotation_storage();
  void set_allocated_pencil_annotation_storage(::TSP::Reference* pencil_annotation_storage);
  private:
  const ::TSP::Reference& _internal_pencil_annotation_storage() const;
  ::TSP::Reference* _internal_mutable_pencil_annotation_storage();
  public:
  void unsafe_arena_set_allocated_pencil_annotation_storage(
      ::TSP::Reference* pencil_annotation_storage);
  ::TSP::Reference* unsafe_arena_release_pencil_annotation_storage();

  // @@protoc_insertion_point(class_scope:TSD.PencilAnnotationArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Reference* pencil_annotation_storage_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class PencilAnnotationSelectionArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.PencilAnnotationSelectionArchive) */ {
 public:
  inline PencilAnnotationSelectionArchive() : PencilAnnotationSelectionArchive(nullptr) {}
  ~PencilAnnotationSelectionArchive() override;
  explicit constexpr PencilAnnotationSelectionArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PencilAnnotationSelectionArchive(const PencilAnnotationSelectionArchive& from);
  PencilAnnotationSelectionArchive(PencilAnnotationSelectionArchive&& from) noexcept
    : PencilAnnotationSelectionArchive() {
    *this = ::std::move(from);
  }

  inline PencilAnnotationSelectionArchive& operator=(const PencilAnnotationSelectionArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PencilAnnotationSelectionArchive& operator=(PencilAnnotationSelectionArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PencilAnnotationSelectionArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PencilAnnotationSelectionArchive* internal_default_instance() {
    return reinterpret_cast<const PencilAnnotationSelectionArchive*>(
               &_PencilAnnotationSelectionArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(PencilAnnotationSelectionArchive& a, PencilAnnotationSelectionArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PencilAnnotationSelectionArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PencilAnnotationSelectionArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PencilAnnotationSelectionArchive* New() const final {
    return CreateMaybeMessage<PencilAnnotationSelectionArchive>(nullptr);
  }

  PencilAnnotationSelectionArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PencilAnnotationSelectionArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PencilAnnotationSelectionArchive& from);
  void MergeFrom(const PencilAnnotationSelectionArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PencilAnnotationSelectionArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.PencilAnnotationSelectionArchive";
  }
  protected:
  explicit PencilAnnotationSelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPencilAnnotationFieldNumber = 1,
  };
  // optional .TSP.Reference pencil_annotation = 1;
  bool has_pencil_annotation() const;
  private:
  bool _internal_has_pencil_annotation() const;
  public:
  void clear_pencil_annotation();
  const ::TSP::Reference& pencil_annotation() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Reference* release_pencil_annotation();
  ::TSP::Reference* mutable_pencil_annotation();
  void set_allocated_pencil_annotation(::TSP::Reference* pencil_annotation);
  private:
  const ::TSP::Reference& _internal_pencil_annotation() const;
  ::TSP::Reference* _internal_mutable_pencil_annotation();
  public:
  void unsafe_arena_set_allocated_pencil_annotation(
      ::TSP::Reference* pencil_annotation);
  ::TSP::Reference* unsafe_arena_release_pencil_annotation();

  // @@protoc_insertion_point(class_scope:TSD.PencilAnnotationSelectionArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Reference* pencil_annotation_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class PencilAnnotationStorageArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.PencilAnnotationStorageArchive) */ {
 public:
  inline PencilAnnotationStorageArchive() : PencilAnnotationStorageArchive(nullptr) {}
  ~PencilAnnotationStorageArchive() override;
  explicit constexpr PencilAnnotationStorageArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PencilAnnotationStorageArchive(const PencilAnnotationStorageArchive& from);
  PencilAnnotationStorageArchive(PencilAnnotationStorageArchive&& from) noexcept
    : PencilAnnotationStorageArchive() {
    *this = ::std::move(from);
  }

  inline PencilAnnotationStorageArchive& operator=(const PencilAnnotationStorageArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PencilAnnotationStorageArchive& operator=(PencilAnnotationStorageArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PencilAnnotationStorageArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PencilAnnotationStorageArchive* internal_default_instance() {
    return reinterpret_cast<const PencilAnnotationStorageArchive*>(
               &_PencilAnnotationStorageArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(PencilAnnotationStorageArchive& a, PencilAnnotationStorageArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PencilAnnotationStorageArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PencilAnnotationStorageArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PencilAnnotationStorageArchive* New() const final {
    return CreateMaybeMessage<PencilAnnotationStorageArchive>(nullptr);
  }

  PencilAnnotationStorageArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PencilAnnotationStorageArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PencilAnnotationStorageArchive& from);
  void MergeFrom(const PencilAnnotationStorageArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PencilAnnotationStorageArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.PencilAnnotationStorageArchive";
  }
  protected:
  explicit PencilAnnotationStorageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCalloutSubStoragesFieldNumber = 15,
    kSubStoragesFieldNumber = 19,
    kMarkupOffsetFieldNumber = 2,
    kRasterizedImageFieldNumber = 3,
    kLegacyEncodedDrawingFieldNumber = 4,
    kDrawingPathFieldNumber = 5,
    kStrokesBoundingBoxOriginFieldNumber = 6,
    kStrokesBoundingBoxSizeFieldNumber = 7,
    kOriginalAttachedSizeFieldNumber = 9,
    kPenColorFieldNumber = 13,
    kCreationDateFieldNumber = 16,
    kEncodedDrawingFieldNumber = 20,
    kStrokePointsFrameOriginFieldNumber = 21,
    kStrokePointsFrameSizeFieldNumber = 22,
    kRenderedFrameOriginFieldNumber = 23,
    kRenderedFrameSizeFieldNumber = 24,
    kAttachedLocationFieldNumber = 1,
    kAttachedTypeFieldNumber = 8,
    kPercentOfPaContainedInParentRepFieldNumber = 10,
    kTextBaselinesTouchedCountFieldNumber = 11,
    kVisibleStrokesCountFieldNumber = 12,
    kToolTypeFieldNumber = 14,
    kCompoundAnnotationTypeFieldNumber = 18,
    kPencilAnnotationDrawingScaleFieldNumber = 17,
  };
  // repeated .TSP.Reference callout_sub_storages = 15;
  int callout_sub_storages_size() const;
  private:
  int _internal_callout_sub_storages_size() const;
  public:
  void clear_callout_sub_storages();
  ::TSP::Reference* mutable_callout_sub_storages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_callout_sub_storages();
  private:
  const ::TSP::Reference& _internal_callout_sub_storages(int index) const;
  ::TSP::Reference* _internal_add_callout_sub_storages();
  public:
  const ::TSP::Reference& callout_sub_storages(int index) const;
  ::TSP::Reference* add_callout_sub_storages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      callout_sub_storages() const;

  // repeated .TSP.Reference sub_storages = 19;
  int sub_storages_size() const;
  private:
  int _internal_sub_storages_size() const;
  public:
  void clear_sub_storages();
  ::TSP::Reference* mutable_sub_storages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_sub_storages();
  private:
  const ::TSP::Reference& _internal_sub_storages(int index) const;
  ::TSP::Reference* _internal_add_sub_storages();
  public:
  const ::TSP::Reference& sub_storages(int index) const;
  ::TSP::Reference* add_sub_storages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      sub_storages() const;

  // optional .TSP.Point markup_offset = 2;
  bool has_markup_offset() const;
  private:
  bool _internal_has_markup_offset() const;
  public:
  void clear_markup_offset();
  const ::TSP::Point& markup_offset() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Point* release_markup_offset();
  ::TSP::Point* mutable_markup_offset();
  void set_allocated_markup_offset(::TSP::Point* markup_offset);
  private:
  const ::TSP::Point& _internal_markup_offset() const;
  ::TSP::Point* _internal_mutable_markup_offset();
  public:
  void unsafe_arena_set_allocated_markup_offset(
      ::TSP::Point* markup_offset);
  ::TSP::Point* unsafe_arena_release_markup_offset();

  // optional .TSP.DataReference rasterized_image = 3;
  bool has_rasterized_image() const;
  private:
  bool _internal_has_rasterized_image() const;
  public:
  void clear_rasterized_image();
  const ::TSP::DataReference& rasterized_image() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::DataReference* release_rasterized_image();
  ::TSP::DataReference* mutable_rasterized_image();
  void set_allocated_rasterized_image(::TSP::DataReference* rasterized_image);
  private:
  const ::TSP::DataReference& _internal_rasterized_image() const;
  ::TSP::DataReference* _internal_mutable_rasterized_image();
  public:
  void unsafe_arena_set_allocated_rasterized_image(
      ::TSP::DataReference* rasterized_image);
  ::TSP::DataReference* unsafe_arena_release_rasterized_image();

  // optional .TSP.DataReference legacy_encoded_drawing = 4;
  bool has_legacy_encoded_drawing() const;
  private:
  bool _internal_has_legacy_encoded_drawing() const;
  public:
  void clear_legacy_encoded_drawing();
  const ::TSP::DataReference& legacy_encoded_drawing() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::DataReference* release_legacy_encoded_drawing();
  ::TSP::DataReference* mutable_legacy_encoded_drawing();
  void set_allocated_legacy_encoded_drawing(::TSP::DataReference* legacy_encoded_drawing);
  private:
  const ::TSP::DataReference& _internal_legacy_encoded_drawing() const;
  ::TSP::DataReference* _internal_mutable_legacy_encoded_drawing();
  public:
  void unsafe_arena_set_allocated_legacy_encoded_drawing(
      ::TSP::DataReference* legacy_encoded_drawing);
  ::TSP::DataReference* unsafe_arena_release_legacy_encoded_drawing();

  // optional .TSP.Path drawing_path = 5;
  bool has_drawing_path() const;
  private:
  bool _internal_has_drawing_path() const;
  public:
  void clear_drawing_path();
  const ::TSP::Path& drawing_path() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Path* release_drawing_path();
  ::TSP::Path* mutable_drawing_path();
  void set_allocated_drawing_path(::TSP::Path* drawing_path);
  private:
  const ::TSP::Path& _internal_drawing_path() const;
  ::TSP::Path* _internal_mutable_drawing_path();
  public:
  void unsafe_arena_set_allocated_drawing_path(
      ::TSP::Path* drawing_path);
  ::TSP::Path* unsafe_arena_release_drawing_path();

  // optional .TSP.Point strokes_bounding_box_origin = 6;
  bool has_strokes_bounding_box_origin() const;
  private:
  bool _internal_has_strokes_bounding_box_origin() const;
  public:
  void clear_strokes_bounding_box_origin();
  const ::TSP::Point& strokes_bounding_box_origin() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Point* release_strokes_bounding_box_origin();
  ::TSP::Point* mutable_strokes_bounding_box_origin();
  void set_allocated_strokes_bounding_box_origin(::TSP::Point* strokes_bounding_box_origin);
  private:
  const ::TSP::Point& _internal_strokes_bounding_box_origin() const;
  ::TSP::Point* _internal_mutable_strokes_bounding_box_origin();
  public:
  void unsafe_arena_set_allocated_strokes_bounding_box_origin(
      ::TSP::Point* strokes_bounding_box_origin);
  ::TSP::Point* unsafe_arena_release_strokes_bounding_box_origin();

  // optional .TSP.Size strokes_bounding_box_size = 7;
  bool has_strokes_bounding_box_size() const;
  private:
  bool _internal_has_strokes_bounding_box_size() const;
  public:
  void clear_strokes_bounding_box_size();
  const ::TSP::Size& strokes_bounding_box_size() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_strokes_bounding_box_size();
  ::TSP::Size* mutable_strokes_bounding_box_size();
  void set_allocated_strokes_bounding_box_size(::TSP::Size* strokes_bounding_box_size);
  private:
  const ::TSP::Size& _internal_strokes_bounding_box_size() const;
  ::TSP::Size* _internal_mutable_strokes_bounding_box_size();
  public:
  void unsafe_arena_set_allocated_strokes_bounding_box_size(
      ::TSP::Size* strokes_bounding_box_size);
  ::TSP::Size* unsafe_arena_release_strokes_bounding_box_size();

  // optional .TSP.Size original_attached_size = 9;
  bool has_original_attached_size() const;
  private:
  bool _internal_has_original_attached_size() const;
  public:
  void clear_original_attached_size();
  const ::TSP::Size& original_attached_size() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_original_attached_size();
  ::TSP::Size* mutable_original_attached_size();
  void set_allocated_original_attached_size(::TSP::Size* original_attached_size);
  private:
  const ::TSP::Size& _internal_original_attached_size() const;
  ::TSP::Size* _internal_mutable_original_attached_size();
  public:
  void unsafe_arena_set_allocated_original_attached_size(
      ::TSP::Size* original_attached_size);
  ::TSP::Size* unsafe_arena_release_original_attached_size();

  // optional .TSP.Color pen_color = 13;
  bool has_pen_color() const;
  private:
  bool _internal_has_pen_color() const;
  public:
  void clear_pen_color();
  const ::TSP::Color& pen_color() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_pen_color();
  ::TSP::Color* mutable_pen_color();
  void set_allocated_pen_color(::TSP::Color* pen_color);
  private:
  const ::TSP::Color& _internal_pen_color() const;
  ::TSP::Color* _internal_mutable_pen_color();
  public:
  void unsafe_arena_set_allocated_pen_color(
      ::TSP::Color* pen_color);
  ::TSP::Color* unsafe_arena_release_pen_color();

  // optional .TSP.Date creation_date = 16;
  bool has_creation_date() const;
  private:
  bool _internal_has_creation_date() const;
  public:
  void clear_creation_date();
  const ::TSP::Date& creation_date() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Date* release_creation_date();
  ::TSP::Date* mutable_creation_date();
  void set_allocated_creation_date(::TSP::Date* creation_date);
  private:
  const ::TSP::Date& _internal_creation_date() const;
  ::TSP::Date* _internal_mutable_creation_date();
  public:
  void unsafe_arena_set_allocated_creation_date(
      ::TSP::Date* creation_date);
  ::TSP::Date* unsafe_arena_release_creation_date();

  // optional .TSP.DataReference encoded_drawing = 20;
  bool has_encoded_drawing() const;
  private:
  bool _internal_has_encoded_drawing() const;
  public:
  void clear_encoded_drawing();
  const ::TSP::DataReference& encoded_drawing() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::DataReference* release_encoded_drawing();
  ::TSP::DataReference* mutable_encoded_drawing();
  void set_allocated_encoded_drawing(::TSP::DataReference* encoded_drawing);
  private:
  const ::TSP::DataReference& _internal_encoded_drawing() const;
  ::TSP::DataReference* _internal_mutable_encoded_drawing();
  public:
  void unsafe_arena_set_allocated_encoded_drawing(
      ::TSP::DataReference* encoded_drawing);
  ::TSP::DataReference* unsafe_arena_release_encoded_drawing();

  // optional .TSP.Point stroke_points_frame_origin = 21;
  bool has_stroke_points_frame_origin() const;
  private:
  bool _internal_has_stroke_points_frame_origin() const;
  public:
  void clear_stroke_points_frame_origin();
  const ::TSP::Point& stroke_points_frame_origin() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Point* release_stroke_points_frame_origin();
  ::TSP::Point* mutable_stroke_points_frame_origin();
  void set_allocated_stroke_points_frame_origin(::TSP::Point* stroke_points_frame_origin);
  private:
  const ::TSP::Point& _internal_stroke_points_frame_origin() const;
  ::TSP::Point* _internal_mutable_stroke_points_frame_origin();
  public:
  void unsafe_arena_set_allocated_stroke_points_frame_origin(
      ::TSP::Point* stroke_points_frame_origin);
  ::TSP::Point* unsafe_arena_release_stroke_points_frame_origin();

  // optional .TSP.Size stroke_points_frame_size = 22;
  bool has_stroke_points_frame_size() const;
  private:
  bool _internal_has_stroke_points_frame_size() const;
  public:
  void clear_stroke_points_frame_size();
  const ::TSP::Size& stroke_points_frame_size() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_stroke_points_frame_size();
  ::TSP::Size* mutable_stroke_points_frame_size();
  void set_allocated_stroke_points_frame_size(::TSP::Size* stroke_points_frame_size);
  private:
  const ::TSP::Size& _internal_stroke_points_frame_size() const;
  ::TSP::Size* _internal_mutable_stroke_points_frame_size();
  public:
  void unsafe_arena_set_allocated_stroke_points_frame_size(
      ::TSP::Size* stroke_points_frame_size);
  ::TSP::Size* unsafe_arena_release_stroke_points_frame_size();

  // optional .TSP.Point rendered_frame_origin = 23;
  bool has_rendered_frame_origin() const;
  private:
  bool _internal_has_rendered_frame_origin() const;
  public:
  void clear_rendered_frame_origin();
  const ::TSP::Point& rendered_frame_origin() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Point* release_rendered_frame_origin();
  ::TSP::Point* mutable_rendered_frame_origin();
  void set_allocated_rendered_frame_origin(::TSP::Point* rendered_frame_origin);
  private:
  const ::TSP::Point& _internal_rendered_frame_origin() const;
  ::TSP::Point* _internal_mutable_rendered_frame_origin();
  public:
  void unsafe_arena_set_allocated_rendered_frame_origin(
      ::TSP::Point* rendered_frame_origin);
  ::TSP::Point* unsafe_arena_release_rendered_frame_origin();

  // optional .TSP.Size rendered_frame_size = 24;
  bool has_rendered_frame_size() const;
  private:
  bool _internal_has_rendered_frame_size() const;
  public:
  void clear_rendered_frame_size();
  const ::TSP::Size& rendered_frame_size() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_rendered_frame_size();
  ::TSP::Size* mutable_rendered_frame_size();
  void set_allocated_rendered_frame_size(::TSP::Size* rendered_frame_size);
  private:
  const ::TSP::Size& _internal_rendered_frame_size() const;
  ::TSP::Size* _internal_mutable_rendered_frame_size();
  public:
  void unsafe_arena_set_allocated_rendered_frame_size(
      ::TSP::Size* rendered_frame_size);
  ::TSP::Size* unsafe_arena_release_rendered_frame_size();

  // optional int32 attached_location = 1;
  bool has_attached_location() const;
  private:
  bool _internal_has_attached_location() const;
  public:
  void clear_attached_location();
  ::PROTOBUF_NAMESPACE_ID::int32 attached_location() const;
  void set_attached_location(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attached_location() const;
  void _internal_set_attached_location(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 attached_type = 8;
  bool has_attached_type() const;
  private:
  bool _internal_has_attached_type() const;
  public:
  void clear_attached_type();
  ::PROTOBUF_NAMESPACE_ID::int32 attached_type() const;
  void set_attached_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attached_type() const;
  void _internal_set_attached_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double percent_of_pa_contained_in_parent_rep = 10;
  bool has_percent_of_pa_contained_in_parent_rep() const;
  private:
  bool _internal_has_percent_of_pa_contained_in_parent_rep() const;
  public:
  void clear_percent_of_pa_contained_in_parent_rep();
  double percent_of_pa_contained_in_parent_rep() const;
  void set_percent_of_pa_contained_in_parent_rep(double value);
  private:
  double _internal_percent_of_pa_contained_in_parent_rep() const;
  void _internal_set_percent_of_pa_contained_in_parent_rep(double value);
  public:

  // optional uint64 text_baselines_touched_count = 11;
  bool has_text_baselines_touched_count() const;
  private:
  bool _internal_has_text_baselines_touched_count() const;
  public:
  void clear_text_baselines_touched_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 text_baselines_touched_count() const;
  void set_text_baselines_touched_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_text_baselines_touched_count() const;
  void _internal_set_text_baselines_touched_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 visible_strokes_count = 12;
  bool has_visible_strokes_count() const;
  private:
  bool _internal_has_visible_strokes_count() const;
  public:
  void clear_visible_strokes_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 visible_strokes_count() const;
  void set_visible_strokes_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_visible_strokes_count() const;
  void _internal_set_visible_strokes_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int32 tool_type = 14;
  bool has_tool_type() const;
  private:
  bool _internal_has_tool_type() const;
  public:
  void clear_tool_type();
  ::PROTOBUF_NAMESPACE_ID::int32 tool_type() const;
  void set_tool_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tool_type() const;
  void _internal_set_tool_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 compound_annotation_type = 18;
  bool has_compound_annotation_type() const;
  private:
  bool _internal_has_compound_annotation_type() const;
  public:
  void clear_compound_annotation_type();
  ::PROTOBUF_NAMESPACE_ID::int32 compound_annotation_type() const;
  void set_compound_annotation_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_compound_annotation_type() const;
  void _internal_set_compound_annotation_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double pencil_annotation_drawing_scale = 17;
  bool has_pencil_annotation_drawing_scale() const;
  private:
  bool _internal_has_pencil_annotation_drawing_scale() const;
  public:
  void clear_pencil_annotation_drawing_scale();
  double pencil_annotation_drawing_scale() const;
  void set_pencil_annotation_drawing_scale(double value);
  private:
  double _internal_pencil_annotation_drawing_scale() const;
  void _internal_set_pencil_annotation_drawing_scale(double value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.PencilAnnotationStorageArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > callout_sub_storages_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > sub_storages_;
  ::TSP::Point* markup_offset_;
  ::TSP::DataReference* rasterized_image_;
  ::TSP::DataReference* legacy_encoded_drawing_;
  ::TSP::Path* drawing_path_;
  ::TSP::Point* strokes_bounding_box_origin_;
  ::TSP::Size* strokes_bounding_box_size_;
  ::TSP::Size* original_attached_size_;
  ::TSP::Color* pen_color_;
  ::TSP::Date* creation_date_;
  ::TSP::DataReference* encoded_drawing_;
  ::TSP::Point* stroke_points_frame_origin_;
  ::TSP::Size* stroke_points_frame_size_;
  ::TSP::Point* rendered_frame_origin_;
  ::TSP::Size* rendered_frame_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 attached_location_;
  ::PROTOBUF_NAMESPACE_ID::int32 attached_type_;
  double percent_of_pa_contained_in_parent_rep_;
  ::PROTOBUF_NAMESPACE_ID::uint64 text_baselines_touched_count_;
  ::PROTOBUF_NAMESPACE_ID::uint64 visible_strokes_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 tool_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 compound_annotation_type_;
  double pencil_annotation_drawing_scale_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SpecColorFillSetColorArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SpecColorFillSetColorArchive) */ {
 public:
  inline SpecColorFillSetColorArchive() : SpecColorFillSetColorArchive(nullptr) {}
  ~SpecColorFillSetColorArchive() override;
  explicit constexpr SpecColorFillSetColorArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecColorFillSetColorArchive(const SpecColorFillSetColorArchive& from);
  SpecColorFillSetColorArchive(SpecColorFillSetColorArchive&& from) noexcept
    : SpecColorFillSetColorArchive() {
    *this = ::std::move(from);
  }

  inline SpecColorFillSetColorArchive& operator=(const SpecColorFillSetColorArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecColorFillSetColorArchive& operator=(SpecColorFillSetColorArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecColorFillSetColorArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecColorFillSetColorArchive* internal_default_instance() {
    return reinterpret_cast<const SpecColorFillSetColorArchive*>(
               &_SpecColorFillSetColorArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(SpecColorFillSetColorArchive& a, SpecColorFillSetColorArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecColorFillSetColorArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecColorFillSetColorArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecColorFillSetColorArchive* New() const final {
    return CreateMaybeMessage<SpecColorFillSetColorArchive>(nullptr);
  }

  SpecColorFillSetColorArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecColorFillSetColorArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpecColorFillSetColorArchive& from);
  void MergeFrom(const SpecColorFillSetColorArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecColorFillSetColorArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SpecColorFillSetColorArchive";
  }
  protected:
  explicit SpecColorFillSetColorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
  };
  // required .TSP.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::TSP::Color& color() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_color();
  ::TSP::Color* mutable_color();
  void set_allocated_color(::TSP::Color* color);
  private:
  const ::TSP::Color& _internal_color() const;
  ::TSP::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::TSP::Color* color);
  ::TSP::Color* unsafe_arena_release_color();

  // @@protoc_insertion_point(class_scope:TSD.SpecColorFillSetColorArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Color* color_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SpecFrameSetAssetScaleArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SpecFrameSetAssetScaleArchive) */ {
 public:
  inline SpecFrameSetAssetScaleArchive() : SpecFrameSetAssetScaleArchive(nullptr) {}
  ~SpecFrameSetAssetScaleArchive() override;
  explicit constexpr SpecFrameSetAssetScaleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecFrameSetAssetScaleArchive(const SpecFrameSetAssetScaleArchive& from);
  SpecFrameSetAssetScaleArchive(SpecFrameSetAssetScaleArchive&& from) noexcept
    : SpecFrameSetAssetScaleArchive() {
    *this = ::std::move(from);
  }

  inline SpecFrameSetAssetScaleArchive& operator=(const SpecFrameSetAssetScaleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecFrameSetAssetScaleArchive& operator=(SpecFrameSetAssetScaleArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecFrameSetAssetScaleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecFrameSetAssetScaleArchive* internal_default_instance() {
    return reinterpret_cast<const SpecFrameSetAssetScaleArchive*>(
               &_SpecFrameSetAssetScaleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(SpecFrameSetAssetScaleArchive& a, SpecFrameSetAssetScaleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecFrameSetAssetScaleArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecFrameSetAssetScaleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecFrameSetAssetScaleArchive* New() const final {
    return CreateMaybeMessage<SpecFrameSetAssetScaleArchive>(nullptr);
  }

  SpecFrameSetAssetScaleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecFrameSetAssetScaleArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpecFrameSetAssetScaleArchive& from);
  void MergeFrom(const SpecFrameSetAssetScaleArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecFrameSetAssetScaleArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SpecFrameSetAssetScaleArchive";
  }
  protected:
  explicit SpecFrameSetAssetScaleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetScaleFieldNumber = 1,
  };
  // required double asset_scale = 1;
  bool has_asset_scale() const;
  private:
  bool _internal_has_asset_scale() const;
  public:
  void clear_asset_scale();
  double asset_scale() const;
  void set_asset_scale(double value);
  private:
  double _internal_asset_scale() const;
  void _internal_set_asset_scale(double value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.SpecFrameSetAssetScaleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double asset_scale_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SpecGradientFillSetAngleArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SpecGradientFillSetAngleArchive) */ {
 public:
  inline SpecGradientFillSetAngleArchive() : SpecGradientFillSetAngleArchive(nullptr) {}
  ~SpecGradientFillSetAngleArchive() override;
  explicit constexpr SpecGradientFillSetAngleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecGradientFillSetAngleArchive(const SpecGradientFillSetAngleArchive& from);
  SpecGradientFillSetAngleArchive(SpecGradientFillSetAngleArchive&& from) noexcept
    : SpecGradientFillSetAngleArchive() {
    *this = ::std::move(from);
  }

  inline SpecGradientFillSetAngleArchive& operator=(const SpecGradientFillSetAngleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecGradientFillSetAngleArchive& operator=(SpecGradientFillSetAngleArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecGradientFillSetAngleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecGradientFillSetAngleArchive* internal_default_instance() {
    return reinterpret_cast<const SpecGradientFillSetAngleArchive*>(
               &_SpecGradientFillSetAngleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(SpecGradientFillSetAngleArchive& a, SpecGradientFillSetAngleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecGradientFillSetAngleArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecGradientFillSetAngleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecGradientFillSetAngleArchive* New() const final {
    return CreateMaybeMessage<SpecGradientFillSetAngleArchive>(nullptr);
  }

  SpecGradientFillSetAngleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecGradientFillSetAngleArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpecGradientFillSetAngleArchive& from);
  void MergeFrom(const SpecGradientFillSetAngleArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecGradientFillSetAngleArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SpecGradientFillSetAngleArchive";
  }
  protected:
  explicit SpecGradientFillSetAngleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAngleFieldNumber = 1,
  };
  // required double angle = 1;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  double angle() const;
  void set_angle(double value);
  private:
  double _internal_angle() const;
  void _internal_set_angle(double value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.SpecGradientFillSetAngleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double angle_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SpecImageFillSetTechniqueArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SpecImageFillSetTechniqueArchive) */ {
 public:
  inline SpecImageFillSetTechniqueArchive() : SpecImageFillSetTechniqueArchive(nullptr) {}
  ~SpecImageFillSetTechniqueArchive() override;
  explicit constexpr SpecImageFillSetTechniqueArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecImageFillSetTechniqueArchive(const SpecImageFillSetTechniqueArchive& from);
  SpecImageFillSetTechniqueArchive(SpecImageFillSetTechniqueArchive&& from) noexcept
    : SpecImageFillSetTechniqueArchive() {
    *this = ::std::move(from);
  }

  inline SpecImageFillSetTechniqueArchive& operator=(const SpecImageFillSetTechniqueArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecImageFillSetTechniqueArchive& operator=(SpecImageFillSetTechniqueArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecImageFillSetTechniqueArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecImageFillSetTechniqueArchive* internal_default_instance() {
    return reinterpret_cast<const SpecImageFillSetTechniqueArchive*>(
               &_SpecImageFillSetTechniqueArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(SpecImageFillSetTechniqueArchive& a, SpecImageFillSetTechniqueArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecImageFillSetTechniqueArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecImageFillSetTechniqueArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecImageFillSetTechniqueArchive* New() const final {
    return CreateMaybeMessage<SpecImageFillSetTechniqueArchive>(nullptr);
  }

  SpecImageFillSetTechniqueArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecImageFillSetTechniqueArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpecImageFillSetTechniqueArchive& from);
  void MergeFrom(const SpecImageFillSetTechniqueArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecImageFillSetTechniqueArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SpecImageFillSetTechniqueArchive";
  }
  protected:
  explicit SpecImageFillSetTechniqueArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTechniqueFieldNumber = 1,
  };
  // required int32 technique = 1;
  bool has_technique() const;
  private:
  bool _internal_has_technique() const;
  public:
  void clear_technique();
  ::PROTOBUF_NAMESPACE_ID::int32 technique() const;
  void set_technique(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_technique() const;
  void _internal_set_technique(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.SpecImageFillSetTechniqueArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 technique_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SpecReflectionSetOpacityArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SpecReflectionSetOpacityArchive) */ {
 public:
  inline SpecReflectionSetOpacityArchive() : SpecReflectionSetOpacityArchive(nullptr) {}
  ~SpecReflectionSetOpacityArchive() override;
  explicit constexpr SpecReflectionSetOpacityArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecReflectionSetOpacityArchive(const SpecReflectionSetOpacityArchive& from);
  SpecReflectionSetOpacityArchive(SpecReflectionSetOpacityArchive&& from) noexcept
    : SpecReflectionSetOpacityArchive() {
    *this = ::std::move(from);
  }

  inline SpecReflectionSetOpacityArchive& operator=(const SpecReflectionSetOpacityArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecReflectionSetOpacityArchive& operator=(SpecReflectionSetOpacityArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecReflectionSetOpacityArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecReflectionSetOpacityArchive* internal_default_instance() {
    return reinterpret_cast<const SpecReflectionSetOpacityArchive*>(
               &_SpecReflectionSetOpacityArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(SpecReflectionSetOpacityArchive& a, SpecReflectionSetOpacityArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecReflectionSetOpacityArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecReflectionSetOpacityArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecReflectionSetOpacityArchive* New() const final {
    return CreateMaybeMessage<SpecReflectionSetOpacityArchive>(nullptr);
  }

  SpecReflectionSetOpacityArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecReflectionSetOpacityArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpecReflectionSetOpacityArchive& from);
  void MergeFrom(const SpecReflectionSetOpacityArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecReflectionSetOpacityArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SpecReflectionSetOpacityArchive";
  }
  protected:
  explicit SpecReflectionSetOpacityArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpacityFieldNumber = 1,
  };
  // required double opacity = 1;
  bool has_opacity() const;
  private:
  bool _internal_has_opacity() const;
  public:
  void clear_opacity();
  double opacity() const;
  void set_opacity(double value);
  private:
  double _internal_opacity() const;
  void _internal_set_opacity(double value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.SpecReflectionSetOpacityArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double opacity_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SpecShadowSetAngleArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SpecShadowSetAngleArchive) */ {
 public:
  inline SpecShadowSetAngleArchive() : SpecShadowSetAngleArchive(nullptr) {}
  ~SpecShadowSetAngleArchive() override;
  explicit constexpr SpecShadowSetAngleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecShadowSetAngleArchive(const SpecShadowSetAngleArchive& from);
  SpecShadowSetAngleArchive(SpecShadowSetAngleArchive&& from) noexcept
    : SpecShadowSetAngleArchive() {
    *this = ::std::move(from);
  }

  inline SpecShadowSetAngleArchive& operator=(const SpecShadowSetAngleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecShadowSetAngleArchive& operator=(SpecShadowSetAngleArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecShadowSetAngleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecShadowSetAngleArchive* internal_default_instance() {
    return reinterpret_cast<const SpecShadowSetAngleArchive*>(
               &_SpecShadowSetAngleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(SpecShadowSetAngleArchive& a, SpecShadowSetAngleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecShadowSetAngleArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecShadowSetAngleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecShadowSetAngleArchive* New() const final {
    return CreateMaybeMessage<SpecShadowSetAngleArchive>(nullptr);
  }

  SpecShadowSetAngleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecShadowSetAngleArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpecShadowSetAngleArchive& from);
  void MergeFrom(const SpecShadowSetAngleArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecShadowSetAngleArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SpecShadowSetAngleArchive";
  }
  protected:
  explicit SpecShadowSetAngleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAngleFieldNumber = 1,
  };
  // required double angle = 1;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  double angle() const;
  void set_angle(double value);
  private:
  double _internal_angle() const;
  void _internal_set_angle(double value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.SpecShadowSetAngleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double angle_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SpecShadowSetColorArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SpecShadowSetColorArchive) */ {
 public:
  inline SpecShadowSetColorArchive() : SpecShadowSetColorArchive(nullptr) {}
  ~SpecShadowSetColorArchive() override;
  explicit constexpr SpecShadowSetColorArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecShadowSetColorArchive(const SpecShadowSetColorArchive& from);
  SpecShadowSetColorArchive(SpecShadowSetColorArchive&& from) noexcept
    : SpecShadowSetColorArchive() {
    *this = ::std::move(from);
  }

  inline SpecShadowSetColorArchive& operator=(const SpecShadowSetColorArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecShadowSetColorArchive& operator=(SpecShadowSetColorArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecShadowSetColorArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecShadowSetColorArchive* internal_default_instance() {
    return reinterpret_cast<const SpecShadowSetColorArchive*>(
               &_SpecShadowSetColorArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(SpecShadowSetColorArchive& a, SpecShadowSetColorArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecShadowSetColorArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecShadowSetColorArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecShadowSetColorArchive* New() const final {
    return CreateMaybeMessage<SpecShadowSetColorArchive>(nullptr);
  }

  SpecShadowSetColorArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecShadowSetColorArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpecShadowSetColorArchive& from);
  void MergeFrom(const SpecShadowSetColorArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecShadowSetColorArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SpecShadowSetColorArchive";
  }
  protected:
  explicit SpecShadowSetColorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
  };
  // required .TSP.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::TSP::Color& color() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_color();
  ::TSP::Color* mutable_color();
  void set_allocated_color(::TSP::Color* color);
  private:
  const ::TSP::Color& _internal_color() const;
  ::TSP::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::TSP::Color* color);
  ::TSP::Color* unsafe_arena_release_color();

  // @@protoc_insertion_point(class_scope:TSD.SpecShadowSetColorArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Color* color_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SpecShadowSetOffsetArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SpecShadowSetOffsetArchive) */ {
 public:
  inline SpecShadowSetOffsetArchive() : SpecShadowSetOffsetArchive(nullptr) {}
  ~SpecShadowSetOffsetArchive() override;
  explicit constexpr SpecShadowSetOffsetArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecShadowSetOffsetArchive(const SpecShadowSetOffsetArchive& from);
  SpecShadowSetOffsetArchive(SpecShadowSetOffsetArchive&& from) noexcept
    : SpecShadowSetOffsetArchive() {
    *this = ::std::move(from);
  }

  inline SpecShadowSetOffsetArchive& operator=(const SpecShadowSetOffsetArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecShadowSetOffsetArchive& operator=(SpecShadowSetOffsetArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecShadowSetOffsetArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecShadowSetOffsetArchive* internal_default_instance() {
    return reinterpret_cast<const SpecShadowSetOffsetArchive*>(
               &_SpecShadowSetOffsetArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(SpecShadowSetOffsetArchive& a, SpecShadowSetOffsetArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecShadowSetOffsetArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecShadowSetOffsetArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecShadowSetOffsetArchive* New() const final {
    return CreateMaybeMessage<SpecShadowSetOffsetArchive>(nullptr);
  }

  SpecShadowSetOffsetArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecShadowSetOffsetArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpecShadowSetOffsetArchive& from);
  void MergeFrom(const SpecShadowSetOffsetArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecShadowSetOffsetArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SpecShadowSetOffsetArchive";
  }
  protected:
  explicit SpecShadowSetOffsetArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
  };
  // required double offset = 1;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  double offset() const;
  void set_offset(double value);
  private:
  double _internal_offset() const;
  void _internal_set_offset(double value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.SpecShadowSetOffsetArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double offset_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SpecShadowSetOpacityArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SpecShadowSetOpacityArchive) */ {
 public:
  inline SpecShadowSetOpacityArchive() : SpecShadowSetOpacityArchive(nullptr) {}
  ~SpecShadowSetOpacityArchive() override;
  explicit constexpr SpecShadowSetOpacityArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecShadowSetOpacityArchive(const SpecShadowSetOpacityArchive& from);
  SpecShadowSetOpacityArchive(SpecShadowSetOpacityArchive&& from) noexcept
    : SpecShadowSetOpacityArchive() {
    *this = ::std::move(from);
  }

  inline SpecShadowSetOpacityArchive& operator=(const SpecShadowSetOpacityArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecShadowSetOpacityArchive& operator=(SpecShadowSetOpacityArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecShadowSetOpacityArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecShadowSetOpacityArchive* internal_default_instance() {
    return reinterpret_cast<const SpecShadowSetOpacityArchive*>(
               &_SpecShadowSetOpacityArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(SpecShadowSetOpacityArchive& a, SpecShadowSetOpacityArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecShadowSetOpacityArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecShadowSetOpacityArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecShadowSetOpacityArchive* New() const final {
    return CreateMaybeMessage<SpecShadowSetOpacityArchive>(nullptr);
  }

  SpecShadowSetOpacityArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecShadowSetOpacityArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpecShadowSetOpacityArchive& from);
  void MergeFrom(const SpecShadowSetOpacityArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecShadowSetOpacityArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SpecShadowSetOpacityArchive";
  }
  protected:
  explicit SpecShadowSetOpacityArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpacityFieldNumber = 1,
  };
  // required double opacity = 1;
  bool has_opacity() const;
  private:
  bool _internal_has_opacity() const;
  public:
  void clear_opacity();
  double opacity() const;
  void set_opacity(double value);
  private:
  double _internal_opacity() const;
  void _internal_set_opacity(double value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.SpecShadowSetOpacityArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double opacity_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SpecShadowSetRadiusArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SpecShadowSetRadiusArchive) */ {
 public:
  inline SpecShadowSetRadiusArchive() : SpecShadowSetRadiusArchive(nullptr) {}
  ~SpecShadowSetRadiusArchive() override;
  explicit constexpr SpecShadowSetRadiusArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecShadowSetRadiusArchive(const SpecShadowSetRadiusArchive& from);
  SpecShadowSetRadiusArchive(SpecShadowSetRadiusArchive&& from) noexcept
    : SpecShadowSetRadiusArchive() {
    *this = ::std::move(from);
  }

  inline SpecShadowSetRadiusArchive& operator=(const SpecShadowSetRadiusArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecShadowSetRadiusArchive& operator=(SpecShadowSetRadiusArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecShadowSetRadiusArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecShadowSetRadiusArchive* internal_default_instance() {
    return reinterpret_cast<const SpecShadowSetRadiusArchive*>(
               &_SpecShadowSetRadiusArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(SpecShadowSetRadiusArchive& a, SpecShadowSetRadiusArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecShadowSetRadiusArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecShadowSetRadiusArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecShadowSetRadiusArchive* New() const final {
    return CreateMaybeMessage<SpecShadowSetRadiusArchive>(nullptr);
  }

  SpecShadowSetRadiusArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecShadowSetRadiusArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpecShadowSetRadiusArchive& from);
  void MergeFrom(const SpecShadowSetRadiusArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecShadowSetRadiusArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SpecShadowSetRadiusArchive";
  }
  protected:
  explicit SpecShadowSetRadiusArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadiusFieldNumber = 1,
  };
  // required int32 radius = 1;
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  ::PROTOBUF_NAMESPACE_ID::int32 radius() const;
  void set_radius(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_radius() const;
  void _internal_set_radius(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.SpecShadowSetRadiusArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 radius_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SpecStrokeSetColorArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SpecStrokeSetColorArchive) */ {
 public:
  inline SpecStrokeSetColorArchive() : SpecStrokeSetColorArchive(nullptr) {}
  ~SpecStrokeSetColorArchive() override;
  explicit constexpr SpecStrokeSetColorArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecStrokeSetColorArchive(const SpecStrokeSetColorArchive& from);
  SpecStrokeSetColorArchive(SpecStrokeSetColorArchive&& from) noexcept
    : SpecStrokeSetColorArchive() {
    *this = ::std::move(from);
  }

  inline SpecStrokeSetColorArchive& operator=(const SpecStrokeSetColorArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecStrokeSetColorArchive& operator=(SpecStrokeSetColorArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecStrokeSetColorArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecStrokeSetColorArchive* internal_default_instance() {
    return reinterpret_cast<const SpecStrokeSetColorArchive*>(
               &_SpecStrokeSetColorArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(SpecStrokeSetColorArchive& a, SpecStrokeSetColorArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecStrokeSetColorArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecStrokeSetColorArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecStrokeSetColorArchive* New() const final {
    return CreateMaybeMessage<SpecStrokeSetColorArchive>(nullptr);
  }

  SpecStrokeSetColorArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecStrokeSetColorArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpecStrokeSetColorArchive& from);
  void MergeFrom(const SpecStrokeSetColorArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecStrokeSetColorArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SpecStrokeSetColorArchive";
  }
  protected:
  explicit SpecStrokeSetColorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
  };
  // required .TSP.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::TSP::Color& color() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_color();
  ::TSP::Color* mutable_color();
  void set_allocated_color(::TSP::Color* color);
  private:
  const ::TSP::Color& _internal_color() const;
  ::TSP::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::TSP::Color* color);
  ::TSP::Color* unsafe_arena_release_color();

  // @@protoc_insertion_point(class_scope:TSD.SpecStrokeSetColorArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Color* color_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SpecStrokeSetPatternArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SpecStrokeSetPatternArchive) */ {
 public:
  inline SpecStrokeSetPatternArchive() : SpecStrokeSetPatternArchive(nullptr) {}
  ~SpecStrokeSetPatternArchive() override;
  explicit constexpr SpecStrokeSetPatternArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecStrokeSetPatternArchive(const SpecStrokeSetPatternArchive& from);
  SpecStrokeSetPatternArchive(SpecStrokeSetPatternArchive&& from) noexcept
    : SpecStrokeSetPatternArchive() {
    *this = ::std::move(from);
  }

  inline SpecStrokeSetPatternArchive& operator=(const SpecStrokeSetPatternArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecStrokeSetPatternArchive& operator=(SpecStrokeSetPatternArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecStrokeSetPatternArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecStrokeSetPatternArchive* internal_default_instance() {
    return reinterpret_cast<const SpecStrokeSetPatternArchive*>(
               &_SpecStrokeSetPatternArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(SpecStrokeSetPatternArchive& a, SpecStrokeSetPatternArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecStrokeSetPatternArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecStrokeSetPatternArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecStrokeSetPatternArchive* New() const final {
    return CreateMaybeMessage<SpecStrokeSetPatternArchive>(nullptr);
  }

  SpecStrokeSetPatternArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecStrokeSetPatternArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpecStrokeSetPatternArchive& from);
  void MergeFrom(const SpecStrokeSetPatternArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecStrokeSetPatternArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SpecStrokeSetPatternArchive";
  }
  protected:
  explicit SpecStrokeSetPatternArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 5,
    kPatternFieldNumber = 6,
    kLineCapFieldNumber = 1,
    kLineJoinFieldNumber = 2,
    kMiterLimitFieldNumber = 3,
    kWidthFieldNumber = 4,
  };
  // optional .TSP.Color color = 5;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::TSP::Color& color() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Color* release_color();
  ::TSP::Color* mutable_color();
  void set_allocated_color(::TSP::Color* color);
  private:
  const ::TSP::Color& _internal_color() const;
  ::TSP::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::TSP::Color* color);
  ::TSP::Color* unsafe_arena_release_color();

  // required .TSD.StrokePatternArchive pattern = 6;
  bool has_pattern() const;
  private:
  bool _internal_has_pattern() const;
  public:
  void clear_pattern();
  const ::TSD::StrokePatternArchive& pattern() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSD::StrokePatternArchive* release_pattern();
  ::TSD::StrokePatternArchive* mutable_pattern();
  void set_allocated_pattern(::TSD::StrokePatternArchive* pattern);
  private:
  const ::TSD::StrokePatternArchive& _internal_pattern() const;
  ::TSD::StrokePatternArchive* _internal_mutable_pattern();
  public:
  void unsafe_arena_set_allocated_pattern(
      ::TSD::StrokePatternArchive* pattern);
  ::TSD::StrokePatternArchive* unsafe_arena_release_pattern();

  // optional int32 line_cap = 1;
  bool has_line_cap() const;
  private:
  bool _internal_has_line_cap() const;
  public:
  void clear_line_cap();
  ::PROTOBUF_NAMESPACE_ID::int32 line_cap() const;
  void set_line_cap(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_line_cap() const;
  void _internal_set_line_cap(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 line_join = 2;
  bool has_line_join() const;
  private:
  bool _internal_has_line_join() const;
  public:
  void clear_line_join();
  ::PROTOBUF_NAMESPACE_ID::int32 line_join() const;
  void set_line_join(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_line_join() const;
  void _internal_set_line_join(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double miter_limit = 3;
  bool has_miter_limit() const;
  private:
  bool _internal_has_miter_limit() const;
  public:
  void clear_miter_limit();
  double miter_limit() const;
  void set_miter_limit(double value);
  private:
  double _internal_miter_limit() const;
  void _internal_set_miter_limit(double value);
  public:

  // optional double width = 4;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  double width() const;
  void set_width(double value);
  private:
  double _internal_width() const;
  void _internal_set_width(double value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.SpecStrokeSetPatternArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TSP::Color* color_;
  ::TSD::StrokePatternArchive* pattern_;
  ::PROTOBUF_NAMESPACE_ID::int32 line_cap_;
  ::PROTOBUF_NAMESPACE_ID::int32 line_join_;
  double miter_limit_;
  double width_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SpecStrokeSetWidthArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SpecStrokeSetWidthArchive) */ {
 public:
  inline SpecStrokeSetWidthArchive() : SpecStrokeSetWidthArchive(nullptr) {}
  ~SpecStrokeSetWidthArchive() override;
  explicit constexpr SpecStrokeSetWidthArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecStrokeSetWidthArchive(const SpecStrokeSetWidthArchive& from);
  SpecStrokeSetWidthArchive(SpecStrokeSetWidthArchive&& from) noexcept
    : SpecStrokeSetWidthArchive() {
    *this = ::std::move(from);
  }

  inline SpecStrokeSetWidthArchive& operator=(const SpecStrokeSetWidthArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecStrokeSetWidthArchive& operator=(SpecStrokeSetWidthArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecStrokeSetWidthArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecStrokeSetWidthArchive* internal_default_instance() {
    return reinterpret_cast<const SpecStrokeSetWidthArchive*>(
               &_SpecStrokeSetWidthArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(SpecStrokeSetWidthArchive& a, SpecStrokeSetWidthArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecStrokeSetWidthArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecStrokeSetWidthArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecStrokeSetWidthArchive* New() const final {
    return CreateMaybeMessage<SpecStrokeSetWidthArchive>(nullptr);
  }

  SpecStrokeSetWidthArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecStrokeSetWidthArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpecStrokeSetWidthArchive& from);
  void MergeFrom(const SpecStrokeSetWidthArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecStrokeSetWidthArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SpecStrokeSetWidthArchive";
  }
  protected:
  explicit SpecStrokeSetWidthArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
  };
  // required double width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  double width() const;
  void set_width(double value);
  private:
  double _internal_width() const;
  void _internal_set_width(double value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.SpecStrokeSetWidthArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double width_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class Attribution PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.Attribution) */ {
 public:
  inline Attribution() : Attribution(nullptr) {}
  ~Attribution() override;
  explicit constexpr Attribution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Attribution(const Attribution& from);
  Attribution(Attribution&& from) noexcept
    : Attribution() {
    *this = ::std::move(from);
  }

  inline Attribution& operator=(const Attribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attribution& operator=(Attribution&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Attribution& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attribution* internal_default_instance() {
    return reinterpret_cast<const Attribution*>(
               &_Attribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(Attribution& a, Attribution& b) {
    a.Swap(&b);
  }
  inline void Swap(Attribution* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attribution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Attribution* New() const final {
    return CreateMaybeMessage<Attribution>(nullptr);
  }

  Attribution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Attribution>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Attribution& from);
  void MergeFrom(const Attribution& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attribution* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.Attribution";
  }
  protected:
  explicit Attribution(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionTextFieldNumber = 2,
    kExternalUrlFieldNumber = 3,
    kAuthorNameFieldNumber = 4,
    kAuthorUrlFieldNumber = 5,
  };
  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string description_text = 2;
  bool has_description_text() const;
  private:
  bool _internal_has_description_text() const;
  public:
  void clear_description_text();
  const std::string& description_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description_text();
  std::string* release_description_text();
  void set_allocated_description_text(std::string* description_text);
  private:
  const std::string& _internal_description_text() const;
  void _internal_set_description_text(const std::string& value);
  std::string* _internal_mutable_description_text();
  public:

  // optional string external_url = 3;
  bool has_external_url() const;
  private:
  bool _internal_has_external_url() const;
  public:
  void clear_external_url();
  const std::string& external_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_url();
  std::string* release_external_url();
  void set_allocated_external_url(std::string* external_url);
  private:
  const std::string& _internal_external_url() const;
  void _internal_set_external_url(const std::string& value);
  std::string* _internal_mutable_external_url();
  public:

  // optional string author_name = 4;
  bool has_author_name() const;
  private:
  bool _internal_has_author_name() const;
  public:
  void clear_author_name();
  const std::string& author_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author_name();
  std::string* release_author_name();
  void set_allocated_author_name(std::string* author_name);
  private:
  const std::string& _internal_author_name() const;
  void _internal_set_author_name(const std::string& value);
  std::string* _internal_mutable_author_name();
  public:

  // optional string author_url = 5;
  bool has_author_url() const;
  private:
  bool _internal_has_author_url() const;
  public:
  void clear_author_url();
  const std::string& author_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author_url();
  std::string* release_author_url();
  void set_allocated_author_url(std::string* author_url);
  private:
  const std::string& _internal_author_url() const;
  void _internal_set_author_url(const std::string& value);
  std::string* _internal_mutable_author_url();
  public:

  // @@protoc_insertion_point(class_scope:TSD.Attribution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_url_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class MovieFingerprint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.MovieFingerprint) */ {
 public:
  inline MovieFingerprint() : MovieFingerprint(nullptr) {}
  ~MovieFingerprint() override;
  explicit constexpr MovieFingerprint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MovieFingerprint(const MovieFingerprint& from);
  MovieFingerprint(MovieFingerprint&& from) noexcept
    : MovieFingerprint() {
    *this = ::std::move(from);
  }

  inline MovieFingerprint& operator=(const MovieFingerprint& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovieFingerprint& operator=(MovieFingerprint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovieFingerprint& default_instance() {
    return *internal_default_instance();
  }
  static inline const MovieFingerprint* internal_default_instance() {
    return reinterpret_cast<const MovieFingerprint*>(
               &_MovieFingerprint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(MovieFingerprint& a, MovieFingerprint& b) {
    a.Swap(&b);
  }
  inline void Swap(MovieFingerprint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovieFingerprint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MovieFingerprint* New() const final {
    return CreateMaybeMessage<MovieFingerprint>(nullptr);
  }

  MovieFingerprint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MovieFingerprint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MovieFingerprint& from);
  void MergeFrom(const MovieFingerprint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovieFingerprint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.MovieFingerprint";
  }
  protected:
  explicit MovieFingerprint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTracksFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // repeated .TSD.MovieFingerprintTrack tracks = 1;
  int tracks_size() const;
  private:
  int _internal_tracks_size() const;
  public:
  void clear_tracks();
  ::TSD::MovieFingerprintTrack* mutable_tracks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::MovieFingerprintTrack >*
      mutable_tracks();
  private:
  const ::TSD::MovieFingerprintTrack& _internal_tracks(int index) const;
  ::TSD::MovieFingerprintTrack* _internal_add_tracks();
  public:
  const ::TSD::MovieFingerprintTrack& tracks(int index) const;
  ::TSD::MovieFingerprintTrack* add_tracks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::MovieFingerprintTrack >&
      tracks() const;

  // repeated uint32 version = 2 [packed = true];
  int version_size() const;
  private:
  int _internal_version_size() const;
  public:
  void clear_version();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_version() const;
  void _internal_add_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_version();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 version(int index) const;
  void set_version(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      version() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_version();

  // @@protoc_insertion_point(class_scope:TSD.MovieFingerprint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::MovieFingerprintTrack > tracks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > version_;
  mutable std::atomic<int> _version_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class MovieFingerprintTrack PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.MovieFingerprintTrack) */ {
 public:
  inline MovieFingerprintTrack() : MovieFingerprintTrack(nullptr) {}
  ~MovieFingerprintTrack() override;
  explicit constexpr MovieFingerprintTrack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MovieFingerprintTrack(const MovieFingerprintTrack& from);
  MovieFingerprintTrack(MovieFingerprintTrack&& from) noexcept
    : MovieFingerprintTrack() {
    *this = ::std::move(from);
  }

  inline MovieFingerprintTrack& operator=(const MovieFingerprintTrack& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovieFingerprintTrack& operator=(MovieFingerprintTrack&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovieFingerprintTrack& default_instance() {
    return *internal_default_instance();
  }
  static inline const MovieFingerprintTrack* internal_default_instance() {
    return reinterpret_cast<const MovieFingerprintTrack*>(
               &_MovieFingerprintTrack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(MovieFingerprintTrack& a, MovieFingerprintTrack& b) {
    a.Swap(&b);
  }
  inline void Swap(MovieFingerprintTrack* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovieFingerprintTrack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MovieFingerprintTrack* New() const final {
    return CreateMaybeMessage<MovieFingerprintTrack>(nullptr);
  }

  MovieFingerprintTrack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MovieFingerprintTrack>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MovieFingerprintTrack& from);
  void MergeFrom(const MovieFingerprintTrack& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovieFingerprintTrack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.MovieFingerprintTrack";
  }
  protected:
  explicit MovieFingerprintTrack(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMediaTypeFieldNumber = 1,
    kSampleDataDigestStringFieldNumber = 4,
    kLanguageCodeFieldNumber = 19,
    kExtendedLanguageTagFieldNumber = 20,
    kNaturalSizeFieldNumber = 11,
    kTotalSampleDataLengthFieldNumber = 3,
    kTimeRangeStartValueFieldNumber = 5,
    kTimeRangeStartTimescaleFieldNumber = 6,
    kEnabledFieldNumber = 2,
    kTimeRangeStartIsValidFieldNumber = 7,
    kTimeRangeDurationIsValidFieldNumber = 10,
    kTimeRangeDurationValueFieldNumber = 8,
    kPreferredTransformAFieldNumber = 12,
    kPreferredTransformBFieldNumber = 13,
    kPreferredTransformCFieldNumber = 14,
    kPreferredTransformDFieldNumber = 15,
    kPreferredTransformTxFieldNumber = 16,
    kPreferredTransformTyFieldNumber = 17,
    kPreferredVolumeFieldNumber = 18,
    kTimeRangeDurationTimescaleFieldNumber = 9,
  };
  // optional string media_type = 1;
  bool has_media_type() const;
  private:
  bool _internal_has_media_type() const;
  public:
  void clear_media_type();
  const std::string& media_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_media_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_media_type();
  std::string* release_media_type();
  void set_allocated_media_type(std::string* media_type);
  private:
  const std::string& _internal_media_type() const;
  void _internal_set_media_type(const std::string& value);
  std::string* _internal_mutable_media_type();
  public:

  // optional string sample_data_digest_string = 4;
  bool has_sample_data_digest_string() const;
  private:
  bool _internal_has_sample_data_digest_string() const;
  public:
  void clear_sample_data_digest_string();
  const std::string& sample_data_digest_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sample_data_digest_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sample_data_digest_string();
  std::string* release_sample_data_digest_string();
  void set_allocated_sample_data_digest_string(std::string* sample_data_digest_string);
  private:
  const std::string& _internal_sample_data_digest_string() const;
  void _internal_set_sample_data_digest_string(const std::string& value);
  std::string* _internal_mutable_sample_data_digest_string();
  public:

  // optional string language_code = 19;
  bool has_language_code() const;
  private:
  bool _internal_has_language_code() const;
  public:
  void clear_language_code();
  const std::string& language_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language_code();
  std::string* release_language_code();
  void set_allocated_language_code(std::string* language_code);
  private:
  const std::string& _internal_language_code() const;
  void _internal_set_language_code(const std::string& value);
  std::string* _internal_mutable_language_code();
  public:

  // optional string extended_language_tag = 20;
  bool has_extended_language_tag() const;
  private:
  bool _internal_has_extended_language_tag() const;
  public:
  void clear_extended_language_tag();
  const std::string& extended_language_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extended_language_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extended_language_tag();
  std::string* release_extended_language_tag();
  void set_allocated_extended_language_tag(std::string* extended_language_tag);
  private:
  const std::string& _internal_extended_language_tag() const;
  void _internal_set_extended_language_tag(const std::string& value);
  std::string* _internal_mutable_extended_language_tag();
  public:

  // optional .TSP.Size natural_size = 11;
  bool has_natural_size() const;
  private:
  bool _internal_has_natural_size() const;
  public:
  void clear_natural_size();
  const ::TSP::Size& natural_size() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::TSP::Size* release_natural_size();
  ::TSP::Size* mutable_natural_size();
  void set_allocated_natural_size(::TSP::Size* natural_size);
  private:
  const ::TSP::Size& _internal_natural_size() const;
  ::TSP::Size* _internal_mutable_natural_size();
  public:
  void unsafe_arena_set_allocated_natural_size(
      ::TSP::Size* natural_size);
  ::TSP::Size* unsafe_arena_release_natural_size();

  // optional int64 total_sample_data_length = 3;
  bool has_total_sample_data_length() const;
  private:
  bool _internal_has_total_sample_data_length() const;
  public:
  void clear_total_sample_data_length();
  ::PROTOBUF_NAMESPACE_ID::int64 total_sample_data_length() const;
  void set_total_sample_data_length(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_total_sample_data_length() const;
  void _internal_set_total_sample_data_length(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 time_range_start_value = 5;
  bool has_time_range_start_value() const;
  private:
  bool _internal_has_time_range_start_value() const;
  public:
  void clear_time_range_start_value();
  ::PROTOBUF_NAMESPACE_ID::int64 time_range_start_value() const;
  void set_time_range_start_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time_range_start_value() const;
  void _internal_set_time_range_start_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 time_range_start_timescale = 6;
  bool has_time_range_start_timescale() const;
  private:
  bool _internal_has_time_range_start_timescale() const;
  public:
  void clear_time_range_start_timescale();
  ::PROTOBUF_NAMESPACE_ID::int32 time_range_start_timescale() const;
  void set_time_range_start_timescale(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_time_range_start_timescale() const;
  void _internal_set_time_range_start_timescale(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool enabled = 2;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional bool time_range_start_is_valid = 7;
  bool has_time_range_start_is_valid() const;
  private:
  bool _internal_has_time_range_start_is_valid() const;
  public:
  void clear_time_range_start_is_valid();
  bool time_range_start_is_valid() const;
  void set_time_range_start_is_valid(bool value);
  private:
  bool _internal_time_range_start_is_valid() const;
  void _internal_set_time_range_start_is_valid(bool value);
  public:

  // optional bool time_range_duration_is_valid = 10;
  bool has_time_range_duration_is_valid() const;
  private:
  bool _internal_has_time_range_duration_is_valid() const;
  public:
  void clear_time_range_duration_is_valid();
  bool time_range_duration_is_valid() const;
  void set_time_range_duration_is_valid(bool value);
  private:
  bool _internal_time_range_duration_is_valid() const;
  void _internal_set_time_range_duration_is_valid(bool value);
  public:

  // optional int64 time_range_duration_value = 8;
  bool has_time_range_duration_value() const;
  private:
  bool _internal_has_time_range_duration_value() const;
  public:
  void clear_time_range_duration_value();
  ::PROTOBUF_NAMESPACE_ID::int64 time_range_duration_value() const;
  void set_time_range_duration_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time_range_duration_value() const;
  void _internal_set_time_range_duration_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional double preferred_transform_a = 12;
  bool has_preferred_transform_a() const;
  private:
  bool _internal_has_preferred_transform_a() const;
  public:
  void clear_preferred_transform_a();
  double preferred_transform_a() const;
  void set_preferred_transform_a(double value);
  private:
  double _internal_preferred_transform_a() const;
  void _internal_set_preferred_transform_a(double value);
  public:

  // optional double preferred_transform_b = 13;
  bool has_preferred_transform_b() const;
  private:
  bool _internal_has_preferred_transform_b() const;
  public:
  void clear_preferred_transform_b();
  double preferred_transform_b() const;
  void set_preferred_transform_b(double value);
  private:
  double _internal_preferred_transform_b() const;
  void _internal_set_preferred_transform_b(double value);
  public:

  // optional double preferred_transform_c = 14;
  bool has_preferred_transform_c() const;
  private:
  bool _internal_has_preferred_transform_c() const;
  public:
  void clear_preferred_transform_c();
  double preferred_transform_c() const;
  void set_preferred_transform_c(double value);
  private:
  double _internal_preferred_transform_c() const;
  void _internal_set_preferred_transform_c(double value);
  public:

  // optional double preferred_transform_d = 15;
  bool has_preferred_transform_d() const;
  private:
  bool _internal_has_preferred_transform_d() const;
  public:
  void clear_preferred_transform_d();
  double preferred_transform_d() const;
  void set_preferred_transform_d(double value);
  private:
  double _internal_preferred_transform_d() const;
  void _internal_set_preferred_transform_d(double value);
  public:

  // optional double preferred_transform_tx = 16;
  bool has_preferred_transform_tx() const;
  private:
  bool _internal_has_preferred_transform_tx() const;
  public:
  void clear_preferred_transform_tx();
  double preferred_transform_tx() const;
  void set_preferred_transform_tx(double value);
  private:
  double _internal_preferred_transform_tx() const;
  void _internal_set_preferred_transform_tx(double value);
  public:

  // optional double preferred_transform_ty = 17;
  bool has_preferred_transform_ty() const;
  private:
  bool _internal_has_preferred_transform_ty() const;
  public:
  void clear_preferred_transform_ty();
  double preferred_transform_ty() const;
  void set_preferred_transform_ty(double value);
  private:
  double _internal_preferred_transform_ty() const;
  void _internal_set_preferred_transform_ty(double value);
  public:

  // optional double preferred_volume = 18;
  bool has_preferred_volume() const;
  private:
  bool _internal_has_preferred_volume() const;
  public:
  void clear_preferred_volume();
  double preferred_volume() const;
  void set_preferred_volume(double value);
  private:
  double _internal_preferred_volume() const;
  void _internal_set_preferred_volume(double value);
  public:

  // optional int32 time_range_duration_timescale = 9;
  bool has_time_range_duration_timescale() const;
  private:
  bool _internal_has_time_range_duration_timescale() const;
  public:
  void clear_time_range_duration_timescale();
  ::PROTOBUF_NAMESPACE_ID::int32 time_range_duration_timescale() const;
  void set_time_range_duration_timescale(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_time_range_duration_timescale() const;
  void _internal_set_time_range_duration_timescale(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.MovieFingerprintTrack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr media_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sample_data_digest_string_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extended_language_tag_;
  ::TSP::Size* natural_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_sample_data_length_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_range_start_value_;
  ::PROTOBUF_NAMESPACE_ID::int32 time_range_start_timescale_;
  bool enabled_;
  bool time_range_start_is_valid_;
  bool time_range_duration_is_valid_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_range_duration_value_;
  double preferred_transform_a_;
  double preferred_transform_b_;
  double preferred_transform_c_;
  double preferred_transform_d_;
  double preferred_transform_tx_;
  double preferred_transform_ty_;
  double preferred_volume_;
  ::PROTOBUF_NAMESPACE_ID::int32 time_range_duration_timescale_;
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// ===================================================================

static const int kFillFieldNumber = 200;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::TSS::CommandPropertyEntryArchive,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::TSD::FillArchive >, 11, false >
  fill;
static const int kStrokeFieldNumber = 201;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::TSS::CommandPropertyEntryArchive,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::TSD::StrokeArchive >, 11, false >
  stroke;

// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EdgeInsetsArchive

// required float top = 1;
inline bool EdgeInsetsArchive::_internal_has_top() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EdgeInsetsArchive::has_top() const {
  return _internal_has_top();
}
inline void EdgeInsetsArchive::clear_top() {
  top_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float EdgeInsetsArchive::_internal_top() const {
  return top_;
}
inline float EdgeInsetsArchive::top() const {
  // @@protoc_insertion_point(field_get:TSD.EdgeInsetsArchive.top)
  return _internal_top();
}
inline void EdgeInsetsArchive::_internal_set_top(float value) {
  _has_bits_[0] |= 0x00000001u;
  top_ = value;
}
inline void EdgeInsetsArchive::set_top(float value) {
  _internal_set_top(value);
  // @@protoc_insertion_point(field_set:TSD.EdgeInsetsArchive.top)
}

// required float left = 2;
inline bool EdgeInsetsArchive::_internal_has_left() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EdgeInsetsArchive::has_left() const {
  return _internal_has_left();
}
inline void EdgeInsetsArchive::clear_left() {
  left_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float EdgeInsetsArchive::_internal_left() const {
  return left_;
}
inline float EdgeInsetsArchive::left() const {
  // @@protoc_insertion_point(field_get:TSD.EdgeInsetsArchive.left)
  return _internal_left();
}
inline void EdgeInsetsArchive::_internal_set_left(float value) {
  _has_bits_[0] |= 0x00000002u;
  left_ = value;
}
inline void EdgeInsetsArchive::set_left(float value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:TSD.EdgeInsetsArchive.left)
}

// required float bottom = 3;
inline bool EdgeInsetsArchive::_internal_has_bottom() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EdgeInsetsArchive::has_bottom() const {
  return _internal_has_bottom();
}
inline void EdgeInsetsArchive::clear_bottom() {
  bottom_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float EdgeInsetsArchive::_internal_bottom() const {
  return bottom_;
}
inline float EdgeInsetsArchive::bottom() const {
  // @@protoc_insertion_point(field_get:TSD.EdgeInsetsArchive.bottom)
  return _internal_bottom();
}
inline void EdgeInsetsArchive::_internal_set_bottom(float value) {
  _has_bits_[0] |= 0x00000004u;
  bottom_ = value;
}
inline void EdgeInsetsArchive::set_bottom(float value) {
  _internal_set_bottom(value);
  // @@protoc_insertion_point(field_set:TSD.EdgeInsetsArchive.bottom)
}

// required float right = 4;
inline bool EdgeInsetsArchive::_internal_has_right() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EdgeInsetsArchive::has_right() const {
  return _internal_has_right();
}
inline void EdgeInsetsArchive::clear_right() {
  right_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float EdgeInsetsArchive::_internal_right() const {
  return right_;
}
inline float EdgeInsetsArchive::right() const {
  // @@protoc_insertion_point(field_get:TSD.EdgeInsetsArchive.right)
  return _internal_right();
}
inline void EdgeInsetsArchive::_internal_set_right(float value) {
  _has_bits_[0] |= 0x00000008u;
  right_ = value;
}
inline void EdgeInsetsArchive::set_right(float value) {
  _internal_set_right(value);
  // @@protoc_insertion_point(field_set:TSD.EdgeInsetsArchive.right)
}

// -------------------------------------------------------------------

// GeometryArchive

// optional .TSP.Point position = 1;
inline bool GeometryArchive::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || position_ != nullptr);
  return value;
}
inline bool GeometryArchive::has_position() const {
  return _internal_has_position();
}
inline const ::TSP::Point& GeometryArchive::_internal_position() const {
  const ::TSP::Point* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& GeometryArchive::position() const {
  // @@protoc_insertion_point(field_get:TSD.GeometryArchive.position)
  return _internal_position();
}
inline void GeometryArchive::unsafe_arena_set_allocated_position(
    ::TSP::Point* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.GeometryArchive.position)
}
inline ::TSP::Point* GeometryArchive::release_position() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = position_;
  position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Point* GeometryArchive::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:TSD.GeometryArchive.position)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::TSP::Point* GeometryArchive::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000001u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::TSP::Point* GeometryArchive::mutable_position() {
  // @@protoc_insertion_point(field_mutable:TSD.GeometryArchive.position)
  return _internal_mutable_position();
}
inline void GeometryArchive::set_allocated_position(::TSP::Point* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position)->GetArena();
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:TSD.GeometryArchive.position)
}

// optional .TSP.Size size = 2;
inline bool GeometryArchive::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || size_ != nullptr);
  return value;
}
inline bool GeometryArchive::has_size() const {
  return _internal_has_size();
}
inline const ::TSP::Size& GeometryArchive::_internal_size() const {
  const ::TSP::Size* p = size_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& GeometryArchive::size() const {
  // @@protoc_insertion_point(field_get:TSD.GeometryArchive.size)
  return _internal_size();
}
inline void GeometryArchive::unsafe_arena_set_allocated_size(
    ::TSP::Size* size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.GeometryArchive.size)
}
inline ::TSP::Size* GeometryArchive::release_size() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Size* temp = size_;
  size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* GeometryArchive::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:TSD.GeometryArchive.size)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Size* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::TSP::Size* GeometryArchive::_internal_mutable_size() {
  _has_bits_[0] |= 0x00000002u;
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    size_ = p;
  }
  return size_;
}
inline ::TSP::Size* GeometryArchive::mutable_size() {
  // @@protoc_insertion_point(field_mutable:TSD.GeometryArchive.size)
  return _internal_mutable_size();
}
inline void GeometryArchive::set_allocated_size(::TSP::Size* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size)->GetArena();
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:TSD.GeometryArchive.size)
}

// optional uint32 flags = 3;
inline bool GeometryArchive::_internal_has_flags() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GeometryArchive::has_flags() const {
  return _internal_has_flags();
}
inline void GeometryArchive::clear_flags() {
  flags_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GeometryArchive::_internal_flags() const {
  return flags_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GeometryArchive::flags() const {
  // @@protoc_insertion_point(field_get:TSD.GeometryArchive.flags)
  return _internal_flags();
}
inline void GeometryArchive::_internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  flags_ = value;
}
inline void GeometryArchive::set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:TSD.GeometryArchive.flags)
}

// optional float angle = 4;
inline bool GeometryArchive::_internal_has_angle() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GeometryArchive::has_angle() const {
  return _internal_has_angle();
}
inline void GeometryArchive::clear_angle() {
  angle_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float GeometryArchive::_internal_angle() const {
  return angle_;
}
inline float GeometryArchive::angle() const {
  // @@protoc_insertion_point(field_get:TSD.GeometryArchive.angle)
  return _internal_angle();
}
inline void GeometryArchive::_internal_set_angle(float value) {
  _has_bits_[0] |= 0x00000008u;
  angle_ = value;
}
inline void GeometryArchive::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:TSD.GeometryArchive.angle)
}

// -------------------------------------------------------------------

// PointPathSourceArchive

// optional .TSD.PointPathSourceArchive.PointPathSourceType type = 1;
inline bool PointPathSourceArchive::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PointPathSourceArchive::has_type() const {
  return _internal_has_type();
}
inline void PointPathSourceArchive::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::TSD::PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::_internal_type() const {
  return static_cast< ::TSD::PointPathSourceArchive_PointPathSourceType >(type_);
}
inline ::TSD::PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.PointPathSourceArchive.type)
  return _internal_type();
}
inline void PointPathSourceArchive::_internal_set_type(::TSD::PointPathSourceArchive_PointPathSourceType value) {
  assert(::TSD::PointPathSourceArchive_PointPathSourceType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void PointPathSourceArchive::set_type(::TSD::PointPathSourceArchive_PointPathSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.PointPathSourceArchive.type)
}

// optional .TSP.Point point = 2;
inline bool PointPathSourceArchive::_internal_has_point() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || point_ != nullptr);
  return value;
}
inline bool PointPathSourceArchive::has_point() const {
  return _internal_has_point();
}
inline const ::TSP::Point& PointPathSourceArchive::_internal_point() const {
  const ::TSP::Point* p = point_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& PointPathSourceArchive::point() const {
  // @@protoc_insertion_point(field_get:TSD.PointPathSourceArchive.point)
  return _internal_point();
}
inline void PointPathSourceArchive::unsafe_arena_set_allocated_point(
    ::TSP::Point* point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  point_ = point;
  if (point) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PointPathSourceArchive.point)
}
inline ::TSP::Point* PointPathSourceArchive::release_point() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = point_;
  point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Point* PointPathSourceArchive::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:TSD.PointPathSourceArchive.point)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::TSP::Point* PointPathSourceArchive::_internal_mutable_point() {
  _has_bits_[0] |= 0x00000001u;
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArena());
    point_ = p;
  }
  return point_;
}
inline ::TSP::Point* PointPathSourceArchive::mutable_point() {
  // @@protoc_insertion_point(field_mutable:TSD.PointPathSourceArchive.point)
  return _internal_mutable_point();
}
inline void PointPathSourceArchive::set_allocated_point(::TSP::Point* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point)->GetArena();
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:TSD.PointPathSourceArchive.point)
}

// optional .TSP.Size naturalSize = 3;
inline bool PointPathSourceArchive::_internal_has_naturalsize() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || naturalsize_ != nullptr);
  return value;
}
inline bool PointPathSourceArchive::has_naturalsize() const {
  return _internal_has_naturalsize();
}
inline const ::TSP::Size& PointPathSourceArchive::_internal_naturalsize() const {
  const ::TSP::Size* p = naturalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& PointPathSourceArchive::naturalsize() const {
  // @@protoc_insertion_point(field_get:TSD.PointPathSourceArchive.naturalSize)
  return _internal_naturalsize();
}
inline void PointPathSourceArchive::unsafe_arena_set_allocated_naturalsize(
    ::TSP::Size* naturalsize) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize_);
  }
  naturalsize_ = naturalsize;
  if (naturalsize) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PointPathSourceArchive.naturalSize)
}
inline ::TSP::Size* PointPathSourceArchive::release_naturalsize() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* PointPathSourceArchive::unsafe_arena_release_naturalsize() {
  // @@protoc_insertion_point(field_release:TSD.PointPathSourceArchive.naturalSize)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* PointPathSourceArchive::_internal_mutable_naturalsize() {
  _has_bits_[0] |= 0x00000002u;
  if (naturalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    naturalsize_ = p;
  }
  return naturalsize_;
}
inline ::TSP::Size* PointPathSourceArchive::mutable_naturalsize() {
  // @@protoc_insertion_point(field_mutable:TSD.PointPathSourceArchive.naturalSize)
  return _internal_mutable_naturalsize();
}
inline void PointPathSourceArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize_);
  }
  if (naturalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize)->GetArena();
    if (message_arena != submessage_arena) {
      naturalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, naturalsize, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  naturalsize_ = naturalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.PointPathSourceArchive.naturalSize)
}

// -------------------------------------------------------------------

// ScalarPathSourceArchive

// optional .TSD.ScalarPathSourceArchive.ScalarPathSourceType type = 1;
inline bool ScalarPathSourceArchive::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScalarPathSourceArchive::has_type() const {
  return _internal_has_type();
}
inline void ScalarPathSourceArchive::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::TSD::ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::_internal_type() const {
  return static_cast< ::TSD::ScalarPathSourceArchive_ScalarPathSourceType >(type_);
}
inline ::TSD::ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.ScalarPathSourceArchive.type)
  return _internal_type();
}
inline void ScalarPathSourceArchive::_internal_set_type(::TSD::ScalarPathSourceArchive_ScalarPathSourceType value) {
  assert(::TSD::ScalarPathSourceArchive_ScalarPathSourceType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void ScalarPathSourceArchive::set_type(::TSD::ScalarPathSourceArchive_ScalarPathSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.ScalarPathSourceArchive.type)
}

// optional float scalar = 2;
inline bool ScalarPathSourceArchive::_internal_has_scalar() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ScalarPathSourceArchive::has_scalar() const {
  return _internal_has_scalar();
}
inline void ScalarPathSourceArchive::clear_scalar() {
  scalar_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ScalarPathSourceArchive::_internal_scalar() const {
  return scalar_;
}
inline float ScalarPathSourceArchive::scalar() const {
  // @@protoc_insertion_point(field_get:TSD.ScalarPathSourceArchive.scalar)
  return _internal_scalar();
}
inline void ScalarPathSourceArchive::_internal_set_scalar(float value) {
  _has_bits_[0] |= 0x00000004u;
  scalar_ = value;
}
inline void ScalarPathSourceArchive::set_scalar(float value) {
  _internal_set_scalar(value);
  // @@protoc_insertion_point(field_set:TSD.ScalarPathSourceArchive.scalar)
}

// optional .TSP.Size naturalSize = 3;
inline bool ScalarPathSourceArchive::_internal_has_naturalsize() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || naturalsize_ != nullptr);
  return value;
}
inline bool ScalarPathSourceArchive::has_naturalsize() const {
  return _internal_has_naturalsize();
}
inline const ::TSP::Size& ScalarPathSourceArchive::_internal_naturalsize() const {
  const ::TSP::Size* p = naturalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& ScalarPathSourceArchive::naturalsize() const {
  // @@protoc_insertion_point(field_get:TSD.ScalarPathSourceArchive.naturalSize)
  return _internal_naturalsize();
}
inline void ScalarPathSourceArchive::unsafe_arena_set_allocated_naturalsize(
    ::TSP::Size* naturalsize) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize_);
  }
  naturalsize_ = naturalsize;
  if (naturalsize) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ScalarPathSourceArchive.naturalSize)
}
inline ::TSP::Size* ScalarPathSourceArchive::release_naturalsize() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* ScalarPathSourceArchive::unsafe_arena_release_naturalsize() {
  // @@protoc_insertion_point(field_release:TSD.ScalarPathSourceArchive.naturalSize)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* ScalarPathSourceArchive::_internal_mutable_naturalsize() {
  _has_bits_[0] |= 0x00000001u;
  if (naturalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    naturalsize_ = p;
  }
  return naturalsize_;
}
inline ::TSP::Size* ScalarPathSourceArchive::mutable_naturalsize() {
  // @@protoc_insertion_point(field_mutable:TSD.ScalarPathSourceArchive.naturalSize)
  return _internal_mutable_naturalsize();
}
inline void ScalarPathSourceArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize_);
  }
  if (naturalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize)->GetArena();
    if (message_arena != submessage_arena) {
      naturalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, naturalsize, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  naturalsize_ = naturalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.ScalarPathSourceArchive.naturalSize)
}

// optional bool is_curve_continuous = 4;
inline bool ScalarPathSourceArchive::_internal_has_is_curve_continuous() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ScalarPathSourceArchive::has_is_curve_continuous() const {
  return _internal_has_is_curve_continuous();
}
inline void ScalarPathSourceArchive::clear_is_curve_continuous() {
  is_curve_continuous_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ScalarPathSourceArchive::_internal_is_curve_continuous() const {
  return is_curve_continuous_;
}
inline bool ScalarPathSourceArchive::is_curve_continuous() const {
  // @@protoc_insertion_point(field_get:TSD.ScalarPathSourceArchive.is_curve_continuous)
  return _internal_is_curve_continuous();
}
inline void ScalarPathSourceArchive::_internal_set_is_curve_continuous(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_curve_continuous_ = value;
}
inline void ScalarPathSourceArchive::set_is_curve_continuous(bool value) {
  _internal_set_is_curve_continuous(value);
  // @@protoc_insertion_point(field_set:TSD.ScalarPathSourceArchive.is_curve_continuous)
}

// -------------------------------------------------------------------

// BezierPathSourceArchive

// optional string path_string = 1 [deprecated = true];
inline bool BezierPathSourceArchive::_internal_has_path_string() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BezierPathSourceArchive::has_path_string() const {
  return _internal_has_path_string();
}
inline void BezierPathSourceArchive::clear_path_string() {
  path_string_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BezierPathSourceArchive::path_string() const {
  // @@protoc_insertion_point(field_get:TSD.BezierPathSourceArchive.path_string)
  return _internal_path_string();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void BezierPathSourceArchive::set_path_string(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 path_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.BezierPathSourceArchive.path_string)
}
inline std::string* BezierPathSourceArchive::mutable_path_string() {
  // @@protoc_insertion_point(field_mutable:TSD.BezierPathSourceArchive.path_string)
  return _internal_mutable_path_string();
}
inline const std::string& BezierPathSourceArchive::_internal_path_string() const {
  return path_string_.Get();
}
inline void BezierPathSourceArchive::_internal_set_path_string(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  path_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* BezierPathSourceArchive::_internal_mutable_path_string() {
  _has_bits_[0] |= 0x00000001u;
  return path_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BezierPathSourceArchive::release_path_string() {
  // @@protoc_insertion_point(field_release:TSD.BezierPathSourceArchive.path_string)
  if (!_internal_has_path_string()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return path_string_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BezierPathSourceArchive::set_allocated_path_string(std::string* path_string) {
  if (path_string != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  path_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path_string,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.BezierPathSourceArchive.path_string)
}

// optional .TSP.Size naturalSize = 2;
inline bool BezierPathSourceArchive::_internal_has_naturalsize() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || naturalsize_ != nullptr);
  return value;
}
inline bool BezierPathSourceArchive::has_naturalsize() const {
  return _internal_has_naturalsize();
}
inline const ::TSP::Size& BezierPathSourceArchive::_internal_naturalsize() const {
  const ::TSP::Size* p = naturalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& BezierPathSourceArchive::naturalsize() const {
  // @@protoc_insertion_point(field_get:TSD.BezierPathSourceArchive.naturalSize)
  return _internal_naturalsize();
}
inline void BezierPathSourceArchive::unsafe_arena_set_allocated_naturalsize(
    ::TSP::Size* naturalsize) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize_);
  }
  naturalsize_ = naturalsize;
  if (naturalsize) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.BezierPathSourceArchive.naturalSize)
}
inline ::TSP::Size* BezierPathSourceArchive::release_naturalsize() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* BezierPathSourceArchive::unsafe_arena_release_naturalsize() {
  // @@protoc_insertion_point(field_release:TSD.BezierPathSourceArchive.naturalSize)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* BezierPathSourceArchive::_internal_mutable_naturalsize() {
  _has_bits_[0] |= 0x00000002u;
  if (naturalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    naturalsize_ = p;
  }
  return naturalsize_;
}
inline ::TSP::Size* BezierPathSourceArchive::mutable_naturalsize() {
  // @@protoc_insertion_point(field_mutable:TSD.BezierPathSourceArchive.naturalSize)
  return _internal_mutable_naturalsize();
}
inline void BezierPathSourceArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize_);
  }
  if (naturalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize)->GetArena();
    if (message_arena != submessage_arena) {
      naturalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, naturalsize, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  naturalsize_ = naturalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.BezierPathSourceArchive.naturalSize)
}

// optional .TSP.Path path = 3;
inline bool BezierPathSourceArchive::_internal_has_path() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || path_ != nullptr);
  return value;
}
inline bool BezierPathSourceArchive::has_path() const {
  return _internal_has_path();
}
inline const ::TSP::Path& BezierPathSourceArchive::_internal_path() const {
  const ::TSP::Path* p = path_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Path&>(
      ::TSP::_Path_default_instance_);
}
inline const ::TSP::Path& BezierPathSourceArchive::path() const {
  // @@protoc_insertion_point(field_get:TSD.BezierPathSourceArchive.path)
  return _internal_path();
}
inline void BezierPathSourceArchive::unsafe_arena_set_allocated_path(
    ::TSP::Path* path) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path_);
  }
  path_ = path;
  if (path) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.BezierPathSourceArchive.path)
}
inline ::TSP::Path* BezierPathSourceArchive::release_path() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Path* temp = path_;
  path_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Path* BezierPathSourceArchive::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:TSD.BezierPathSourceArchive.path)
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Path* temp = path_;
  path_ = nullptr;
  return temp;
}
inline ::TSP::Path* BezierPathSourceArchive::_internal_mutable_path() {
  _has_bits_[0] |= 0x00000004u;
  if (path_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Path>(GetArena());
    path_ = p;
  }
  return path_;
}
inline ::TSP::Path* BezierPathSourceArchive::mutable_path() {
  // @@protoc_insertion_point(field_mutable:TSD.BezierPathSourceArchive.path)
  return _internal_mutable_path();
}
inline void BezierPathSourceArchive::set_allocated_path(::TSP::Path* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(path_);
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path)->GetArena();
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  path_ = path;
  // @@protoc_insertion_point(field_set_allocated:TSD.BezierPathSourceArchive.path)
}

// -------------------------------------------------------------------

// CalloutPathSourceArchive

// optional .TSP.Size natural_size = 1;
inline bool CalloutPathSourceArchive::_internal_has_natural_size() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || natural_size_ != nullptr);
  return value;
}
inline bool CalloutPathSourceArchive::has_natural_size() const {
  return _internal_has_natural_size();
}
inline const ::TSP::Size& CalloutPathSourceArchive::_internal_natural_size() const {
  const ::TSP::Size* p = natural_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& CalloutPathSourceArchive::natural_size() const {
  // @@protoc_insertion_point(field_get:TSD.CalloutPathSourceArchive.natural_size)
  return _internal_natural_size();
}
inline void CalloutPathSourceArchive::unsafe_arena_set_allocated_natural_size(
    ::TSP::Size* natural_size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(natural_size_);
  }
  natural_size_ = natural_size;
  if (natural_size) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.CalloutPathSourceArchive.natural_size)
}
inline ::TSP::Size* CalloutPathSourceArchive::release_natural_size() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Size* temp = natural_size_;
  natural_size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* CalloutPathSourceArchive::unsafe_arena_release_natural_size() {
  // @@protoc_insertion_point(field_release:TSD.CalloutPathSourceArchive.natural_size)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Size* temp = natural_size_;
  natural_size_ = nullptr;
  return temp;
}
inline ::TSP::Size* CalloutPathSourceArchive::_internal_mutable_natural_size() {
  _has_bits_[0] |= 0x00000001u;
  if (natural_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    natural_size_ = p;
  }
  return natural_size_;
}
inline ::TSP::Size* CalloutPathSourceArchive::mutable_natural_size() {
  // @@protoc_insertion_point(field_mutable:TSD.CalloutPathSourceArchive.natural_size)
  return _internal_mutable_natural_size();
}
inline void CalloutPathSourceArchive::set_allocated_natural_size(::TSP::Size* natural_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(natural_size_);
  }
  if (natural_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(natural_size)->GetArena();
    if (message_arena != submessage_arena) {
      natural_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, natural_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  natural_size_ = natural_size;
  // @@protoc_insertion_point(field_set_allocated:TSD.CalloutPathSourceArchive.natural_size)
}

// optional .TSP.Point tail_position = 2;
inline bool CalloutPathSourceArchive::_internal_has_tail_position() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || tail_position_ != nullptr);
  return value;
}
inline bool CalloutPathSourceArchive::has_tail_position() const {
  return _internal_has_tail_position();
}
inline const ::TSP::Point& CalloutPathSourceArchive::_internal_tail_position() const {
  const ::TSP::Point* p = tail_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& CalloutPathSourceArchive::tail_position() const {
  // @@protoc_insertion_point(field_get:TSD.CalloutPathSourceArchive.tail_position)
  return _internal_tail_position();
}
inline void CalloutPathSourceArchive::unsafe_arena_set_allocated_tail_position(
    ::TSP::Point* tail_position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tail_position_);
  }
  tail_position_ = tail_position;
  if (tail_position) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.CalloutPathSourceArchive.tail_position)
}
inline ::TSP::Point* CalloutPathSourceArchive::release_tail_position() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Point* temp = tail_position_;
  tail_position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Point* CalloutPathSourceArchive::unsafe_arena_release_tail_position() {
  // @@protoc_insertion_point(field_release:TSD.CalloutPathSourceArchive.tail_position)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Point* temp = tail_position_;
  tail_position_ = nullptr;
  return temp;
}
inline ::TSP::Point* CalloutPathSourceArchive::_internal_mutable_tail_position() {
  _has_bits_[0] |= 0x00000002u;
  if (tail_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArena());
    tail_position_ = p;
  }
  return tail_position_;
}
inline ::TSP::Point* CalloutPathSourceArchive::mutable_tail_position() {
  // @@protoc_insertion_point(field_mutable:TSD.CalloutPathSourceArchive.tail_position)
  return _internal_mutable_tail_position();
}
inline void CalloutPathSourceArchive::set_allocated_tail_position(::TSP::Point* tail_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tail_position_);
  }
  if (tail_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tail_position)->GetArena();
    if (message_arena != submessage_arena) {
      tail_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tail_position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tail_position_ = tail_position;
  // @@protoc_insertion_point(field_set_allocated:TSD.CalloutPathSourceArchive.tail_position)
}

// optional float tail_size = 3;
inline bool CalloutPathSourceArchive::_internal_has_tail_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CalloutPathSourceArchive::has_tail_size() const {
  return _internal_has_tail_size();
}
inline void CalloutPathSourceArchive::clear_tail_size() {
  tail_size_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float CalloutPathSourceArchive::_internal_tail_size() const {
  return tail_size_;
}
inline float CalloutPathSourceArchive::tail_size() const {
  // @@protoc_insertion_point(field_get:TSD.CalloutPathSourceArchive.tail_size)
  return _internal_tail_size();
}
inline void CalloutPathSourceArchive::_internal_set_tail_size(float value) {
  _has_bits_[0] |= 0x00000004u;
  tail_size_ = value;
}
inline void CalloutPathSourceArchive::set_tail_size(float value) {
  _internal_set_tail_size(value);
  // @@protoc_insertion_point(field_set:TSD.CalloutPathSourceArchive.tail_size)
}

// optional float corner_radius = 4;
inline bool CalloutPathSourceArchive::_internal_has_corner_radius() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CalloutPathSourceArchive::has_corner_radius() const {
  return _internal_has_corner_radius();
}
inline void CalloutPathSourceArchive::clear_corner_radius() {
  corner_radius_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float CalloutPathSourceArchive::_internal_corner_radius() const {
  return corner_radius_;
}
inline float CalloutPathSourceArchive::corner_radius() const {
  // @@protoc_insertion_point(field_get:TSD.CalloutPathSourceArchive.corner_radius)
  return _internal_corner_radius();
}
inline void CalloutPathSourceArchive::_internal_set_corner_radius(float value) {
  _has_bits_[0] |= 0x00000008u;
  corner_radius_ = value;
}
inline void CalloutPathSourceArchive::set_corner_radius(float value) {
  _internal_set_corner_radius(value);
  // @@protoc_insertion_point(field_set:TSD.CalloutPathSourceArchive.corner_radius)
}

// optional bool center_tail = 5;
inline bool CalloutPathSourceArchive::_internal_has_center_tail() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CalloutPathSourceArchive::has_center_tail() const {
  return _internal_has_center_tail();
}
inline void CalloutPathSourceArchive::clear_center_tail() {
  center_tail_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CalloutPathSourceArchive::_internal_center_tail() const {
  return center_tail_;
}
inline bool CalloutPathSourceArchive::center_tail() const {
  // @@protoc_insertion_point(field_get:TSD.CalloutPathSourceArchive.center_tail)
  return _internal_center_tail();
}
inline void CalloutPathSourceArchive::_internal_set_center_tail(bool value) {
  _has_bits_[0] |= 0x00000010u;
  center_tail_ = value;
}
inline void CalloutPathSourceArchive::set_center_tail(bool value) {
  _internal_set_center_tail(value);
  // @@protoc_insertion_point(field_set:TSD.CalloutPathSourceArchive.center_tail)
}

// -------------------------------------------------------------------

// ConnectionLinePathSourceArchive

// required .TSD.BezierPathSourceArchive super = 1;
inline bool ConnectionLinePathSourceArchive::_internal_has_super() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || super_ != nullptr);
  return value;
}
inline bool ConnectionLinePathSourceArchive::has_super() const {
  return _internal_has_super();
}
inline void ConnectionLinePathSourceArchive::clear_super() {
  if (super_ != nullptr) super_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::BezierPathSourceArchive& ConnectionLinePathSourceArchive::_internal_super() const {
  const ::TSD::BezierPathSourceArchive* p = super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::BezierPathSourceArchive&>(
      ::TSD::_BezierPathSourceArchive_default_instance_);
}
inline const ::TSD::BezierPathSourceArchive& ConnectionLinePathSourceArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLinePathSourceArchive.super)
  return _internal_super();
}
inline void ConnectionLinePathSourceArchive::unsafe_arena_set_allocated_super(
    ::TSD::BezierPathSourceArchive* super) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  super_ = super;
  if (super) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ConnectionLinePathSourceArchive.super)
}
inline ::TSD::BezierPathSourceArchive* ConnectionLinePathSourceArchive::release_super() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::BezierPathSourceArchive* temp = super_;
  super_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::BezierPathSourceArchive* ConnectionLinePathSourceArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.ConnectionLinePathSourceArchive.super)
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::BezierPathSourceArchive* temp = super_;
  super_ = nullptr;
  return temp;
}
inline ::TSD::BezierPathSourceArchive* ConnectionLinePathSourceArchive::_internal_mutable_super() {
  _has_bits_[0] |= 0x00000001u;
  if (super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::BezierPathSourceArchive>(GetArena());
    super_ = p;
  }
  return super_;
}
inline ::TSD::BezierPathSourceArchive* ConnectionLinePathSourceArchive::mutable_super() {
  // @@protoc_insertion_point(field_mutable:TSD.ConnectionLinePathSourceArchive.super)
  return _internal_mutable_super();
}
inline void ConnectionLinePathSourceArchive::set_allocated_super(::TSD::BezierPathSourceArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.ConnectionLinePathSourceArchive.super)
}

// optional .TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType type = 2;
inline bool ConnectionLinePathSourceArchive::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConnectionLinePathSourceArchive::has_type() const {
  return _internal_has_type();
}
inline void ConnectionLinePathSourceArchive::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive::_internal_type() const {
  return static_cast< ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType >(type_);
}
inline ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLinePathSourceArchive.type)
  return _internal_type();
}
inline void ConnectionLinePathSourceArchive::_internal_set_type(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType value) {
  assert(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void ConnectionLinePathSourceArchive::set_type(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.ConnectionLinePathSourceArchive.type)
}

// optional float outset_from = 3;
inline bool ConnectionLinePathSourceArchive::_internal_has_outset_from() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConnectionLinePathSourceArchive::has_outset_from() const {
  return _internal_has_outset_from();
}
inline void ConnectionLinePathSourceArchive::clear_outset_from() {
  outset_from_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ConnectionLinePathSourceArchive::_internal_outset_from() const {
  return outset_from_;
}
inline float ConnectionLinePathSourceArchive::outset_from() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLinePathSourceArchive.outset_from)
  return _internal_outset_from();
}
inline void ConnectionLinePathSourceArchive::_internal_set_outset_from(float value) {
  _has_bits_[0] |= 0x00000004u;
  outset_from_ = value;
}
inline void ConnectionLinePathSourceArchive::set_outset_from(float value) {
  _internal_set_outset_from(value);
  // @@protoc_insertion_point(field_set:TSD.ConnectionLinePathSourceArchive.outset_from)
}

// optional float outset_to = 4;
inline bool ConnectionLinePathSourceArchive::_internal_has_outset_to() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConnectionLinePathSourceArchive::has_outset_to() const {
  return _internal_has_outset_to();
}
inline void ConnectionLinePathSourceArchive::clear_outset_to() {
  outset_to_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float ConnectionLinePathSourceArchive::_internal_outset_to() const {
  return outset_to_;
}
inline float ConnectionLinePathSourceArchive::outset_to() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLinePathSourceArchive.outset_to)
  return _internal_outset_to();
}
inline void ConnectionLinePathSourceArchive::_internal_set_outset_to(float value) {
  _has_bits_[0] |= 0x00000008u;
  outset_to_ = value;
}
inline void ConnectionLinePathSourceArchive::set_outset_to(float value) {
  _internal_set_outset_to(value);
  // @@protoc_insertion_point(field_set:TSD.ConnectionLinePathSourceArchive.outset_to)
}

// -------------------------------------------------------------------

// EditableBezierPathSourceArchive_Node

// required .TSP.Point inControlPoint = 1;
inline bool EditableBezierPathSourceArchive_Node::_internal_has_incontrolpoint() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || incontrolpoint_ != nullptr);
  return value;
}
inline bool EditableBezierPathSourceArchive_Node::has_incontrolpoint() const {
  return _internal_has_incontrolpoint();
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::_internal_incontrolpoint() const {
  const ::TSP::Point* p = incontrolpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::incontrolpoint() const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.Node.inControlPoint)
  return _internal_incontrolpoint();
}
inline void EditableBezierPathSourceArchive_Node::unsafe_arena_set_allocated_incontrolpoint(
    ::TSP::Point* incontrolpoint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(incontrolpoint_);
  }
  incontrolpoint_ = incontrolpoint;
  if (incontrolpoint) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.EditableBezierPathSourceArchive.Node.inControlPoint)
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::release_incontrolpoint() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = incontrolpoint_;
  incontrolpoint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::unsafe_arena_release_incontrolpoint() {
  // @@protoc_insertion_point(field_release:TSD.EditableBezierPathSourceArchive.Node.inControlPoint)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = incontrolpoint_;
  incontrolpoint_ = nullptr;
  return temp;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::_internal_mutable_incontrolpoint() {
  _has_bits_[0] |= 0x00000001u;
  if (incontrolpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArena());
    incontrolpoint_ = p;
  }
  return incontrolpoint_;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::mutable_incontrolpoint() {
  // @@protoc_insertion_point(field_mutable:TSD.EditableBezierPathSourceArchive.Node.inControlPoint)
  return _internal_mutable_incontrolpoint();
}
inline void EditableBezierPathSourceArchive_Node::set_allocated_incontrolpoint(::TSP::Point* incontrolpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(incontrolpoint_);
  }
  if (incontrolpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(incontrolpoint)->GetArena();
    if (message_arena != submessage_arena) {
      incontrolpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, incontrolpoint, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  incontrolpoint_ = incontrolpoint;
  // @@protoc_insertion_point(field_set_allocated:TSD.EditableBezierPathSourceArchive.Node.inControlPoint)
}

// required .TSP.Point nodePoint = 2;
inline bool EditableBezierPathSourceArchive_Node::_internal_has_nodepoint() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || nodepoint_ != nullptr);
  return value;
}
inline bool EditableBezierPathSourceArchive_Node::has_nodepoint() const {
  return _internal_has_nodepoint();
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::_internal_nodepoint() const {
  const ::TSP::Point* p = nodepoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::nodepoint() const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.Node.nodePoint)
  return _internal_nodepoint();
}
inline void EditableBezierPathSourceArchive_Node::unsafe_arena_set_allocated_nodepoint(
    ::TSP::Point* nodepoint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodepoint_);
  }
  nodepoint_ = nodepoint;
  if (nodepoint) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.EditableBezierPathSourceArchive.Node.nodePoint)
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::release_nodepoint() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Point* temp = nodepoint_;
  nodepoint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::unsafe_arena_release_nodepoint() {
  // @@protoc_insertion_point(field_release:TSD.EditableBezierPathSourceArchive.Node.nodePoint)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Point* temp = nodepoint_;
  nodepoint_ = nullptr;
  return temp;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::_internal_mutable_nodepoint() {
  _has_bits_[0] |= 0x00000002u;
  if (nodepoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArena());
    nodepoint_ = p;
  }
  return nodepoint_;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::mutable_nodepoint() {
  // @@protoc_insertion_point(field_mutable:TSD.EditableBezierPathSourceArchive.Node.nodePoint)
  return _internal_mutable_nodepoint();
}
inline void EditableBezierPathSourceArchive_Node::set_allocated_nodepoint(::TSP::Point* nodepoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodepoint_);
  }
  if (nodepoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodepoint)->GetArena();
    if (message_arena != submessage_arena) {
      nodepoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodepoint, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nodepoint_ = nodepoint;
  // @@protoc_insertion_point(field_set_allocated:TSD.EditableBezierPathSourceArchive.Node.nodePoint)
}

// required .TSP.Point outControlPoint = 3;
inline bool EditableBezierPathSourceArchive_Node::_internal_has_outcontrolpoint() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || outcontrolpoint_ != nullptr);
  return value;
}
inline bool EditableBezierPathSourceArchive_Node::has_outcontrolpoint() const {
  return _internal_has_outcontrolpoint();
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::_internal_outcontrolpoint() const {
  const ::TSP::Point* p = outcontrolpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::outcontrolpoint() const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.Node.outControlPoint)
  return _internal_outcontrolpoint();
}
inline void EditableBezierPathSourceArchive_Node::unsafe_arena_set_allocated_outcontrolpoint(
    ::TSP::Point* outcontrolpoint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outcontrolpoint_);
  }
  outcontrolpoint_ = outcontrolpoint;
  if (outcontrolpoint) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.EditableBezierPathSourceArchive.Node.outControlPoint)
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::release_outcontrolpoint() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Point* temp = outcontrolpoint_;
  outcontrolpoint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::unsafe_arena_release_outcontrolpoint() {
  // @@protoc_insertion_point(field_release:TSD.EditableBezierPathSourceArchive.Node.outControlPoint)
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Point* temp = outcontrolpoint_;
  outcontrolpoint_ = nullptr;
  return temp;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::_internal_mutable_outcontrolpoint() {
  _has_bits_[0] |= 0x00000004u;
  if (outcontrolpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArena());
    outcontrolpoint_ = p;
  }
  return outcontrolpoint_;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::mutable_outcontrolpoint() {
  // @@protoc_insertion_point(field_mutable:TSD.EditableBezierPathSourceArchive.Node.outControlPoint)
  return _internal_mutable_outcontrolpoint();
}
inline void EditableBezierPathSourceArchive_Node::set_allocated_outcontrolpoint(::TSP::Point* outcontrolpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(outcontrolpoint_);
  }
  if (outcontrolpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outcontrolpoint)->GetArena();
    if (message_arena != submessage_arena) {
      outcontrolpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outcontrolpoint, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  outcontrolpoint_ = outcontrolpoint;
  // @@protoc_insertion_point(field_set_allocated:TSD.EditableBezierPathSourceArchive.Node.outControlPoint)
}

// required .TSD.EditableBezierPathSourceArchive.NodeType type = 4;
inline bool EditableBezierPathSourceArchive_Node::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EditableBezierPathSourceArchive_Node::has_type() const {
  return _internal_has_type();
}
inline void EditableBezierPathSourceArchive_Node::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::TSD::EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive_Node::_internal_type() const {
  return static_cast< ::TSD::EditableBezierPathSourceArchive_NodeType >(type_);
}
inline ::TSD::EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive_Node::type() const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.Node.type)
  return _internal_type();
}
inline void EditableBezierPathSourceArchive_Node::_internal_set_type(::TSD::EditableBezierPathSourceArchive_NodeType value) {
  assert(::TSD::EditableBezierPathSourceArchive_NodeType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void EditableBezierPathSourceArchive_Node::set_type(::TSD::EditableBezierPathSourceArchive_NodeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.EditableBezierPathSourceArchive.Node.type)
}

// -------------------------------------------------------------------

// EditableBezierPathSourceArchive_Subpath

// repeated .TSD.EditableBezierPathSourceArchive.Node nodes = 1;
inline int EditableBezierPathSourceArchive_Subpath::_internal_nodes_size() const {
  return nodes_.size();
}
inline int EditableBezierPathSourceArchive_Subpath::nodes_size() const {
  return _internal_nodes_size();
}
inline void EditableBezierPathSourceArchive_Subpath::clear_nodes() {
  nodes_.Clear();
}
inline ::TSD::EditableBezierPathSourceArchive_Node* EditableBezierPathSourceArchive_Subpath::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.EditableBezierPathSourceArchive.Subpath.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node >*
EditableBezierPathSourceArchive_Subpath::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:TSD.EditableBezierPathSourceArchive.Subpath.nodes)
  return &nodes_;
}
inline const ::TSD::EditableBezierPathSourceArchive_Node& EditableBezierPathSourceArchive_Subpath::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::TSD::EditableBezierPathSourceArchive_Node& EditableBezierPathSourceArchive_Subpath::nodes(int index) const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.Subpath.nodes)
  return _internal_nodes(index);
}
inline ::TSD::EditableBezierPathSourceArchive_Node* EditableBezierPathSourceArchive_Subpath::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::TSD::EditableBezierPathSourceArchive_Node* EditableBezierPathSourceArchive_Subpath::add_nodes() {
  // @@protoc_insertion_point(field_add:TSD.EditableBezierPathSourceArchive.Subpath.nodes)
  return _internal_add_nodes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node >&
EditableBezierPathSourceArchive_Subpath::nodes() const {
  // @@protoc_insertion_point(field_list:TSD.EditableBezierPathSourceArchive.Subpath.nodes)
  return nodes_;
}

// required bool closed = 2;
inline bool EditableBezierPathSourceArchive_Subpath::_internal_has_closed() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EditableBezierPathSourceArchive_Subpath::has_closed() const {
  return _internal_has_closed();
}
inline void EditableBezierPathSourceArchive_Subpath::clear_closed() {
  closed_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool EditableBezierPathSourceArchive_Subpath::_internal_closed() const {
  return closed_;
}
inline bool EditableBezierPathSourceArchive_Subpath::closed() const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.Subpath.closed)
  return _internal_closed();
}
inline void EditableBezierPathSourceArchive_Subpath::_internal_set_closed(bool value) {
  _has_bits_[0] |= 0x00000001u;
  closed_ = value;
}
inline void EditableBezierPathSourceArchive_Subpath::set_closed(bool value) {
  _internal_set_closed(value);
  // @@protoc_insertion_point(field_set:TSD.EditableBezierPathSourceArchive.Subpath.closed)
}

// -------------------------------------------------------------------

// EditableBezierPathSourceArchive

// repeated .TSD.EditableBezierPathSourceArchive.Subpath subpaths = 1;
inline int EditableBezierPathSourceArchive::_internal_subpaths_size() const {
  return subpaths_.size();
}
inline int EditableBezierPathSourceArchive::subpaths_size() const {
  return _internal_subpaths_size();
}
inline void EditableBezierPathSourceArchive::clear_subpaths() {
  subpaths_.Clear();
}
inline ::TSD::EditableBezierPathSourceArchive_Subpath* EditableBezierPathSourceArchive::mutable_subpaths(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.EditableBezierPathSourceArchive.subpaths)
  return subpaths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath >*
EditableBezierPathSourceArchive::mutable_subpaths() {
  // @@protoc_insertion_point(field_mutable_list:TSD.EditableBezierPathSourceArchive.subpaths)
  return &subpaths_;
}
inline const ::TSD::EditableBezierPathSourceArchive_Subpath& EditableBezierPathSourceArchive::_internal_subpaths(int index) const {
  return subpaths_.Get(index);
}
inline const ::TSD::EditableBezierPathSourceArchive_Subpath& EditableBezierPathSourceArchive::subpaths(int index) const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.subpaths)
  return _internal_subpaths(index);
}
inline ::TSD::EditableBezierPathSourceArchive_Subpath* EditableBezierPathSourceArchive::_internal_add_subpaths() {
  return subpaths_.Add();
}
inline ::TSD::EditableBezierPathSourceArchive_Subpath* EditableBezierPathSourceArchive::add_subpaths() {
  // @@protoc_insertion_point(field_add:TSD.EditableBezierPathSourceArchive.subpaths)
  return _internal_add_subpaths();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath >&
EditableBezierPathSourceArchive::subpaths() const {
  // @@protoc_insertion_point(field_list:TSD.EditableBezierPathSourceArchive.subpaths)
  return subpaths_;
}

// optional .TSP.Size naturalSize = 2;
inline bool EditableBezierPathSourceArchive::_internal_has_naturalsize() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || naturalsize_ != nullptr);
  return value;
}
inline bool EditableBezierPathSourceArchive::has_naturalsize() const {
  return _internal_has_naturalsize();
}
inline const ::TSP::Size& EditableBezierPathSourceArchive::_internal_naturalsize() const {
  const ::TSP::Size* p = naturalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& EditableBezierPathSourceArchive::naturalsize() const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.naturalSize)
  return _internal_naturalsize();
}
inline void EditableBezierPathSourceArchive::unsafe_arena_set_allocated_naturalsize(
    ::TSP::Size* naturalsize) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize_);
  }
  naturalsize_ = naturalsize;
  if (naturalsize) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.EditableBezierPathSourceArchive.naturalSize)
}
inline ::TSP::Size* EditableBezierPathSourceArchive::release_naturalsize() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* EditableBezierPathSourceArchive::unsafe_arena_release_naturalsize() {
  // @@protoc_insertion_point(field_release:TSD.EditableBezierPathSourceArchive.naturalSize)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* EditableBezierPathSourceArchive::_internal_mutable_naturalsize() {
  _has_bits_[0] |= 0x00000001u;
  if (naturalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    naturalsize_ = p;
  }
  return naturalsize_;
}
inline ::TSP::Size* EditableBezierPathSourceArchive::mutable_naturalsize() {
  // @@protoc_insertion_point(field_mutable:TSD.EditableBezierPathSourceArchive.naturalSize)
  return _internal_mutable_naturalsize();
}
inline void EditableBezierPathSourceArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize_);
  }
  if (naturalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize)->GetArena();
    if (message_arena != submessage_arena) {
      naturalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, naturalsize, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  naturalsize_ = naturalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.EditableBezierPathSourceArchive.naturalSize)
}

// -------------------------------------------------------------------

// PathSourceArchive

// optional bool horizontalFlip = 1;
inline bool PathSourceArchive::_internal_has_horizontalflip() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PathSourceArchive::has_horizontalflip() const {
  return _internal_has_horizontalflip();
}
inline void PathSourceArchive::clear_horizontalflip() {
  horizontalflip_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool PathSourceArchive::_internal_horizontalflip() const {
  return horizontalflip_;
}
inline bool PathSourceArchive::horizontalflip() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.horizontalFlip)
  return _internal_horizontalflip();
}
inline void PathSourceArchive::_internal_set_horizontalflip(bool value) {
  _has_bits_[0] |= 0x00000100u;
  horizontalflip_ = value;
}
inline void PathSourceArchive::set_horizontalflip(bool value) {
  _internal_set_horizontalflip(value);
  // @@protoc_insertion_point(field_set:TSD.PathSourceArchive.horizontalFlip)
}

// optional bool verticalFlip = 2;
inline bool PathSourceArchive::_internal_has_verticalflip() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool PathSourceArchive::has_verticalflip() const {
  return _internal_has_verticalflip();
}
inline void PathSourceArchive::clear_verticalflip() {
  verticalflip_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool PathSourceArchive::_internal_verticalflip() const {
  return verticalflip_;
}
inline bool PathSourceArchive::verticalflip() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.verticalFlip)
  return _internal_verticalflip();
}
inline void PathSourceArchive::_internal_set_verticalflip(bool value) {
  _has_bits_[0] |= 0x00000200u;
  verticalflip_ = value;
}
inline void PathSourceArchive::set_verticalflip(bool value) {
  _internal_set_verticalflip(value);
  // @@protoc_insertion_point(field_set:TSD.PathSourceArchive.verticalFlip)
}

// optional .TSD.PointPathSourceArchive point_path_source = 3;
inline bool PathSourceArchive::_internal_has_point_path_source() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || point_path_source_ != nullptr);
  return value;
}
inline bool PathSourceArchive::has_point_path_source() const {
  return _internal_has_point_path_source();
}
inline void PathSourceArchive::clear_point_path_source() {
  if (point_path_source_ != nullptr) point_path_source_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::PointPathSourceArchive& PathSourceArchive::_internal_point_path_source() const {
  const ::TSD::PointPathSourceArchive* p = point_path_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::PointPathSourceArchive&>(
      ::TSD::_PointPathSourceArchive_default_instance_);
}
inline const ::TSD::PointPathSourceArchive& PathSourceArchive::point_path_source() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.point_path_source)
  return _internal_point_path_source();
}
inline void PathSourceArchive::unsafe_arena_set_allocated_point_path_source(
    ::TSD::PointPathSourceArchive* point_path_source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_path_source_);
  }
  point_path_source_ = point_path_source;
  if (point_path_source) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PathSourceArchive.point_path_source)
}
inline ::TSD::PointPathSourceArchive* PathSourceArchive::release_point_path_source() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::PointPathSourceArchive* temp = point_path_source_;
  point_path_source_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::PointPathSourceArchive* PathSourceArchive::unsafe_arena_release_point_path_source() {
  // @@protoc_insertion_point(field_release:TSD.PathSourceArchive.point_path_source)
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::PointPathSourceArchive* temp = point_path_source_;
  point_path_source_ = nullptr;
  return temp;
}
inline ::TSD::PointPathSourceArchive* PathSourceArchive::_internal_mutable_point_path_source() {
  _has_bits_[0] |= 0x00000004u;
  if (point_path_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::PointPathSourceArchive>(GetArena());
    point_path_source_ = p;
  }
  return point_path_source_;
}
inline ::TSD::PointPathSourceArchive* PathSourceArchive::mutable_point_path_source() {
  // @@protoc_insertion_point(field_mutable:TSD.PathSourceArchive.point_path_source)
  return _internal_mutable_point_path_source();
}
inline void PathSourceArchive::set_allocated_point_path_source(::TSD::PointPathSourceArchive* point_path_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete point_path_source_;
  }
  if (point_path_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(point_path_source);
    if (message_arena != submessage_arena) {
      point_path_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_path_source, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  point_path_source_ = point_path_source;
  // @@protoc_insertion_point(field_set_allocated:TSD.PathSourceArchive.point_path_source)
}

// optional .TSD.ScalarPathSourceArchive scalar_path_source = 4;
inline bool PathSourceArchive::_internal_has_scalar_path_source() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || scalar_path_source_ != nullptr);
  return value;
}
inline bool PathSourceArchive::has_scalar_path_source() const {
  return _internal_has_scalar_path_source();
}
inline void PathSourceArchive::clear_scalar_path_source() {
  if (scalar_path_source_ != nullptr) scalar_path_source_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::TSD::ScalarPathSourceArchive& PathSourceArchive::_internal_scalar_path_source() const {
  const ::TSD::ScalarPathSourceArchive* p = scalar_path_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ScalarPathSourceArchive&>(
      ::TSD::_ScalarPathSourceArchive_default_instance_);
}
inline const ::TSD::ScalarPathSourceArchive& PathSourceArchive::scalar_path_source() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.scalar_path_source)
  return _internal_scalar_path_source();
}
inline void PathSourceArchive::unsafe_arena_set_allocated_scalar_path_source(
    ::TSD::ScalarPathSourceArchive* scalar_path_source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scalar_path_source_);
  }
  scalar_path_source_ = scalar_path_source;
  if (scalar_path_source) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PathSourceArchive.scalar_path_source)
}
inline ::TSD::ScalarPathSourceArchive* PathSourceArchive::release_scalar_path_source() {
  _has_bits_[0] &= ~0x00000008u;
  ::TSD::ScalarPathSourceArchive* temp = scalar_path_source_;
  scalar_path_source_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::ScalarPathSourceArchive* PathSourceArchive::unsafe_arena_release_scalar_path_source() {
  // @@protoc_insertion_point(field_release:TSD.PathSourceArchive.scalar_path_source)
  _has_bits_[0] &= ~0x00000008u;
  ::TSD::ScalarPathSourceArchive* temp = scalar_path_source_;
  scalar_path_source_ = nullptr;
  return temp;
}
inline ::TSD::ScalarPathSourceArchive* PathSourceArchive::_internal_mutable_scalar_path_source() {
  _has_bits_[0] |= 0x00000008u;
  if (scalar_path_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ScalarPathSourceArchive>(GetArena());
    scalar_path_source_ = p;
  }
  return scalar_path_source_;
}
inline ::TSD::ScalarPathSourceArchive* PathSourceArchive::mutable_scalar_path_source() {
  // @@protoc_insertion_point(field_mutable:TSD.PathSourceArchive.scalar_path_source)
  return _internal_mutable_scalar_path_source();
}
inline void PathSourceArchive::set_allocated_scalar_path_source(::TSD::ScalarPathSourceArchive* scalar_path_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete scalar_path_source_;
  }
  if (scalar_path_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(scalar_path_source);
    if (message_arena != submessage_arena) {
      scalar_path_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scalar_path_source, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  scalar_path_source_ = scalar_path_source;
  // @@protoc_insertion_point(field_set_allocated:TSD.PathSourceArchive.scalar_path_source)
}

// optional .TSD.BezierPathSourceArchive bezier_path_source = 5;
inline bool PathSourceArchive::_internal_has_bezier_path_source() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || bezier_path_source_ != nullptr);
  return value;
}
inline bool PathSourceArchive::has_bezier_path_source() const {
  return _internal_has_bezier_path_source();
}
inline void PathSourceArchive::clear_bezier_path_source() {
  if (bezier_path_source_ != nullptr) bezier_path_source_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::TSD::BezierPathSourceArchive& PathSourceArchive::_internal_bezier_path_source() const {
  const ::TSD::BezierPathSourceArchive* p = bezier_path_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::BezierPathSourceArchive&>(
      ::TSD::_BezierPathSourceArchive_default_instance_);
}
inline const ::TSD::BezierPathSourceArchive& PathSourceArchive::bezier_path_source() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.bezier_path_source)
  return _internal_bezier_path_source();
}
inline void PathSourceArchive::unsafe_arena_set_allocated_bezier_path_source(
    ::TSD::BezierPathSourceArchive* bezier_path_source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bezier_path_source_);
  }
  bezier_path_source_ = bezier_path_source;
  if (bezier_path_source) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PathSourceArchive.bezier_path_source)
}
inline ::TSD::BezierPathSourceArchive* PathSourceArchive::release_bezier_path_source() {
  _has_bits_[0] &= ~0x00000010u;
  ::TSD::BezierPathSourceArchive* temp = bezier_path_source_;
  bezier_path_source_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::BezierPathSourceArchive* PathSourceArchive::unsafe_arena_release_bezier_path_source() {
  // @@protoc_insertion_point(field_release:TSD.PathSourceArchive.bezier_path_source)
  _has_bits_[0] &= ~0x00000010u;
  ::TSD::BezierPathSourceArchive* temp = bezier_path_source_;
  bezier_path_source_ = nullptr;
  return temp;
}
inline ::TSD::BezierPathSourceArchive* PathSourceArchive::_internal_mutable_bezier_path_source() {
  _has_bits_[0] |= 0x00000010u;
  if (bezier_path_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::BezierPathSourceArchive>(GetArena());
    bezier_path_source_ = p;
  }
  return bezier_path_source_;
}
inline ::TSD::BezierPathSourceArchive* PathSourceArchive::mutable_bezier_path_source() {
  // @@protoc_insertion_point(field_mutable:TSD.PathSourceArchive.bezier_path_source)
  return _internal_mutable_bezier_path_source();
}
inline void PathSourceArchive::set_allocated_bezier_path_source(::TSD::BezierPathSourceArchive* bezier_path_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bezier_path_source_;
  }
  if (bezier_path_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bezier_path_source);
    if (message_arena != submessage_arena) {
      bezier_path_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bezier_path_source, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  bezier_path_source_ = bezier_path_source;
  // @@protoc_insertion_point(field_set_allocated:TSD.PathSourceArchive.bezier_path_source)
}

// optional .TSD.CalloutPathSourceArchive callout_path_source = 6;
inline bool PathSourceArchive::_internal_has_callout_path_source() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || callout_path_source_ != nullptr);
  return value;
}
inline bool PathSourceArchive::has_callout_path_source() const {
  return _internal_has_callout_path_source();
}
inline void PathSourceArchive::clear_callout_path_source() {
  if (callout_path_source_ != nullptr) callout_path_source_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::TSD::CalloutPathSourceArchive& PathSourceArchive::_internal_callout_path_source() const {
  const ::TSD::CalloutPathSourceArchive* p = callout_path_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::CalloutPathSourceArchive&>(
      ::TSD::_CalloutPathSourceArchive_default_instance_);
}
inline const ::TSD::CalloutPathSourceArchive& PathSourceArchive::callout_path_source() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.callout_path_source)
  return _internal_callout_path_source();
}
inline void PathSourceArchive::unsafe_arena_set_allocated_callout_path_source(
    ::TSD::CalloutPathSourceArchive* callout_path_source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(callout_path_source_);
  }
  callout_path_source_ = callout_path_source;
  if (callout_path_source) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PathSourceArchive.callout_path_source)
}
inline ::TSD::CalloutPathSourceArchive* PathSourceArchive::release_callout_path_source() {
  _has_bits_[0] &= ~0x00000020u;
  ::TSD::CalloutPathSourceArchive* temp = callout_path_source_;
  callout_path_source_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::CalloutPathSourceArchive* PathSourceArchive::unsafe_arena_release_callout_path_source() {
  // @@protoc_insertion_point(field_release:TSD.PathSourceArchive.callout_path_source)
  _has_bits_[0] &= ~0x00000020u;
  ::TSD::CalloutPathSourceArchive* temp = callout_path_source_;
  callout_path_source_ = nullptr;
  return temp;
}
inline ::TSD::CalloutPathSourceArchive* PathSourceArchive::_internal_mutable_callout_path_source() {
  _has_bits_[0] |= 0x00000020u;
  if (callout_path_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::CalloutPathSourceArchive>(GetArena());
    callout_path_source_ = p;
  }
  return callout_path_source_;
}
inline ::TSD::CalloutPathSourceArchive* PathSourceArchive::mutable_callout_path_source() {
  // @@protoc_insertion_point(field_mutable:TSD.PathSourceArchive.callout_path_source)
  return _internal_mutable_callout_path_source();
}
inline void PathSourceArchive::set_allocated_callout_path_source(::TSD::CalloutPathSourceArchive* callout_path_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete callout_path_source_;
  }
  if (callout_path_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(callout_path_source);
    if (message_arena != submessage_arena) {
      callout_path_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, callout_path_source, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  callout_path_source_ = callout_path_source;
  // @@protoc_insertion_point(field_set_allocated:TSD.PathSourceArchive.callout_path_source)
}

// optional .TSD.ConnectionLinePathSourceArchive connection_line_path_source = 7;
inline bool PathSourceArchive::_internal_has_connection_line_path_source() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || connection_line_path_source_ != nullptr);
  return value;
}
inline bool PathSourceArchive::has_connection_line_path_source() const {
  return _internal_has_connection_line_path_source();
}
inline void PathSourceArchive::clear_connection_line_path_source() {
  if (connection_line_path_source_ != nullptr) connection_line_path_source_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::TSD::ConnectionLinePathSourceArchive& PathSourceArchive::_internal_connection_line_path_source() const {
  const ::TSD::ConnectionLinePathSourceArchive* p = connection_line_path_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ConnectionLinePathSourceArchive&>(
      ::TSD::_ConnectionLinePathSourceArchive_default_instance_);
}
inline const ::TSD::ConnectionLinePathSourceArchive& PathSourceArchive::connection_line_path_source() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.connection_line_path_source)
  return _internal_connection_line_path_source();
}
inline void PathSourceArchive::unsafe_arena_set_allocated_connection_line_path_source(
    ::TSD::ConnectionLinePathSourceArchive* connection_line_path_source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_line_path_source_);
  }
  connection_line_path_source_ = connection_line_path_source;
  if (connection_line_path_source) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PathSourceArchive.connection_line_path_source)
}
inline ::TSD::ConnectionLinePathSourceArchive* PathSourceArchive::release_connection_line_path_source() {
  _has_bits_[0] &= ~0x00000040u;
  ::TSD::ConnectionLinePathSourceArchive* temp = connection_line_path_source_;
  connection_line_path_source_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::ConnectionLinePathSourceArchive* PathSourceArchive::unsafe_arena_release_connection_line_path_source() {
  // @@protoc_insertion_point(field_release:TSD.PathSourceArchive.connection_line_path_source)
  _has_bits_[0] &= ~0x00000040u;
  ::TSD::ConnectionLinePathSourceArchive* temp = connection_line_path_source_;
  connection_line_path_source_ = nullptr;
  return temp;
}
inline ::TSD::ConnectionLinePathSourceArchive* PathSourceArchive::_internal_mutable_connection_line_path_source() {
  _has_bits_[0] |= 0x00000040u;
  if (connection_line_path_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ConnectionLinePathSourceArchive>(GetArena());
    connection_line_path_source_ = p;
  }
  return connection_line_path_source_;
}
inline ::TSD::ConnectionLinePathSourceArchive* PathSourceArchive::mutable_connection_line_path_source() {
  // @@protoc_insertion_point(field_mutable:TSD.PathSourceArchive.connection_line_path_source)
  return _internal_mutable_connection_line_path_source();
}
inline void PathSourceArchive::set_allocated_connection_line_path_source(::TSD::ConnectionLinePathSourceArchive* connection_line_path_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete connection_line_path_source_;
  }
  if (connection_line_path_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(connection_line_path_source);
    if (message_arena != submessage_arena) {
      connection_line_path_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_line_path_source, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  connection_line_path_source_ = connection_line_path_source;
  // @@protoc_insertion_point(field_set_allocated:TSD.PathSourceArchive.connection_line_path_source)
}

// optional .TSD.EditableBezierPathSourceArchive editable_bezier_path_source = 8;
inline bool PathSourceArchive::_internal_has_editable_bezier_path_source() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || editable_bezier_path_source_ != nullptr);
  return value;
}
inline bool PathSourceArchive::has_editable_bezier_path_source() const {
  return _internal_has_editable_bezier_path_source();
}
inline void PathSourceArchive::clear_editable_bezier_path_source() {
  if (editable_bezier_path_source_ != nullptr) editable_bezier_path_source_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::TSD::EditableBezierPathSourceArchive& PathSourceArchive::_internal_editable_bezier_path_source() const {
  const ::TSD::EditableBezierPathSourceArchive* p = editable_bezier_path_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::EditableBezierPathSourceArchive&>(
      ::TSD::_EditableBezierPathSourceArchive_default_instance_);
}
inline const ::TSD::EditableBezierPathSourceArchive& PathSourceArchive::editable_bezier_path_source() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.editable_bezier_path_source)
  return _internal_editable_bezier_path_source();
}
inline void PathSourceArchive::unsafe_arena_set_allocated_editable_bezier_path_source(
    ::TSD::EditableBezierPathSourceArchive* editable_bezier_path_source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(editable_bezier_path_source_);
  }
  editable_bezier_path_source_ = editable_bezier_path_source;
  if (editable_bezier_path_source) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PathSourceArchive.editable_bezier_path_source)
}
inline ::TSD::EditableBezierPathSourceArchive* PathSourceArchive::release_editable_bezier_path_source() {
  _has_bits_[0] &= ~0x00000080u;
  ::TSD::EditableBezierPathSourceArchive* temp = editable_bezier_path_source_;
  editable_bezier_path_source_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::EditableBezierPathSourceArchive* PathSourceArchive::unsafe_arena_release_editable_bezier_path_source() {
  // @@protoc_insertion_point(field_release:TSD.PathSourceArchive.editable_bezier_path_source)
  _has_bits_[0] &= ~0x00000080u;
  ::TSD::EditableBezierPathSourceArchive* temp = editable_bezier_path_source_;
  editable_bezier_path_source_ = nullptr;
  return temp;
}
inline ::TSD::EditableBezierPathSourceArchive* PathSourceArchive::_internal_mutable_editable_bezier_path_source() {
  _has_bits_[0] |= 0x00000080u;
  if (editable_bezier_path_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::EditableBezierPathSourceArchive>(GetArena());
    editable_bezier_path_source_ = p;
  }
  return editable_bezier_path_source_;
}
inline ::TSD::EditableBezierPathSourceArchive* PathSourceArchive::mutable_editable_bezier_path_source() {
  // @@protoc_insertion_point(field_mutable:TSD.PathSourceArchive.editable_bezier_path_source)
  return _internal_mutable_editable_bezier_path_source();
}
inline void PathSourceArchive::set_allocated_editable_bezier_path_source(::TSD::EditableBezierPathSourceArchive* editable_bezier_path_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete editable_bezier_path_source_;
  }
  if (editable_bezier_path_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(editable_bezier_path_source);
    if (message_arena != submessage_arena) {
      editable_bezier_path_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, editable_bezier_path_source, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  editable_bezier_path_source_ = editable_bezier_path_source;
  // @@protoc_insertion_point(field_set_allocated:TSD.PathSourceArchive.editable_bezier_path_source)
}

// optional string localizationKey = 9;
inline bool PathSourceArchive::_internal_has_localizationkey() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PathSourceArchive::has_localizationkey() const {
  return _internal_has_localizationkey();
}
inline void PathSourceArchive::clear_localizationkey() {
  localizationkey_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PathSourceArchive::localizationkey() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.localizationKey)
  return _internal_localizationkey();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void PathSourceArchive::set_localizationkey(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 localizationkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.PathSourceArchive.localizationKey)
}
inline std::string* PathSourceArchive::mutable_localizationkey() {
  // @@protoc_insertion_point(field_mutable:TSD.PathSourceArchive.localizationKey)
  return _internal_mutable_localizationkey();
}
inline const std::string& PathSourceArchive::_internal_localizationkey() const {
  return localizationkey_.Get();
}
inline void PathSourceArchive::_internal_set_localizationkey(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  localizationkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* PathSourceArchive::_internal_mutable_localizationkey() {
  _has_bits_[0] |= 0x00000001u;
  return localizationkey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PathSourceArchive::release_localizationkey() {
  // @@protoc_insertion_point(field_release:TSD.PathSourceArchive.localizationKey)
  if (!_internal_has_localizationkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return localizationkey_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PathSourceArchive::set_allocated_localizationkey(std::string* localizationkey) {
  if (localizationkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  localizationkey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), localizationkey,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.PathSourceArchive.localizationKey)
}

// optional string userDefinedName = 10;
inline bool PathSourceArchive::_internal_has_userdefinedname() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PathSourceArchive::has_userdefinedname() const {
  return _internal_has_userdefinedname();
}
inline void PathSourceArchive::clear_userdefinedname() {
  userdefinedname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PathSourceArchive::userdefinedname() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.userDefinedName)
  return _internal_userdefinedname();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void PathSourceArchive::set_userdefinedname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 userdefinedname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.PathSourceArchive.userDefinedName)
}
inline std::string* PathSourceArchive::mutable_userdefinedname() {
  // @@protoc_insertion_point(field_mutable:TSD.PathSourceArchive.userDefinedName)
  return _internal_mutable_userdefinedname();
}
inline const std::string& PathSourceArchive::_internal_userdefinedname() const {
  return userdefinedname_.Get();
}
inline void PathSourceArchive::_internal_set_userdefinedname(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  userdefinedname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* PathSourceArchive::_internal_mutable_userdefinedname() {
  _has_bits_[0] |= 0x00000002u;
  return userdefinedname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PathSourceArchive::release_userdefinedname() {
  // @@protoc_insertion_point(field_release:TSD.PathSourceArchive.userDefinedName)
  if (!_internal_has_userdefinedname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return userdefinedname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PathSourceArchive::set_allocated_userdefinedname(std::string* userdefinedname) {
  if (userdefinedname != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  userdefinedname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userdefinedname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.PathSourceArchive.userDefinedName)
}

// -------------------------------------------------------------------

// AngleGradientArchive

// optional float gradientangle = 2;
inline bool AngleGradientArchive::_internal_has_gradientangle() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AngleGradientArchive::has_gradientangle() const {
  return _internal_has_gradientangle();
}
inline void AngleGradientArchive::clear_gradientangle() {
  gradientangle_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float AngleGradientArchive::_internal_gradientangle() const {
  return gradientangle_;
}
inline float AngleGradientArchive::gradientangle() const {
  // @@protoc_insertion_point(field_get:TSD.AngleGradientArchive.gradientangle)
  return _internal_gradientangle();
}
inline void AngleGradientArchive::_internal_set_gradientangle(float value) {
  _has_bits_[0] |= 0x00000001u;
  gradientangle_ = value;
}
inline void AngleGradientArchive::set_gradientangle(float value) {
  _internal_set_gradientangle(value);
  // @@protoc_insertion_point(field_set:TSD.AngleGradientArchive.gradientangle)
}

// -------------------------------------------------------------------

// TransformGradientArchive

// optional .TSP.Point start = 1;
inline bool TransformGradientArchive::_internal_has_start() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || start_ != nullptr);
  return value;
}
inline bool TransformGradientArchive::has_start() const {
  return _internal_has_start();
}
inline const ::TSP::Point& TransformGradientArchive::_internal_start() const {
  const ::TSP::Point* p = start_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& TransformGradientArchive::start() const {
  // @@protoc_insertion_point(field_get:TSD.TransformGradientArchive.start)
  return _internal_start();
}
inline void TransformGradientArchive::unsafe_arena_set_allocated_start(
    ::TSP::Point* start) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  start_ = start;
  if (start) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.TransformGradientArchive.start)
}
inline ::TSP::Point* TransformGradientArchive::release_start() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = start_;
  start_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Point* TransformGradientArchive::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:TSD.TransformGradientArchive.start)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = start_;
  start_ = nullptr;
  return temp;
}
inline ::TSP::Point* TransformGradientArchive::_internal_mutable_start() {
  _has_bits_[0] |= 0x00000001u;
  if (start_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArena());
    start_ = p;
  }
  return start_;
}
inline ::TSP::Point* TransformGradientArchive::mutable_start() {
  // @@protoc_insertion_point(field_mutable:TSD.TransformGradientArchive.start)
  return _internal_mutable_start();
}
inline void TransformGradientArchive::set_allocated_start(::TSP::Point* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start)->GetArena();
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:TSD.TransformGradientArchive.start)
}

// optional .TSP.Point end = 2;
inline bool TransformGradientArchive::_internal_has_end() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || end_ != nullptr);
  return value;
}
inline bool TransformGradientArchive::has_end() const {
  return _internal_has_end();
}
inline const ::TSP::Point& TransformGradientArchive::_internal_end() const {
  const ::TSP::Point* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& TransformGradientArchive::end() const {
  // @@protoc_insertion_point(field_get:TSD.TransformGradientArchive.end)
  return _internal_end();
}
inline void TransformGradientArchive::unsafe_arena_set_allocated_end(
    ::TSP::Point* end) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.TransformGradientArchive.end)
}
inline ::TSP::Point* TransformGradientArchive::release_end() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Point* temp = end_;
  end_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Point* TransformGradientArchive::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:TSD.TransformGradientArchive.end)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Point* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::TSP::Point* TransformGradientArchive::_internal_mutable_end() {
  _has_bits_[0] |= 0x00000002u;
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArena());
    end_ = p;
  }
  return end_;
}
inline ::TSP::Point* TransformGradientArchive::mutable_end() {
  // @@protoc_insertion_point(field_mutable:TSD.TransformGradientArchive.end)
  return _internal_mutable_end();
}
inline void TransformGradientArchive::set_allocated_end(::TSP::Point* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end)->GetArena();
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:TSD.TransformGradientArchive.end)
}

// optional .TSP.Size baseNaturalSize = 3;
inline bool TransformGradientArchive::_internal_has_basenaturalsize() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || basenaturalsize_ != nullptr);
  return value;
}
inline bool TransformGradientArchive::has_basenaturalsize() const {
  return _internal_has_basenaturalsize();
}
inline const ::TSP::Size& TransformGradientArchive::_internal_basenaturalsize() const {
  const ::TSP::Size* p = basenaturalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& TransformGradientArchive::basenaturalsize() const {
  // @@protoc_insertion_point(field_get:TSD.TransformGradientArchive.baseNaturalSize)
  return _internal_basenaturalsize();
}
inline void TransformGradientArchive::unsafe_arena_set_allocated_basenaturalsize(
    ::TSP::Size* basenaturalsize) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(basenaturalsize_);
  }
  basenaturalsize_ = basenaturalsize;
  if (basenaturalsize) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.TransformGradientArchive.baseNaturalSize)
}
inline ::TSP::Size* TransformGradientArchive::release_basenaturalsize() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Size* temp = basenaturalsize_;
  basenaturalsize_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* TransformGradientArchive::unsafe_arena_release_basenaturalsize() {
  // @@protoc_insertion_point(field_release:TSD.TransformGradientArchive.baseNaturalSize)
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Size* temp = basenaturalsize_;
  basenaturalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* TransformGradientArchive::_internal_mutable_basenaturalsize() {
  _has_bits_[0] |= 0x00000004u;
  if (basenaturalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    basenaturalsize_ = p;
  }
  return basenaturalsize_;
}
inline ::TSP::Size* TransformGradientArchive::mutable_basenaturalsize() {
  // @@protoc_insertion_point(field_mutable:TSD.TransformGradientArchive.baseNaturalSize)
  return _internal_mutable_basenaturalsize();
}
inline void TransformGradientArchive::set_allocated_basenaturalsize(::TSP::Size* basenaturalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(basenaturalsize_);
  }
  if (basenaturalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(basenaturalsize)->GetArena();
    if (message_arena != submessage_arena) {
      basenaturalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basenaturalsize, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  basenaturalsize_ = basenaturalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.TransformGradientArchive.baseNaturalSize)
}

// -------------------------------------------------------------------

// GradientArchive_GradientStop

// optional .TSP.Color color = 1;
inline bool GradientArchive_GradientStop::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || color_ != nullptr);
  return value;
}
inline bool GradientArchive_GradientStop::has_color() const {
  return _internal_has_color();
}
inline const ::TSP::Color& GradientArchive_GradientStop::_internal_color() const {
  const ::TSP::Color* p = color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& GradientArchive_GradientStop::color() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.GradientStop.color)
  return _internal_color();
}
inline void GradientArchive_GradientStop::unsafe_arena_set_allocated_color(
    ::TSP::Color* color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  color_ = color;
  if (color) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.GradientArchive.GradientStop.color)
}
inline ::TSP::Color* GradientArchive_GradientStop::release_color() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* GradientArchive_GradientStop::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:TSD.GradientArchive.GradientStop.color)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::TSP::Color* GradientArchive_GradientStop::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000001u;
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    color_ = p;
  }
  return color_;
}
inline ::TSP::Color* GradientArchive_GradientStop::mutable_color() {
  // @@protoc_insertion_point(field_mutable:TSD.GradientArchive.GradientStop.color)
  return _internal_mutable_color();
}
inline void GradientArchive_GradientStop::set_allocated_color(::TSP::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color)->GetArena();
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:TSD.GradientArchive.GradientStop.color)
}

// optional float fraction = 2;
inline bool GradientArchive_GradientStop::_internal_has_fraction() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GradientArchive_GradientStop::has_fraction() const {
  return _internal_has_fraction();
}
inline void GradientArchive_GradientStop::clear_fraction() {
  fraction_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float GradientArchive_GradientStop::_internal_fraction() const {
  return fraction_;
}
inline float GradientArchive_GradientStop::fraction() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.GradientStop.fraction)
  return _internal_fraction();
}
inline void GradientArchive_GradientStop::_internal_set_fraction(float value) {
  _has_bits_[0] |= 0x00000002u;
  fraction_ = value;
}
inline void GradientArchive_GradientStop::set_fraction(float value) {
  _internal_set_fraction(value);
  // @@protoc_insertion_point(field_set:TSD.GradientArchive.GradientStop.fraction)
}

// optional float inflection = 3;
inline bool GradientArchive_GradientStop::_internal_has_inflection() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GradientArchive_GradientStop::has_inflection() const {
  return _internal_has_inflection();
}
inline void GradientArchive_GradientStop::clear_inflection() {
  inflection_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float GradientArchive_GradientStop::_internal_inflection() const {
  return inflection_;
}
inline float GradientArchive_GradientStop::inflection() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.GradientStop.inflection)
  return _internal_inflection();
}
inline void GradientArchive_GradientStop::_internal_set_inflection(float value) {
  _has_bits_[0] |= 0x00000004u;
  inflection_ = value;
}
inline void GradientArchive_GradientStop::set_inflection(float value) {
  _internal_set_inflection(value);
  // @@protoc_insertion_point(field_set:TSD.GradientArchive.GradientStop.inflection)
}

// -------------------------------------------------------------------

// GradientArchive

// optional .TSD.GradientArchive.GradientType type = 1;
inline bool GradientArchive::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GradientArchive::has_type() const {
  return _internal_has_type();
}
inline void GradientArchive::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::TSD::GradientArchive_GradientType GradientArchive::_internal_type() const {
  return static_cast< ::TSD::GradientArchive_GradientType >(type_);
}
inline ::TSD::GradientArchive_GradientType GradientArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.type)
  return _internal_type();
}
inline void GradientArchive::_internal_set_type(::TSD::GradientArchive_GradientType value) {
  assert(::TSD::GradientArchive_GradientType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void GradientArchive::set_type(::TSD::GradientArchive_GradientType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.GradientArchive.type)
}

// repeated .TSD.GradientArchive.GradientStop stops = 2;
inline int GradientArchive::_internal_stops_size() const {
  return stops_.size();
}
inline int GradientArchive::stops_size() const {
  return _internal_stops_size();
}
inline void GradientArchive::clear_stops() {
  stops_.Clear();
}
inline ::TSD::GradientArchive_GradientStop* GradientArchive::mutable_stops(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.GradientArchive.stops)
  return stops_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::GradientArchive_GradientStop >*
GradientArchive::mutable_stops() {
  // @@protoc_insertion_point(field_mutable_list:TSD.GradientArchive.stops)
  return &stops_;
}
inline const ::TSD::GradientArchive_GradientStop& GradientArchive::_internal_stops(int index) const {
  return stops_.Get(index);
}
inline const ::TSD::GradientArchive_GradientStop& GradientArchive::stops(int index) const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.stops)
  return _internal_stops(index);
}
inline ::TSD::GradientArchive_GradientStop* GradientArchive::_internal_add_stops() {
  return stops_.Add();
}
inline ::TSD::GradientArchive_GradientStop* GradientArchive::add_stops() {
  // @@protoc_insertion_point(field_add:TSD.GradientArchive.stops)
  return _internal_add_stops();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::GradientArchive_GradientStop >&
GradientArchive::stops() const {
  // @@protoc_insertion_point(field_list:TSD.GradientArchive.stops)
  return stops_;
}

// optional float opacity = 3;
inline bool GradientArchive::_internal_has_opacity() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GradientArchive::has_opacity() const {
  return _internal_has_opacity();
}
inline void GradientArchive::clear_opacity() {
  opacity_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float GradientArchive::_internal_opacity() const {
  return opacity_;
}
inline float GradientArchive::opacity() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.opacity)
  return _internal_opacity();
}
inline void GradientArchive::_internal_set_opacity(float value) {
  _has_bits_[0] |= 0x00000008u;
  opacity_ = value;
}
inline void GradientArchive::set_opacity(float value) {
  _internal_set_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.GradientArchive.opacity)
}

// optional bool advancedGradient = 4;
inline bool GradientArchive::_internal_has_advancedgradient() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GradientArchive::has_advancedgradient() const {
  return _internal_has_advancedgradient();
}
inline void GradientArchive::clear_advancedgradient() {
  advancedgradient_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool GradientArchive::_internal_advancedgradient() const {
  return advancedgradient_;
}
inline bool GradientArchive::advancedgradient() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.advancedGradient)
  return _internal_advancedgradient();
}
inline void GradientArchive::_internal_set_advancedgradient(bool value) {
  _has_bits_[0] |= 0x00000010u;
  advancedgradient_ = value;
}
inline void GradientArchive::set_advancedgradient(bool value) {
  _internal_set_advancedgradient(value);
  // @@protoc_insertion_point(field_set:TSD.GradientArchive.advancedGradient)
}

// optional .TSD.AngleGradientArchive anglegradient = 5;
inline bool GradientArchive::_internal_has_anglegradient() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || anglegradient_ != nullptr);
  return value;
}
inline bool GradientArchive::has_anglegradient() const {
  return _internal_has_anglegradient();
}
inline void GradientArchive::clear_anglegradient() {
  if (anglegradient_ != nullptr) anglegradient_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::AngleGradientArchive& GradientArchive::_internal_anglegradient() const {
  const ::TSD::AngleGradientArchive* p = anglegradient_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::AngleGradientArchive&>(
      ::TSD::_AngleGradientArchive_default_instance_);
}
inline const ::TSD::AngleGradientArchive& GradientArchive::anglegradient() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.anglegradient)
  return _internal_anglegradient();
}
inline void GradientArchive::unsafe_arena_set_allocated_anglegradient(
    ::TSD::AngleGradientArchive* anglegradient) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(anglegradient_);
  }
  anglegradient_ = anglegradient;
  if (anglegradient) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.GradientArchive.anglegradient)
}
inline ::TSD::AngleGradientArchive* GradientArchive::release_anglegradient() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::AngleGradientArchive* temp = anglegradient_;
  anglegradient_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::AngleGradientArchive* GradientArchive::unsafe_arena_release_anglegradient() {
  // @@protoc_insertion_point(field_release:TSD.GradientArchive.anglegradient)
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::AngleGradientArchive* temp = anglegradient_;
  anglegradient_ = nullptr;
  return temp;
}
inline ::TSD::AngleGradientArchive* GradientArchive::_internal_mutable_anglegradient() {
  _has_bits_[0] |= 0x00000001u;
  if (anglegradient_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::AngleGradientArchive>(GetArena());
    anglegradient_ = p;
  }
  return anglegradient_;
}
inline ::TSD::AngleGradientArchive* GradientArchive::mutable_anglegradient() {
  // @@protoc_insertion_point(field_mutable:TSD.GradientArchive.anglegradient)
  return _internal_mutable_anglegradient();
}
inline void GradientArchive::set_allocated_anglegradient(::TSD::AngleGradientArchive* anglegradient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete anglegradient_;
  }
  if (anglegradient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(anglegradient);
    if (message_arena != submessage_arena) {
      anglegradient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anglegradient, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  anglegradient_ = anglegradient;
  // @@protoc_insertion_point(field_set_allocated:TSD.GradientArchive.anglegradient)
}

// optional .TSD.TransformGradientArchive transformgradient = 6;
inline bool GradientArchive::_internal_has_transformgradient() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || transformgradient_ != nullptr);
  return value;
}
inline bool GradientArchive::has_transformgradient() const {
  return _internal_has_transformgradient();
}
inline void GradientArchive::clear_transformgradient() {
  if (transformgradient_ != nullptr) transformgradient_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::TransformGradientArchive& GradientArchive::_internal_transformgradient() const {
  const ::TSD::TransformGradientArchive* p = transformgradient_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::TransformGradientArchive&>(
      ::TSD::_TransformGradientArchive_default_instance_);
}
inline const ::TSD::TransformGradientArchive& GradientArchive::transformgradient() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.transformgradient)
  return _internal_transformgradient();
}
inline void GradientArchive::unsafe_arena_set_allocated_transformgradient(
    ::TSD::TransformGradientArchive* transformgradient) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transformgradient_);
  }
  transformgradient_ = transformgradient;
  if (transformgradient) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.GradientArchive.transformgradient)
}
inline ::TSD::TransformGradientArchive* GradientArchive::release_transformgradient() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::TransformGradientArchive* temp = transformgradient_;
  transformgradient_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::TransformGradientArchive* GradientArchive::unsafe_arena_release_transformgradient() {
  // @@protoc_insertion_point(field_release:TSD.GradientArchive.transformgradient)
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::TransformGradientArchive* temp = transformgradient_;
  transformgradient_ = nullptr;
  return temp;
}
inline ::TSD::TransformGradientArchive* GradientArchive::_internal_mutable_transformgradient() {
  _has_bits_[0] |= 0x00000002u;
  if (transformgradient_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::TransformGradientArchive>(GetArena());
    transformgradient_ = p;
  }
  return transformgradient_;
}
inline ::TSD::TransformGradientArchive* GradientArchive::mutable_transformgradient() {
  // @@protoc_insertion_point(field_mutable:TSD.GradientArchive.transformgradient)
  return _internal_mutable_transformgradient();
}
inline void GradientArchive::set_allocated_transformgradient(::TSD::TransformGradientArchive* transformgradient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete transformgradient_;
  }
  if (transformgradient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(transformgradient);
    if (message_arena != submessage_arena) {
      transformgradient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transformgradient, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  transformgradient_ = transformgradient;
  // @@protoc_insertion_point(field_set_allocated:TSD.GradientArchive.transformgradient)
}

// -------------------------------------------------------------------

// ImageFillArchive

// optional .TSP.DataReference imagedata = 6;
inline bool ImageFillArchive::_internal_has_imagedata() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || imagedata_ != nullptr);
  return value;
}
inline bool ImageFillArchive::has_imagedata() const {
  return _internal_has_imagedata();
}
inline const ::TSP::DataReference& ImageFillArchive::_internal_imagedata() const {
  const ::TSP::DataReference* p = imagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageFillArchive::imagedata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.imagedata)
  return _internal_imagedata();
}
inline void ImageFillArchive::unsafe_arena_set_allocated_imagedata(
    ::TSP::DataReference* imagedata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(imagedata_);
  }
  imagedata_ = imagedata;
  if (imagedata) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageFillArchive.imagedata)
}
inline ::TSP::DataReference* ImageFillArchive::release_imagedata() {
  _has_bits_[0] &= ~0x00000010u;
  ::TSP::DataReference* temp = imagedata_;
  imagedata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* ImageFillArchive::unsafe_arena_release_imagedata() {
  // @@protoc_insertion_point(field_release:TSD.ImageFillArchive.imagedata)
  _has_bits_[0] &= ~0x00000010u;
  ::TSP::DataReference* temp = imagedata_;
  imagedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageFillArchive::_internal_mutable_imagedata() {
  _has_bits_[0] |= 0x00000010u;
  if (imagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    imagedata_ = p;
  }
  return imagedata_;
}
inline ::TSP::DataReference* ImageFillArchive::mutable_imagedata() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageFillArchive.imagedata)
  return _internal_mutable_imagedata();
}
inline void ImageFillArchive::set_allocated_imagedata(::TSP::DataReference* imagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(imagedata_);
  }
  if (imagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(imagedata)->GetArena();
    if (message_arena != submessage_arena) {
      imagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imagedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  imagedata_ = imagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageFillArchive.imagedata)
}

// optional .TSD.ImageFillArchive.ImageFillTechnique technique = 2 [default = NaturalSize];
inline bool ImageFillArchive::_internal_has_technique() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ImageFillArchive::has_technique() const {
  return _internal_has_technique();
}
inline void ImageFillArchive::clear_technique() {
  technique_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::TSD::ImageFillArchive_ImageFillTechnique ImageFillArchive::_internal_technique() const {
  return static_cast< ::TSD::ImageFillArchive_ImageFillTechnique >(technique_);
}
inline ::TSD::ImageFillArchive_ImageFillTechnique ImageFillArchive::technique() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.technique)
  return _internal_technique();
}
inline void ImageFillArchive::_internal_set_technique(::TSD::ImageFillArchive_ImageFillTechnique value) {
  assert(::TSD::ImageFillArchive_ImageFillTechnique_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  technique_ = value;
}
inline void ImageFillArchive::set_technique(::TSD::ImageFillArchive_ImageFillTechnique value) {
  _internal_set_technique(value);
  // @@protoc_insertion_point(field_set:TSD.ImageFillArchive.technique)
}

// optional .TSP.Color tint = 3;
inline bool ImageFillArchive::_internal_has_tint() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || tint_ != nullptr);
  return value;
}
inline bool ImageFillArchive::has_tint() const {
  return _internal_has_tint();
}
inline const ::TSP::Color& ImageFillArchive::_internal_tint() const {
  const ::TSP::Color* p = tint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& ImageFillArchive::tint() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.tint)
  return _internal_tint();
}
inline void ImageFillArchive::unsafe_arena_set_allocated_tint(
    ::TSP::Color* tint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tint_);
  }
  tint_ = tint;
  if (tint) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageFillArchive.tint)
}
inline ::TSP::Color* ImageFillArchive::release_tint() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Color* temp = tint_;
  tint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* ImageFillArchive::unsafe_arena_release_tint() {
  // @@protoc_insertion_point(field_release:TSD.ImageFillArchive.tint)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Color* temp = tint_;
  tint_ = nullptr;
  return temp;
}
inline ::TSP::Color* ImageFillArchive::_internal_mutable_tint() {
  _has_bits_[0] |= 0x00000002u;
  if (tint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    tint_ = p;
  }
  return tint_;
}
inline ::TSP::Color* ImageFillArchive::mutable_tint() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageFillArchive.tint)
  return _internal_mutable_tint();
}
inline void ImageFillArchive::set_allocated_tint(::TSP::Color* tint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tint_);
  }
  if (tint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tint)->GetArena();
    if (message_arena != submessage_arena) {
      tint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tint, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tint_ = tint;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageFillArchive.tint)
}

// optional .TSP.Size fillsize = 4;
inline bool ImageFillArchive::_internal_has_fillsize() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || fillsize_ != nullptr);
  return value;
}
inline bool ImageFillArchive::has_fillsize() const {
  return _internal_has_fillsize();
}
inline const ::TSP::Size& ImageFillArchive::_internal_fillsize() const {
  const ::TSP::Size* p = fillsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& ImageFillArchive::fillsize() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.fillsize)
  return _internal_fillsize();
}
inline void ImageFillArchive::unsafe_arena_set_allocated_fillsize(
    ::TSP::Size* fillsize) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fillsize_);
  }
  fillsize_ = fillsize;
  if (fillsize) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageFillArchive.fillsize)
}
inline ::TSP::Size* ImageFillArchive::release_fillsize() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Size* temp = fillsize_;
  fillsize_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* ImageFillArchive::unsafe_arena_release_fillsize() {
  // @@protoc_insertion_point(field_release:TSD.ImageFillArchive.fillsize)
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Size* temp = fillsize_;
  fillsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* ImageFillArchive::_internal_mutable_fillsize() {
  _has_bits_[0] |= 0x00000004u;
  if (fillsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    fillsize_ = p;
  }
  return fillsize_;
}
inline ::TSP::Size* ImageFillArchive::mutable_fillsize() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageFillArchive.fillsize)
  return _internal_mutable_fillsize();
}
inline void ImageFillArchive::set_allocated_fillsize(::TSP::Size* fillsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fillsize_);
  }
  if (fillsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fillsize)->GetArena();
    if (message_arena != submessage_arena) {
      fillsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fillsize, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  fillsize_ = fillsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageFillArchive.fillsize)
}

// optional .TSP.DataReference originalimagedata = 7 [deprecated = true];
inline bool ImageFillArchive::_internal_has_originalimagedata() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || originalimagedata_ != nullptr);
  return value;
}
inline bool ImageFillArchive::has_originalimagedata() const {
  return _internal_has_originalimagedata();
}
inline const ::TSP::DataReference& ImageFillArchive::_internal_originalimagedata() const {
  const ::TSP::DataReference* p = originalimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageFillArchive::originalimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.originalimagedata)
  return _internal_originalimagedata();
}
inline void ImageFillArchive::unsafe_arena_set_allocated_originalimagedata(
    ::TSP::DataReference* originalimagedata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(originalimagedata_);
  }
  originalimagedata_ = originalimagedata;
  if (originalimagedata) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageFillArchive.originalimagedata)
}
inline ::TSP::DataReference* ImageFillArchive::release_originalimagedata() {
  _has_bits_[0] &= ~0x00000020u;
  ::TSP::DataReference* temp = originalimagedata_;
  originalimagedata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* ImageFillArchive::unsafe_arena_release_originalimagedata() {
  // @@protoc_insertion_point(field_release:TSD.ImageFillArchive.originalimagedata)
  _has_bits_[0] &= ~0x00000020u;
  ::TSP::DataReference* temp = originalimagedata_;
  originalimagedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageFillArchive::_internal_mutable_originalimagedata() {
  _has_bits_[0] |= 0x00000020u;
  if (originalimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    originalimagedata_ = p;
  }
  return originalimagedata_;
}
inline ::TSP::DataReference* ImageFillArchive::mutable_originalimagedata() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageFillArchive.originalimagedata)
  return _internal_mutable_originalimagedata();
}
inline void ImageFillArchive::set_allocated_originalimagedata(::TSP::DataReference* originalimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(originalimagedata_);
  }
  if (originalimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(originalimagedata)->GetArena();
    if (message_arena != submessage_arena) {
      originalimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, originalimagedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  originalimagedata_ = originalimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageFillArchive.originalimagedata)
}

// optional bool interpretsUntaggedImageDataAsGeneric = 8;
inline bool ImageFillArchive::_internal_has_interpretsuntaggedimagedataasgeneric() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ImageFillArchive::has_interpretsuntaggedimagedataasgeneric() const {
  return _internal_has_interpretsuntaggedimagedataasgeneric();
}
inline void ImageFillArchive::clear_interpretsuntaggedimagedataasgeneric() {
  interpretsuntaggedimagedataasgeneric_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ImageFillArchive::_internal_interpretsuntaggedimagedataasgeneric() const {
  return interpretsuntaggedimagedataasgeneric_;
}
inline bool ImageFillArchive::interpretsuntaggedimagedataasgeneric() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.interpretsUntaggedImageDataAsGeneric)
  return _internal_interpretsuntaggedimagedataasgeneric();
}
inline void ImageFillArchive::_internal_set_interpretsuntaggedimagedataasgeneric(bool value) {
  _has_bits_[0] |= 0x00000100u;
  interpretsuntaggedimagedataasgeneric_ = value;
}
inline void ImageFillArchive::set_interpretsuntaggedimagedataasgeneric(bool value) {
  _internal_set_interpretsuntaggedimagedataasgeneric(value);
  // @@protoc_insertion_point(field_set:TSD.ImageFillArchive.interpretsUntaggedImageDataAsGeneric)
}

// optional .TSP.Color referencecolor = 9;
inline bool ImageFillArchive::_internal_has_referencecolor() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || referencecolor_ != nullptr);
  return value;
}
inline bool ImageFillArchive::has_referencecolor() const {
  return _internal_has_referencecolor();
}
inline const ::TSP::Color& ImageFillArchive::_internal_referencecolor() const {
  const ::TSP::Color* p = referencecolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& ImageFillArchive::referencecolor() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.referencecolor)
  return _internal_referencecolor();
}
inline void ImageFillArchive::unsafe_arena_set_allocated_referencecolor(
    ::TSP::Color* referencecolor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(referencecolor_);
  }
  referencecolor_ = referencecolor;
  if (referencecolor) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageFillArchive.referencecolor)
}
inline ::TSP::Color* ImageFillArchive::release_referencecolor() {
  _has_bits_[0] &= ~0x00000040u;
  ::TSP::Color* temp = referencecolor_;
  referencecolor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* ImageFillArchive::unsafe_arena_release_referencecolor() {
  // @@protoc_insertion_point(field_release:TSD.ImageFillArchive.referencecolor)
  _has_bits_[0] &= ~0x00000040u;
  ::TSP::Color* temp = referencecolor_;
  referencecolor_ = nullptr;
  return temp;
}
inline ::TSP::Color* ImageFillArchive::_internal_mutable_referencecolor() {
  _has_bits_[0] |= 0x00000040u;
  if (referencecolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    referencecolor_ = p;
  }
  return referencecolor_;
}
inline ::TSP::Color* ImageFillArchive::mutable_referencecolor() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageFillArchive.referencecolor)
  return _internal_mutable_referencecolor();
}
inline void ImageFillArchive::set_allocated_referencecolor(::TSP::Color* referencecolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(referencecolor_);
  }
  if (referencecolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(referencecolor)->GetArena();
    if (message_arena != submessage_arena) {
      referencecolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, referencecolor, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  referencecolor_ = referencecolor;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageFillArchive.referencecolor)
}

// optional .TSP.Reference database_imagedata = 1;
inline bool ImageFillArchive::_internal_has_database_imagedata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || database_imagedata_ != nullptr);
  return value;
}
inline bool ImageFillArchive::has_database_imagedata() const {
  return _internal_has_database_imagedata();
}
inline const ::TSP::Reference& ImageFillArchive::_internal_database_imagedata() const {
  const ::TSP::Reference* p = database_imagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ImageFillArchive::database_imagedata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.database_imagedata)
  return _internal_database_imagedata();
}
inline void ImageFillArchive::unsafe_arena_set_allocated_database_imagedata(
    ::TSP::Reference* database_imagedata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_imagedata_);
  }
  database_imagedata_ = database_imagedata;
  if (database_imagedata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageFillArchive.database_imagedata)
}
inline ::TSP::Reference* ImageFillArchive::release_database_imagedata() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = database_imagedata_;
  database_imagedata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* ImageFillArchive::unsafe_arena_release_database_imagedata() {
  // @@protoc_insertion_point(field_release:TSD.ImageFillArchive.database_imagedata)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = database_imagedata_;
  database_imagedata_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ImageFillArchive::_internal_mutable_database_imagedata() {
  _has_bits_[0] |= 0x00000001u;
  if (database_imagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    database_imagedata_ = p;
  }
  return database_imagedata_;
}
inline ::TSP::Reference* ImageFillArchive::mutable_database_imagedata() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageFillArchive.database_imagedata)
  return _internal_mutable_database_imagedata();
}
inline void ImageFillArchive::set_allocated_database_imagedata(::TSP::Reference* database_imagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_imagedata_);
  }
  if (database_imagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_imagedata)->GetArena();
    if (message_arena != submessage_arena) {
      database_imagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_imagedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  database_imagedata_ = database_imagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageFillArchive.database_imagedata)
}

// optional .TSP.Reference database_originalimagedata = 5;
inline bool ImageFillArchive::_internal_has_database_originalimagedata() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || database_originalimagedata_ != nullptr);
  return value;
}
inline bool ImageFillArchive::has_database_originalimagedata() const {
  return _internal_has_database_originalimagedata();
}
inline const ::TSP::Reference& ImageFillArchive::_internal_database_originalimagedata() const {
  const ::TSP::Reference* p = database_originalimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ImageFillArchive::database_originalimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.database_originalimagedata)
  return _internal_database_originalimagedata();
}
inline void ImageFillArchive::unsafe_arena_set_allocated_database_originalimagedata(
    ::TSP::Reference* database_originalimagedata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_originalimagedata_);
  }
  database_originalimagedata_ = database_originalimagedata;
  if (database_originalimagedata) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageFillArchive.database_originalimagedata)
}
inline ::TSP::Reference* ImageFillArchive::release_database_originalimagedata() {
  _has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = database_originalimagedata_;
  database_originalimagedata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* ImageFillArchive::unsafe_arena_release_database_originalimagedata() {
  // @@protoc_insertion_point(field_release:TSD.ImageFillArchive.database_originalimagedata)
  _has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = database_originalimagedata_;
  database_originalimagedata_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ImageFillArchive::_internal_mutable_database_originalimagedata() {
  _has_bits_[0] |= 0x00000008u;
  if (database_originalimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    database_originalimagedata_ = p;
  }
  return database_originalimagedata_;
}
inline ::TSP::Reference* ImageFillArchive::mutable_database_originalimagedata() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageFillArchive.database_originalimagedata)
  return _internal_mutable_database_originalimagedata();
}
inline void ImageFillArchive::set_allocated_database_originalimagedata(::TSP::Reference* database_originalimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_originalimagedata_);
  }
  if (database_originalimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_originalimagedata)->GetArena();
    if (message_arena != submessage_arena) {
      database_originalimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_originalimagedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  database_originalimagedata_ = database_originalimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageFillArchive.database_originalimagedata)
}

// -------------------------------------------------------------------

// FillArchive

// optional .TSP.Color color = 1;
inline bool FillArchive::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || color_ != nullptr);
  return value;
}
inline bool FillArchive::has_color() const {
  return _internal_has_color();
}
inline const ::TSP::Color& FillArchive::_internal_color() const {
  const ::TSP::Color* p = color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& FillArchive::color() const {
  // @@protoc_insertion_point(field_get:TSD.FillArchive.color)
  return _internal_color();
}
inline void FillArchive::unsafe_arena_set_allocated_color(
    ::TSP::Color* color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  color_ = color;
  if (color) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.FillArchive.color)
}
inline ::TSP::Color* FillArchive::release_color() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* FillArchive::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:TSD.FillArchive.color)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::TSP::Color* FillArchive::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000001u;
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    color_ = p;
  }
  return color_;
}
inline ::TSP::Color* FillArchive::mutable_color() {
  // @@protoc_insertion_point(field_mutable:TSD.FillArchive.color)
  return _internal_mutable_color();
}
inline void FillArchive::set_allocated_color(::TSP::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color)->GetArena();
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:TSD.FillArchive.color)
}

// optional .TSD.GradientArchive gradient = 2;
inline bool FillArchive::_internal_has_gradient() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || gradient_ != nullptr);
  return value;
}
inline bool FillArchive::has_gradient() const {
  return _internal_has_gradient();
}
inline void FillArchive::clear_gradient() {
  if (gradient_ != nullptr) gradient_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::GradientArchive& FillArchive::_internal_gradient() const {
  const ::TSD::GradientArchive* p = gradient_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::GradientArchive&>(
      ::TSD::_GradientArchive_default_instance_);
}
inline const ::TSD::GradientArchive& FillArchive::gradient() const {
  // @@protoc_insertion_point(field_get:TSD.FillArchive.gradient)
  return _internal_gradient();
}
inline void FillArchive::unsafe_arena_set_allocated_gradient(
    ::TSD::GradientArchive* gradient) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gradient_);
  }
  gradient_ = gradient;
  if (gradient) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.FillArchive.gradient)
}
inline ::TSD::GradientArchive* FillArchive::release_gradient() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::GradientArchive* temp = gradient_;
  gradient_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::GradientArchive* FillArchive::unsafe_arena_release_gradient() {
  // @@protoc_insertion_point(field_release:TSD.FillArchive.gradient)
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::GradientArchive* temp = gradient_;
  gradient_ = nullptr;
  return temp;
}
inline ::TSD::GradientArchive* FillArchive::_internal_mutable_gradient() {
  _has_bits_[0] |= 0x00000002u;
  if (gradient_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::GradientArchive>(GetArena());
    gradient_ = p;
  }
  return gradient_;
}
inline ::TSD::GradientArchive* FillArchive::mutable_gradient() {
  // @@protoc_insertion_point(field_mutable:TSD.FillArchive.gradient)
  return _internal_mutable_gradient();
}
inline void FillArchive::set_allocated_gradient(::TSD::GradientArchive* gradient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete gradient_;
  }
  if (gradient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gradient);
    if (message_arena != submessage_arena) {
      gradient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gradient, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  gradient_ = gradient;
  // @@protoc_insertion_point(field_set_allocated:TSD.FillArchive.gradient)
}

// optional .TSD.ImageFillArchive image = 3;
inline bool FillArchive::_internal_has_image() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || image_ != nullptr);
  return value;
}
inline bool FillArchive::has_image() const {
  return _internal_has_image();
}
inline void FillArchive::clear_image() {
  if (image_ != nullptr) image_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::ImageFillArchive& FillArchive::_internal_image() const {
  const ::TSD::ImageFillArchive* p = image_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ImageFillArchive&>(
      ::TSD::_ImageFillArchive_default_instance_);
}
inline const ::TSD::ImageFillArchive& FillArchive::image() const {
  // @@protoc_insertion_point(field_get:TSD.FillArchive.image)
  return _internal_image();
}
inline void FillArchive::unsafe_arena_set_allocated_image(
    ::TSD::ImageFillArchive* image) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_);
  }
  image_ = image;
  if (image) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.FillArchive.image)
}
inline ::TSD::ImageFillArchive* FillArchive::release_image() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::ImageFillArchive* temp = image_;
  image_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::ImageFillArchive* FillArchive::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:TSD.FillArchive.image)
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::ImageFillArchive* temp = image_;
  image_ = nullptr;
  return temp;
}
inline ::TSD::ImageFillArchive* FillArchive::_internal_mutable_image() {
  _has_bits_[0] |= 0x00000004u;
  if (image_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ImageFillArchive>(GetArena());
    image_ = p;
  }
  return image_;
}
inline ::TSD::ImageFillArchive* FillArchive::mutable_image() {
  // @@protoc_insertion_point(field_mutable:TSD.FillArchive.image)
  return _internal_mutable_image();
}
inline void FillArchive::set_allocated_image(::TSD::ImageFillArchive* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:TSD.FillArchive.image)
}

// -------------------------------------------------------------------

// StrokePatternArchive

// optional .TSD.StrokePatternArchive.StrokePatternType type = 1;
inline bool StrokePatternArchive::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StrokePatternArchive::has_type() const {
  return _internal_has_type();
}
inline void StrokePatternArchive::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::TSD::StrokePatternArchive_StrokePatternType StrokePatternArchive::_internal_type() const {
  return static_cast< ::TSD::StrokePatternArchive_StrokePatternType >(type_);
}
inline ::TSD::StrokePatternArchive_StrokePatternType StrokePatternArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.StrokePatternArchive.type)
  return _internal_type();
}
inline void StrokePatternArchive::_internal_set_type(::TSD::StrokePatternArchive_StrokePatternType value) {
  assert(::TSD::StrokePatternArchive_StrokePatternType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void StrokePatternArchive::set_type(::TSD::StrokePatternArchive_StrokePatternType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.StrokePatternArchive.type)
}

// optional float phase = 2;
inline bool StrokePatternArchive::_internal_has_phase() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StrokePatternArchive::has_phase() const {
  return _internal_has_phase();
}
inline void StrokePatternArchive::clear_phase() {
  phase_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float StrokePatternArchive::_internal_phase() const {
  return phase_;
}
inline float StrokePatternArchive::phase() const {
  // @@protoc_insertion_point(field_get:TSD.StrokePatternArchive.phase)
  return _internal_phase();
}
inline void StrokePatternArchive::_internal_set_phase(float value) {
  _has_bits_[0] |= 0x00000002u;
  phase_ = value;
}
inline void StrokePatternArchive::set_phase(float value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:TSD.StrokePatternArchive.phase)
}

// optional uint32 count = 3;
inline bool StrokePatternArchive::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StrokePatternArchive::has_count() const {
  return _internal_has_count();
}
inline void StrokePatternArchive::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StrokePatternArchive::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StrokePatternArchive::count() const {
  // @@protoc_insertion_point(field_get:TSD.StrokePatternArchive.count)
  return _internal_count();
}
inline void StrokePatternArchive::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  count_ = value;
}
inline void StrokePatternArchive::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:TSD.StrokePatternArchive.count)
}

// repeated float pattern = 4;
inline int StrokePatternArchive::_internal_pattern_size() const {
  return pattern_.size();
}
inline int StrokePatternArchive::pattern_size() const {
  return _internal_pattern_size();
}
inline void StrokePatternArchive::clear_pattern() {
  pattern_.Clear();
}
inline float StrokePatternArchive::_internal_pattern(int index) const {
  return pattern_.Get(index);
}
inline float StrokePatternArchive::pattern(int index) const {
  // @@protoc_insertion_point(field_get:TSD.StrokePatternArchive.pattern)
  return _internal_pattern(index);
}
inline void StrokePatternArchive::set_pattern(int index, float value) {
  pattern_.Set(index, value);
  // @@protoc_insertion_point(field_set:TSD.StrokePatternArchive.pattern)
}
inline void StrokePatternArchive::_internal_add_pattern(float value) {
  pattern_.Add(value);
}
inline void StrokePatternArchive::add_pattern(float value) {
  _internal_add_pattern(value);
  // @@protoc_insertion_point(field_add:TSD.StrokePatternArchive.pattern)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
StrokePatternArchive::_internal_pattern() const {
  return pattern_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
StrokePatternArchive::pattern() const {
  // @@protoc_insertion_point(field_list:TSD.StrokePatternArchive.pattern)
  return _internal_pattern();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
StrokePatternArchive::_internal_mutable_pattern() {
  return &pattern_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
StrokePatternArchive::mutable_pattern() {
  // @@protoc_insertion_point(field_mutable_list:TSD.StrokePatternArchive.pattern)
  return _internal_mutable_pattern();
}

// -------------------------------------------------------------------

// StrokeArchive

// optional .TSP.Color color = 1;
inline bool StrokeArchive::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || color_ != nullptr);
  return value;
}
inline bool StrokeArchive::has_color() const {
  return _internal_has_color();
}
inline const ::TSP::Color& StrokeArchive::_internal_color() const {
  const ::TSP::Color* p = color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& StrokeArchive::color() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.color)
  return _internal_color();
}
inline void StrokeArchive::unsafe_arena_set_allocated_color(
    ::TSP::Color* color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  color_ = color;
  if (color) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.StrokeArchive.color)
}
inline ::TSP::Color* StrokeArchive::release_color() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* StrokeArchive::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:TSD.StrokeArchive.color)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::TSP::Color* StrokeArchive::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000001u;
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    color_ = p;
  }
  return color_;
}
inline ::TSP::Color* StrokeArchive::mutable_color() {
  // @@protoc_insertion_point(field_mutable:TSD.StrokeArchive.color)
  return _internal_mutable_color();
}
inline void StrokeArchive::set_allocated_color(::TSP::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color)->GetArena();
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:TSD.StrokeArchive.color)
}

// optional float width = 2;
inline bool StrokeArchive::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StrokeArchive::has_width() const {
  return _internal_has_width();
}
inline void StrokeArchive::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float StrokeArchive::_internal_width() const {
  return width_;
}
inline float StrokeArchive::width() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.width)
  return _internal_width();
}
inline void StrokeArchive::_internal_set_width(float value) {
  _has_bits_[0] |= 0x00000020u;
  width_ = value;
}
inline void StrokeArchive::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:TSD.StrokeArchive.width)
}

// optional .TSD.StrokeArchive.LineCap cap = 3;
inline bool StrokeArchive::_internal_has_cap() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool StrokeArchive::has_cap() const {
  return _internal_has_cap();
}
inline void StrokeArchive::clear_cap() {
  cap_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::TSD::StrokeArchive_LineCap StrokeArchive::_internal_cap() const {
  return static_cast< ::TSD::StrokeArchive_LineCap >(cap_);
}
inline ::TSD::StrokeArchive_LineCap StrokeArchive::cap() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.cap)
  return _internal_cap();
}
inline void StrokeArchive::_internal_set_cap(::TSD::StrokeArchive_LineCap value) {
  assert(::TSD::StrokeArchive_LineCap_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  cap_ = value;
}
inline void StrokeArchive::set_cap(::TSD::StrokeArchive_LineCap value) {
  _internal_set_cap(value);
  // @@protoc_insertion_point(field_set:TSD.StrokeArchive.cap)
}

// optional .TSD.LineJoin join = 4;
inline bool StrokeArchive::_internal_has_join() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool StrokeArchive::has_join() const {
  return _internal_has_join();
}
inline void StrokeArchive::clear_join() {
  join_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::TSD::LineJoin StrokeArchive::_internal_join() const {
  return static_cast< ::TSD::LineJoin >(join_);
}
inline ::TSD::LineJoin StrokeArchive::join() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.join)
  return _internal_join();
}
inline void StrokeArchive::_internal_set_join(::TSD::LineJoin value) {
  assert(::TSD::LineJoin_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  join_ = value;
}
inline void StrokeArchive::set_join(::TSD::LineJoin value) {
  _internal_set_join(value);
  // @@protoc_insertion_point(field_set:TSD.StrokeArchive.join)
}

// optional float miter_limit = 5;
inline bool StrokeArchive::_internal_has_miter_limit() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool StrokeArchive::has_miter_limit() const {
  return _internal_has_miter_limit();
}
inline void StrokeArchive::clear_miter_limit() {
  miter_limit_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float StrokeArchive::_internal_miter_limit() const {
  return miter_limit_;
}
inline float StrokeArchive::miter_limit() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.miter_limit)
  return _internal_miter_limit();
}
inline void StrokeArchive::_internal_set_miter_limit(float value) {
  _has_bits_[0] |= 0x00000100u;
  miter_limit_ = value;
}
inline void StrokeArchive::set_miter_limit(float value) {
  _internal_set_miter_limit(value);
  // @@protoc_insertion_point(field_set:TSD.StrokeArchive.miter_limit)
}

// optional .TSD.StrokePatternArchive pattern = 6;
inline bool StrokeArchive::_internal_has_pattern() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || pattern_ != nullptr);
  return value;
}
inline bool StrokeArchive::has_pattern() const {
  return _internal_has_pattern();
}
inline void StrokeArchive::clear_pattern() {
  if (pattern_ != nullptr) pattern_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::StrokePatternArchive& StrokeArchive::_internal_pattern() const {
  const ::TSD::StrokePatternArchive* p = pattern_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::StrokePatternArchive&>(
      ::TSD::_StrokePatternArchive_default_instance_);
}
inline const ::TSD::StrokePatternArchive& StrokeArchive::pattern() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.pattern)
  return _internal_pattern();
}
inline void StrokeArchive::unsafe_arena_set_allocated_pattern(
    ::TSD::StrokePatternArchive* pattern) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pattern_);
  }
  pattern_ = pattern;
  if (pattern) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.StrokeArchive.pattern)
}
inline ::TSD::StrokePatternArchive* StrokeArchive::release_pattern() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::StrokePatternArchive* temp = pattern_;
  pattern_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::StrokePatternArchive* StrokeArchive::unsafe_arena_release_pattern() {
  // @@protoc_insertion_point(field_release:TSD.StrokeArchive.pattern)
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::StrokePatternArchive* temp = pattern_;
  pattern_ = nullptr;
  return temp;
}
inline ::TSD::StrokePatternArchive* StrokeArchive::_internal_mutable_pattern() {
  _has_bits_[0] |= 0x00000002u;
  if (pattern_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::StrokePatternArchive>(GetArena());
    pattern_ = p;
  }
  return pattern_;
}
inline ::TSD::StrokePatternArchive* StrokeArchive::mutable_pattern() {
  // @@protoc_insertion_point(field_mutable:TSD.StrokeArchive.pattern)
  return _internal_mutable_pattern();
}
inline void StrokeArchive::set_allocated_pattern(::TSD::StrokePatternArchive* pattern) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pattern_;
  }
  if (pattern) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pattern);
    if (message_arena != submessage_arena) {
      pattern = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pattern, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pattern_ = pattern;
  // @@protoc_insertion_point(field_set_allocated:TSD.StrokeArchive.pattern)
}

// optional .TSD.SmartStrokeArchive smart_stroke = 7;
inline bool StrokeArchive::_internal_has_smart_stroke() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || smart_stroke_ != nullptr);
  return value;
}
inline bool StrokeArchive::has_smart_stroke() const {
  return _internal_has_smart_stroke();
}
inline void StrokeArchive::clear_smart_stroke() {
  if (smart_stroke_ != nullptr) smart_stroke_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::SmartStrokeArchive& StrokeArchive::_internal_smart_stroke() const {
  const ::TSD::SmartStrokeArchive* p = smart_stroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::SmartStrokeArchive&>(
      ::TSD::_SmartStrokeArchive_default_instance_);
}
inline const ::TSD::SmartStrokeArchive& StrokeArchive::smart_stroke() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.smart_stroke)
  return _internal_smart_stroke();
}
inline void StrokeArchive::unsafe_arena_set_allocated_smart_stroke(
    ::TSD::SmartStrokeArchive* smart_stroke) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(smart_stroke_);
  }
  smart_stroke_ = smart_stroke;
  if (smart_stroke) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.StrokeArchive.smart_stroke)
}
inline ::TSD::SmartStrokeArchive* StrokeArchive::release_smart_stroke() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::SmartStrokeArchive* temp = smart_stroke_;
  smart_stroke_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::SmartStrokeArchive* StrokeArchive::unsafe_arena_release_smart_stroke() {
  // @@protoc_insertion_point(field_release:TSD.StrokeArchive.smart_stroke)
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::SmartStrokeArchive* temp = smart_stroke_;
  smart_stroke_ = nullptr;
  return temp;
}
inline ::TSD::SmartStrokeArchive* StrokeArchive::_internal_mutable_smart_stroke() {
  _has_bits_[0] |= 0x00000004u;
  if (smart_stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::SmartStrokeArchive>(GetArena());
    smart_stroke_ = p;
  }
  return smart_stroke_;
}
inline ::TSD::SmartStrokeArchive* StrokeArchive::mutable_smart_stroke() {
  // @@protoc_insertion_point(field_mutable:TSD.StrokeArchive.smart_stroke)
  return _internal_mutable_smart_stroke();
}
inline void StrokeArchive::set_allocated_smart_stroke(::TSD::SmartStrokeArchive* smart_stroke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete smart_stroke_;
  }
  if (smart_stroke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(smart_stroke);
    if (message_arena != submessage_arena) {
      smart_stroke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, smart_stroke, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  smart_stroke_ = smart_stroke;
  // @@protoc_insertion_point(field_set_allocated:TSD.StrokeArchive.smart_stroke)
}

// optional .TSD.FrameArchive frame = 8;
inline bool StrokeArchive::_internal_has_frame() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || frame_ != nullptr);
  return value;
}
inline bool StrokeArchive::has_frame() const {
  return _internal_has_frame();
}
inline void StrokeArchive::clear_frame() {
  if (frame_ != nullptr) frame_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::TSD::FrameArchive& StrokeArchive::_internal_frame() const {
  const ::TSD::FrameArchive* p = frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::FrameArchive&>(
      ::TSD::_FrameArchive_default_instance_);
}
inline const ::TSD::FrameArchive& StrokeArchive::frame() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.frame)
  return _internal_frame();
}
inline void StrokeArchive::unsafe_arena_set_allocated_frame(
    ::TSD::FrameArchive* frame) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_);
  }
  frame_ = frame;
  if (frame) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.StrokeArchive.frame)
}
inline ::TSD::FrameArchive* StrokeArchive::release_frame() {
  _has_bits_[0] &= ~0x00000008u;
  ::TSD::FrameArchive* temp = frame_;
  frame_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::FrameArchive* StrokeArchive::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_release:TSD.StrokeArchive.frame)
  _has_bits_[0] &= ~0x00000008u;
  ::TSD::FrameArchive* temp = frame_;
  frame_ = nullptr;
  return temp;
}
inline ::TSD::FrameArchive* StrokeArchive::_internal_mutable_frame() {
  _has_bits_[0] |= 0x00000008u;
  if (frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::FrameArchive>(GetArena());
    frame_ = p;
  }
  return frame_;
}
inline ::TSD::FrameArchive* StrokeArchive::mutable_frame() {
  // @@protoc_insertion_point(field_mutable:TSD.StrokeArchive.frame)
  return _internal_mutable_frame();
}
inline void StrokeArchive::set_allocated_frame(::TSD::FrameArchive* frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete frame_;
  }
  if (frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(frame);
    if (message_arena != submessage_arena) {
      frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:TSD.StrokeArchive.frame)
}

// optional .TSD.PatternedStrokeArchive patterned_stroke = 9;
inline bool StrokeArchive::_internal_has_patterned_stroke() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || patterned_stroke_ != nullptr);
  return value;
}
inline bool StrokeArchive::has_patterned_stroke() const {
  return _internal_has_patterned_stroke();
}
inline void StrokeArchive::clear_patterned_stroke() {
  if (patterned_stroke_ != nullptr) patterned_stroke_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::TSD::PatternedStrokeArchive& StrokeArchive::_internal_patterned_stroke() const {
  const ::TSD::PatternedStrokeArchive* p = patterned_stroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::PatternedStrokeArchive&>(
      ::TSD::_PatternedStrokeArchive_default_instance_);
}
inline const ::TSD::PatternedStrokeArchive& StrokeArchive::patterned_stroke() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.patterned_stroke)
  return _internal_patterned_stroke();
}
inline void StrokeArchive::unsafe_arena_set_allocated_patterned_stroke(
    ::TSD::PatternedStrokeArchive* patterned_stroke) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(patterned_stroke_);
  }
  patterned_stroke_ = patterned_stroke;
  if (patterned_stroke) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.StrokeArchive.patterned_stroke)
}
inline ::TSD::PatternedStrokeArchive* StrokeArchive::release_patterned_stroke() {
  _has_bits_[0] &= ~0x00000010u;
  ::TSD::PatternedStrokeArchive* temp = patterned_stroke_;
  patterned_stroke_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::PatternedStrokeArchive* StrokeArchive::unsafe_arena_release_patterned_stroke() {
  // @@protoc_insertion_point(field_release:TSD.StrokeArchive.patterned_stroke)
  _has_bits_[0] &= ~0x00000010u;
  ::TSD::PatternedStrokeArchive* temp = patterned_stroke_;
  patterned_stroke_ = nullptr;
  return temp;
}
inline ::TSD::PatternedStrokeArchive* StrokeArchive::_internal_mutable_patterned_stroke() {
  _has_bits_[0] |= 0x00000010u;
  if (patterned_stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::PatternedStrokeArchive>(GetArena());
    patterned_stroke_ = p;
  }
  return patterned_stroke_;
}
inline ::TSD::PatternedStrokeArchive* StrokeArchive::mutable_patterned_stroke() {
  // @@protoc_insertion_point(field_mutable:TSD.StrokeArchive.patterned_stroke)
  return _internal_mutable_patterned_stroke();
}
inline void StrokeArchive::set_allocated_patterned_stroke(::TSD::PatternedStrokeArchive* patterned_stroke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete patterned_stroke_;
  }
  if (patterned_stroke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(patterned_stroke);
    if (message_arena != submessage_arena) {
      patterned_stroke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, patterned_stroke, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  patterned_stroke_ = patterned_stroke;
  // @@protoc_insertion_point(field_set_allocated:TSD.StrokeArchive.patterned_stroke)
}

// -------------------------------------------------------------------

// SmartStrokeArchive

// optional string stroke_name = 2;
inline bool SmartStrokeArchive::_internal_has_stroke_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SmartStrokeArchive::has_stroke_name() const {
  return _internal_has_stroke_name();
}
inline void SmartStrokeArchive::clear_stroke_name() {
  stroke_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SmartStrokeArchive::stroke_name() const {
  // @@protoc_insertion_point(field_get:TSD.SmartStrokeArchive.stroke_name)
  return _internal_stroke_name();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void SmartStrokeArchive::set_stroke_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 stroke_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.SmartStrokeArchive.stroke_name)
}
inline std::string* SmartStrokeArchive::mutable_stroke_name() {
  // @@protoc_insertion_point(field_mutable:TSD.SmartStrokeArchive.stroke_name)
  return _internal_mutable_stroke_name();
}
inline const std::string& SmartStrokeArchive::_internal_stroke_name() const {
  return stroke_name_.Get();
}
inline void SmartStrokeArchive::_internal_set_stroke_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  stroke_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* SmartStrokeArchive::_internal_mutable_stroke_name() {
  _has_bits_[0] |= 0x00000001u;
  return stroke_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SmartStrokeArchive::release_stroke_name() {
  // @@protoc_insertion_point(field_release:TSD.SmartStrokeArchive.stroke_name)
  if (!_internal_has_stroke_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return stroke_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SmartStrokeArchive::set_allocated_stroke_name(std::string* stroke_name) {
  if (stroke_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stroke_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stroke_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.SmartStrokeArchive.stroke_name)
}

// optional uint32 random_seed = 3;
inline bool SmartStrokeArchive::_internal_has_random_seed() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SmartStrokeArchive::has_random_seed() const {
  return _internal_has_random_seed();
}
inline void SmartStrokeArchive::clear_random_seed() {
  random_seed_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SmartStrokeArchive::_internal_random_seed() const {
  return random_seed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SmartStrokeArchive::random_seed() const {
  // @@protoc_insertion_point(field_get:TSD.SmartStrokeArchive.random_seed)
  return _internal_random_seed();
}
inline void SmartStrokeArchive::_internal_set_random_seed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  random_seed_ = value;
}
inline void SmartStrokeArchive::set_random_seed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_random_seed(value);
  // @@protoc_insertion_point(field_set:TSD.SmartStrokeArchive.random_seed)
}

// optional .TSP.ReferenceDictionary parameterValues = 4;
inline bool SmartStrokeArchive::_internal_has_parametervalues() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || parametervalues_ != nullptr);
  return value;
}
inline bool SmartStrokeArchive::has_parametervalues() const {
  return _internal_has_parametervalues();
}
inline const ::TSP::ReferenceDictionary& SmartStrokeArchive::_internal_parametervalues() const {
  const ::TSP::ReferenceDictionary* p = parametervalues_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::ReferenceDictionary&>(
      ::TSP::_ReferenceDictionary_default_instance_);
}
inline const ::TSP::ReferenceDictionary& SmartStrokeArchive::parametervalues() const {
  // @@protoc_insertion_point(field_get:TSD.SmartStrokeArchive.parameterValues)
  return _internal_parametervalues();
}
inline void SmartStrokeArchive::unsafe_arena_set_allocated_parametervalues(
    ::TSP::ReferenceDictionary* parametervalues) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parametervalues_);
  }
  parametervalues_ = parametervalues;
  if (parametervalues) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.SmartStrokeArchive.parameterValues)
}
inline ::TSP::ReferenceDictionary* SmartStrokeArchive::release_parametervalues() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::ReferenceDictionary* temp = parametervalues_;
  parametervalues_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::ReferenceDictionary* SmartStrokeArchive::unsafe_arena_release_parametervalues() {
  // @@protoc_insertion_point(field_release:TSD.SmartStrokeArchive.parameterValues)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::ReferenceDictionary* temp = parametervalues_;
  parametervalues_ = nullptr;
  return temp;
}
inline ::TSP::ReferenceDictionary* SmartStrokeArchive::_internal_mutable_parametervalues() {
  _has_bits_[0] |= 0x00000002u;
  if (parametervalues_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::ReferenceDictionary>(GetArena());
    parametervalues_ = p;
  }
  return parametervalues_;
}
inline ::TSP::ReferenceDictionary* SmartStrokeArchive::mutable_parametervalues() {
  // @@protoc_insertion_point(field_mutable:TSD.SmartStrokeArchive.parameterValues)
  return _internal_mutable_parametervalues();
}
inline void SmartStrokeArchive::set_allocated_parametervalues(::TSP::ReferenceDictionary* parametervalues) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(parametervalues_);
  }
  if (parametervalues) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parametervalues)->GetArena();
    if (message_arena != submessage_arena) {
      parametervalues = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parametervalues, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  parametervalues_ = parametervalues;
  // @@protoc_insertion_point(field_set_allocated:TSD.SmartStrokeArchive.parameterValues)
}

// optional double pattern_offset_distance = 5;
inline bool SmartStrokeArchive::_internal_has_pattern_offset_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SmartStrokeArchive::has_pattern_offset_distance() const {
  return _internal_has_pattern_offset_distance();
}
inline void SmartStrokeArchive::clear_pattern_offset_distance() {
  pattern_offset_distance_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double SmartStrokeArchive::_internal_pattern_offset_distance() const {
  return pattern_offset_distance_;
}
inline double SmartStrokeArchive::pattern_offset_distance() const {
  // @@protoc_insertion_point(field_get:TSD.SmartStrokeArchive.pattern_offset_distance)
  return _internal_pattern_offset_distance();
}
inline void SmartStrokeArchive::_internal_set_pattern_offset_distance(double value) {
  _has_bits_[0] |= 0x00000004u;
  pattern_offset_distance_ = value;
}
inline void SmartStrokeArchive::set_pattern_offset_distance(double value) {
  _internal_set_pattern_offset_distance(value);
  // @@protoc_insertion_point(field_set:TSD.SmartStrokeArchive.pattern_offset_distance)
}

// -------------------------------------------------------------------

// FrameArchive

// optional string frameName = 2;
inline bool FrameArchive::_internal_has_framename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FrameArchive::has_framename() const {
  return _internal_has_framename();
}
inline void FrameArchive::clear_framename() {
  framename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FrameArchive::framename() const {
  // @@protoc_insertion_point(field_get:TSD.FrameArchive.frameName)
  return _internal_framename();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void FrameArchive::set_framename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 framename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.FrameArchive.frameName)
}
inline std::string* FrameArchive::mutable_framename() {
  // @@protoc_insertion_point(field_mutable:TSD.FrameArchive.frameName)
  return _internal_mutable_framename();
}
inline const std::string& FrameArchive::_internal_framename() const {
  return framename_.Get();
}
inline void FrameArchive::_internal_set_framename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  framename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* FrameArchive::_internal_mutable_framename() {
  _has_bits_[0] |= 0x00000001u;
  return framename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FrameArchive::release_framename() {
  // @@protoc_insertion_point(field_release:TSD.FrameArchive.frameName)
  if (!_internal_has_framename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return framename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FrameArchive::set_allocated_framename(std::string* framename) {
  if (framename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  framename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), framename,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.FrameArchive.frameName)
}

// optional float assetScale = 3;
inline bool FrameArchive::_internal_has_assetscale() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FrameArchive::has_assetscale() const {
  return _internal_has_assetscale();
}
inline void FrameArchive::clear_assetscale() {
  assetscale_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float FrameArchive::_internal_assetscale() const {
  return assetscale_;
}
inline float FrameArchive::assetscale() const {
  // @@protoc_insertion_point(field_get:TSD.FrameArchive.assetScale)
  return _internal_assetscale();
}
inline void FrameArchive::_internal_set_assetscale(float value) {
  _has_bits_[0] |= 0x00000002u;
  assetscale_ = value;
}
inline void FrameArchive::set_assetscale(float value) {
  _internal_set_assetscale(value);
  // @@protoc_insertion_point(field_set:TSD.FrameArchive.assetScale)
}

// -------------------------------------------------------------------

// PatternedStrokeArchive

// optional string pattern_name = 2;
inline bool PatternedStrokeArchive::_internal_has_pattern_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PatternedStrokeArchive::has_pattern_name() const {
  return _internal_has_pattern_name();
}
inline void PatternedStrokeArchive::clear_pattern_name() {
  pattern_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PatternedStrokeArchive::pattern_name() const {
  // @@protoc_insertion_point(field_get:TSD.PatternedStrokeArchive.pattern_name)
  return _internal_pattern_name();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void PatternedStrokeArchive::set_pattern_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 pattern_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.PatternedStrokeArchive.pattern_name)
}
inline std::string* PatternedStrokeArchive::mutable_pattern_name() {
  // @@protoc_insertion_point(field_mutable:TSD.PatternedStrokeArchive.pattern_name)
  return _internal_mutable_pattern_name();
}
inline const std::string& PatternedStrokeArchive::_internal_pattern_name() const {
  return pattern_name_.Get();
}
inline void PatternedStrokeArchive::_internal_set_pattern_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pattern_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* PatternedStrokeArchive::_internal_mutable_pattern_name() {
  _has_bits_[0] |= 0x00000001u;
  return pattern_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PatternedStrokeArchive::release_pattern_name() {
  // @@protoc_insertion_point(field_release:TSD.PatternedStrokeArchive.pattern_name)
  if (!_internal_has_pattern_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return pattern_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PatternedStrokeArchive::set_allocated_pattern_name(std::string* pattern_name) {
  if (pattern_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pattern_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pattern_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.PatternedStrokeArchive.pattern_name)
}

// -------------------------------------------------------------------

// LineEndArchive

// optional .TSP.Path path = 1;
inline bool LineEndArchive::_internal_has_path() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || path_ != nullptr);
  return value;
}
inline bool LineEndArchive::has_path() const {
  return _internal_has_path();
}
inline const ::TSP::Path& LineEndArchive::_internal_path() const {
  const ::TSP::Path* p = path_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Path&>(
      ::TSP::_Path_default_instance_);
}
inline const ::TSP::Path& LineEndArchive::path() const {
  // @@protoc_insertion_point(field_get:TSD.LineEndArchive.path)
  return _internal_path();
}
inline void LineEndArchive::unsafe_arena_set_allocated_path(
    ::TSP::Path* path) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path_);
  }
  path_ = path;
  if (path) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.LineEndArchive.path)
}
inline ::TSP::Path* LineEndArchive::release_path() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Path* temp = path_;
  path_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Path* LineEndArchive::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:TSD.LineEndArchive.path)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Path* temp = path_;
  path_ = nullptr;
  return temp;
}
inline ::TSP::Path* LineEndArchive::_internal_mutable_path() {
  _has_bits_[0] |= 0x00000002u;
  if (path_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Path>(GetArena());
    path_ = p;
  }
  return path_;
}
inline ::TSP::Path* LineEndArchive::mutable_path() {
  // @@protoc_insertion_point(field_mutable:TSD.LineEndArchive.path)
  return _internal_mutable_path();
}
inline void LineEndArchive::set_allocated_path(::TSP::Path* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(path_);
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path)->GetArena();
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  path_ = path;
  // @@protoc_insertion_point(field_set_allocated:TSD.LineEndArchive.path)
}

// optional .TSD.LineJoin line_join = 2 [default = MiterJoin];
inline bool LineEndArchive::_internal_has_line_join() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LineEndArchive::has_line_join() const {
  return _internal_has_line_join();
}
inline void LineEndArchive::clear_line_join() {
  line_join_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::TSD::LineJoin LineEndArchive::_internal_line_join() const {
  return static_cast< ::TSD::LineJoin >(line_join_);
}
inline ::TSD::LineJoin LineEndArchive::line_join() const {
  // @@protoc_insertion_point(field_get:TSD.LineEndArchive.line_join)
  return _internal_line_join();
}
inline void LineEndArchive::_internal_set_line_join(::TSD::LineJoin value) {
  assert(::TSD::LineJoin_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  line_join_ = value;
}
inline void LineEndArchive::set_line_join(::TSD::LineJoin value) {
  _internal_set_line_join(value);
  // @@protoc_insertion_point(field_set:TSD.LineEndArchive.line_join)
}

// optional .TSP.Point end_point = 3;
inline bool LineEndArchive::_internal_has_end_point() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || end_point_ != nullptr);
  return value;
}
inline bool LineEndArchive::has_end_point() const {
  return _internal_has_end_point();
}
inline const ::TSP::Point& LineEndArchive::_internal_end_point() const {
  const ::TSP::Point* p = end_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& LineEndArchive::end_point() const {
  // @@protoc_insertion_point(field_get:TSD.LineEndArchive.end_point)
  return _internal_end_point();
}
inline void LineEndArchive::unsafe_arena_set_allocated_end_point(
    ::TSP::Point* end_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_point_);
  }
  end_point_ = end_point;
  if (end_point) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.LineEndArchive.end_point)
}
inline ::TSP::Point* LineEndArchive::release_end_point() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Point* temp = end_point_;
  end_point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Point* LineEndArchive::unsafe_arena_release_end_point() {
  // @@protoc_insertion_point(field_release:TSD.LineEndArchive.end_point)
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Point* temp = end_point_;
  end_point_ = nullptr;
  return temp;
}
inline ::TSP::Point* LineEndArchive::_internal_mutable_end_point() {
  _has_bits_[0] |= 0x00000004u;
  if (end_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArena());
    end_point_ = p;
  }
  return end_point_;
}
inline ::TSP::Point* LineEndArchive::mutable_end_point() {
  // @@protoc_insertion_point(field_mutable:TSD.LineEndArchive.end_point)
  return _internal_mutable_end_point();
}
inline void LineEndArchive::set_allocated_end_point(::TSP::Point* end_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_point_);
  }
  if (end_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_point)->GetArena();
    if (message_arena != submessage_arena) {
      end_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  end_point_ = end_point;
  // @@protoc_insertion_point(field_set_allocated:TSD.LineEndArchive.end_point)
}

// optional bool is_filled = 4;
inline bool LineEndArchive::_internal_has_is_filled() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LineEndArchive::has_is_filled() const {
  return _internal_has_is_filled();
}
inline void LineEndArchive::clear_is_filled() {
  is_filled_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool LineEndArchive::_internal_is_filled() const {
  return is_filled_;
}
inline bool LineEndArchive::is_filled() const {
  // @@protoc_insertion_point(field_get:TSD.LineEndArchive.is_filled)
  return _internal_is_filled();
}
inline void LineEndArchive::_internal_set_is_filled(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_filled_ = value;
}
inline void LineEndArchive::set_is_filled(bool value) {
  _internal_set_is_filled(value);
  // @@protoc_insertion_point(field_set:TSD.LineEndArchive.is_filled)
}

// optional string identifier = 5;
inline bool LineEndArchive::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LineEndArchive::has_identifier() const {
  return _internal_has_identifier();
}
inline void LineEndArchive::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LineEndArchive::identifier() const {
  // @@protoc_insertion_point(field_get:TSD.LineEndArchive.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void LineEndArchive::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.LineEndArchive.identifier)
}
inline std::string* LineEndArchive::mutable_identifier() {
  // @@protoc_insertion_point(field_mutable:TSD.LineEndArchive.identifier)
  return _internal_mutable_identifier();
}
inline const std::string& LineEndArchive::_internal_identifier() const {
  return identifier_.Get();
}
inline void LineEndArchive::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* LineEndArchive::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LineEndArchive::release_identifier() {
  // @@protoc_insertion_point(field_release:TSD.LineEndArchive.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LineEndArchive::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.LineEndArchive.identifier)
}

// -------------------------------------------------------------------

// ShadowArchive

// optional .TSP.Color color = 1;
inline bool ShadowArchive::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || color_ != nullptr);
  return value;
}
inline bool ShadowArchive::has_color() const {
  return _internal_has_color();
}
inline const ::TSP::Color& ShadowArchive::_internal_color() const {
  const ::TSP::Color* p = color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& ShadowArchive::color() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.color)
  return _internal_color();
}
inline void ShadowArchive::unsafe_arena_set_allocated_color(
    ::TSP::Color* color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  color_ = color;
  if (color) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShadowArchive.color)
}
inline ::TSP::Color* ShadowArchive::release_color() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* ShadowArchive::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:TSD.ShadowArchive.color)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::TSP::Color* ShadowArchive::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000001u;
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    color_ = p;
  }
  return color_;
}
inline ::TSP::Color* ShadowArchive::mutable_color() {
  // @@protoc_insertion_point(field_mutable:TSD.ShadowArchive.color)
  return _internal_mutable_color();
}
inline void ShadowArchive::set_allocated_color(::TSP::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color)->GetArena();
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShadowArchive.color)
}

// optional float angle = 2 [default = 315];
inline bool ShadowArchive::_internal_has_angle() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ShadowArchive::has_angle() const {
  return _internal_has_angle();
}
inline void ShadowArchive::clear_angle() {
  angle_ = 315;
  _has_bits_[0] &= ~0x00000040u;
}
inline float ShadowArchive::_internal_angle() const {
  return angle_;
}
inline float ShadowArchive::angle() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.angle)
  return _internal_angle();
}
inline void ShadowArchive::_internal_set_angle(float value) {
  _has_bits_[0] |= 0x00000040u;
  angle_ = value;
}
inline void ShadowArchive::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:TSD.ShadowArchive.angle)
}

// optional float offset = 3 [default = 5];
inline bool ShadowArchive::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ShadowArchive::has_offset() const {
  return _internal_has_offset();
}
inline void ShadowArchive::clear_offset() {
  offset_ = 5;
  _has_bits_[0] &= ~0x00000080u;
}
inline float ShadowArchive::_internal_offset() const {
  return offset_;
}
inline float ShadowArchive::offset() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.offset)
  return _internal_offset();
}
inline void ShadowArchive::_internal_set_offset(float value) {
  _has_bits_[0] |= 0x00000080u;
  offset_ = value;
}
inline void ShadowArchive::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:TSD.ShadowArchive.offset)
}

// optional int32 radius = 4 [default = 1];
inline bool ShadowArchive::_internal_has_radius() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ShadowArchive::has_radius() const {
  return _internal_has_radius();
}
inline void ShadowArchive::clear_radius() {
  radius_ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ShadowArchive::_internal_radius() const {
  return radius_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ShadowArchive::radius() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.radius)
  return _internal_radius();
}
inline void ShadowArchive::_internal_set_radius(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  radius_ = value;
}
inline void ShadowArchive::set_radius(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:TSD.ShadowArchive.radius)
}

// optional float opacity = 5 [default = 1];
inline bool ShadowArchive::_internal_has_opacity() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ShadowArchive::has_opacity() const {
  return _internal_has_opacity();
}
inline void ShadowArchive::clear_opacity() {
  opacity_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline float ShadowArchive::_internal_opacity() const {
  return opacity_;
}
inline float ShadowArchive::opacity() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.opacity)
  return _internal_opacity();
}
inline void ShadowArchive::_internal_set_opacity(float value) {
  _has_bits_[0] |= 0x00000200u;
  opacity_ = value;
}
inline void ShadowArchive::set_opacity(float value) {
  _internal_set_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.ShadowArchive.opacity)
}

// optional bool is_enabled = 6 [default = true];
inline bool ShadowArchive::_internal_has_is_enabled() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ShadowArchive::has_is_enabled() const {
  return _internal_has_is_enabled();
}
inline void ShadowArchive::clear_is_enabled() {
  is_enabled_ = true;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ShadowArchive::_internal_is_enabled() const {
  return is_enabled_;
}
inline bool ShadowArchive::is_enabled() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.is_enabled)
  return _internal_is_enabled();
}
inline void ShadowArchive::_internal_set_is_enabled(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_enabled_ = value;
}
inline void ShadowArchive::set_is_enabled(bool value) {
  _internal_set_is_enabled(value);
  // @@protoc_insertion_point(field_set:TSD.ShadowArchive.is_enabled)
}

// optional .TSD.ShadowArchive.ShadowType type = 7 [default = TSDDropShadow];
inline bool ShadowArchive::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShadowArchive::has_type() const {
  return _internal_has_type();
}
inline void ShadowArchive::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::TSD::ShadowArchive_ShadowType ShadowArchive::_internal_type() const {
  return static_cast< ::TSD::ShadowArchive_ShadowType >(type_);
}
inline ::TSD::ShadowArchive_ShadowType ShadowArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.type)
  return _internal_type();
}
inline void ShadowArchive::_internal_set_type(::TSD::ShadowArchive_ShadowType value) {
  assert(::TSD::ShadowArchive_ShadowType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  type_ = value;
}
inline void ShadowArchive::set_type(::TSD::ShadowArchive_ShadowType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.ShadowArchive.type)
}

// optional .TSD.DropShadowArchive dropShadow = 8;
inline bool ShadowArchive::_internal_has_dropshadow() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || dropshadow_ != nullptr);
  return value;
}
inline bool ShadowArchive::has_dropshadow() const {
  return _internal_has_dropshadow();
}
inline void ShadowArchive::clear_dropshadow() {
  if (dropshadow_ != nullptr) dropshadow_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::DropShadowArchive& ShadowArchive::_internal_dropshadow() const {
  const ::TSD::DropShadowArchive* p = dropshadow_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DropShadowArchive&>(
      ::TSD::_DropShadowArchive_default_instance_);
}
inline const ::TSD::DropShadowArchive& ShadowArchive::dropshadow() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.dropShadow)
  return _internal_dropshadow();
}
inline void ShadowArchive::unsafe_arena_set_allocated_dropshadow(
    ::TSD::DropShadowArchive* dropshadow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dropshadow_);
  }
  dropshadow_ = dropshadow;
  if (dropshadow) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShadowArchive.dropShadow)
}
inline ::TSD::DropShadowArchive* ShadowArchive::release_dropshadow() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::DropShadowArchive* temp = dropshadow_;
  dropshadow_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::DropShadowArchive* ShadowArchive::unsafe_arena_release_dropshadow() {
  // @@protoc_insertion_point(field_release:TSD.ShadowArchive.dropShadow)
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::DropShadowArchive* temp = dropshadow_;
  dropshadow_ = nullptr;
  return temp;
}
inline ::TSD::DropShadowArchive* ShadowArchive::_internal_mutable_dropshadow() {
  _has_bits_[0] |= 0x00000002u;
  if (dropshadow_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DropShadowArchive>(GetArena());
    dropshadow_ = p;
  }
  return dropshadow_;
}
inline ::TSD::DropShadowArchive* ShadowArchive::mutable_dropshadow() {
  // @@protoc_insertion_point(field_mutable:TSD.ShadowArchive.dropShadow)
  return _internal_mutable_dropshadow();
}
inline void ShadowArchive::set_allocated_dropshadow(::TSD::DropShadowArchive* dropshadow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete dropshadow_;
  }
  if (dropshadow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(dropshadow);
    if (message_arena != submessage_arena) {
      dropshadow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dropshadow, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dropshadow_ = dropshadow;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShadowArchive.dropShadow)
}

// optional .TSD.ContactShadowArchive contactShadow = 9;
inline bool ShadowArchive::_internal_has_contactshadow() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || contactshadow_ != nullptr);
  return value;
}
inline bool ShadowArchive::has_contactshadow() const {
  return _internal_has_contactshadow();
}
inline void ShadowArchive::clear_contactshadow() {
  if (contactshadow_ != nullptr) contactshadow_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::ContactShadowArchive& ShadowArchive::_internal_contactshadow() const {
  const ::TSD::ContactShadowArchive* p = contactshadow_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ContactShadowArchive&>(
      ::TSD::_ContactShadowArchive_default_instance_);
}
inline const ::TSD::ContactShadowArchive& ShadowArchive::contactshadow() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.contactShadow)
  return _internal_contactshadow();
}
inline void ShadowArchive::unsafe_arena_set_allocated_contactshadow(
    ::TSD::ContactShadowArchive* contactshadow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contactshadow_);
  }
  contactshadow_ = contactshadow;
  if (contactshadow) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShadowArchive.contactShadow)
}
inline ::TSD::ContactShadowArchive* ShadowArchive::release_contactshadow() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::ContactShadowArchive* temp = contactshadow_;
  contactshadow_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::ContactShadowArchive* ShadowArchive::unsafe_arena_release_contactshadow() {
  // @@protoc_insertion_point(field_release:TSD.ShadowArchive.contactShadow)
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::ContactShadowArchive* temp = contactshadow_;
  contactshadow_ = nullptr;
  return temp;
}
inline ::TSD::ContactShadowArchive* ShadowArchive::_internal_mutable_contactshadow() {
  _has_bits_[0] |= 0x00000004u;
  if (contactshadow_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ContactShadowArchive>(GetArena());
    contactshadow_ = p;
  }
  return contactshadow_;
}
inline ::TSD::ContactShadowArchive* ShadowArchive::mutable_contactshadow() {
  // @@protoc_insertion_point(field_mutable:TSD.ShadowArchive.contactShadow)
  return _internal_mutable_contactshadow();
}
inline void ShadowArchive::set_allocated_contactshadow(::TSD::ContactShadowArchive* contactshadow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete contactshadow_;
  }
  if (contactshadow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(contactshadow);
    if (message_arena != submessage_arena) {
      contactshadow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contactshadow, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  contactshadow_ = contactshadow;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShadowArchive.contactShadow)
}

// optional .TSD.CurvedShadowArchive curvedShadow = 10;
inline bool ShadowArchive::_internal_has_curvedshadow() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || curvedshadow_ != nullptr);
  return value;
}
inline bool ShadowArchive::has_curvedshadow() const {
  return _internal_has_curvedshadow();
}
inline void ShadowArchive::clear_curvedshadow() {
  if (curvedshadow_ != nullptr) curvedshadow_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::TSD::CurvedShadowArchive& ShadowArchive::_internal_curvedshadow() const {
  const ::TSD::CurvedShadowArchive* p = curvedshadow_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::CurvedShadowArchive&>(
      ::TSD::_CurvedShadowArchive_default_instance_);
}
inline const ::TSD::CurvedShadowArchive& ShadowArchive::curvedshadow() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.curvedShadow)
  return _internal_curvedshadow();
}
inline void ShadowArchive::unsafe_arena_set_allocated_curvedshadow(
    ::TSD::CurvedShadowArchive* curvedshadow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(curvedshadow_);
  }
  curvedshadow_ = curvedshadow;
  if (curvedshadow) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShadowArchive.curvedShadow)
}
inline ::TSD::CurvedShadowArchive* ShadowArchive::release_curvedshadow() {
  _has_bits_[0] &= ~0x00000008u;
  ::TSD::CurvedShadowArchive* temp = curvedshadow_;
  curvedshadow_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::CurvedShadowArchive* ShadowArchive::unsafe_arena_release_curvedshadow() {
  // @@protoc_insertion_point(field_release:TSD.ShadowArchive.curvedShadow)
  _has_bits_[0] &= ~0x00000008u;
  ::TSD::CurvedShadowArchive* temp = curvedshadow_;
  curvedshadow_ = nullptr;
  return temp;
}
inline ::TSD::CurvedShadowArchive* ShadowArchive::_internal_mutable_curvedshadow() {
  _has_bits_[0] |= 0x00000008u;
  if (curvedshadow_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::CurvedShadowArchive>(GetArena());
    curvedshadow_ = p;
  }
  return curvedshadow_;
}
inline ::TSD::CurvedShadowArchive* ShadowArchive::mutable_curvedshadow() {
  // @@protoc_insertion_point(field_mutable:TSD.ShadowArchive.curvedShadow)
  return _internal_mutable_curvedshadow();
}
inline void ShadowArchive::set_allocated_curvedshadow(::TSD::CurvedShadowArchive* curvedshadow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete curvedshadow_;
  }
  if (curvedshadow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(curvedshadow);
    if (message_arena != submessage_arena) {
      curvedshadow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curvedshadow, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  curvedshadow_ = curvedshadow;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShadowArchive.curvedShadow)
}

// -------------------------------------------------------------------

// DropShadowArchive

// -------------------------------------------------------------------

// ContactShadowArchive

// optional float height = 2 [default = 0.2];
inline bool ContactShadowArchive::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContactShadowArchive::has_height() const {
  return _internal_has_height();
}
inline void ContactShadowArchive::clear_height() {
  height_ = 0.2f;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ContactShadowArchive::_internal_height() const {
  return height_;
}
inline float ContactShadowArchive::height() const {
  // @@protoc_insertion_point(field_get:TSD.ContactShadowArchive.height)
  return _internal_height();
}
inline void ContactShadowArchive::_internal_set_height(float value) {
  _has_bits_[0] |= 0x00000002u;
  height_ = value;
}
inline void ContactShadowArchive::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:TSD.ContactShadowArchive.height)
}

// optional float offset = 4 [default = 0];
inline bool ContactShadowArchive::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContactShadowArchive::has_offset() const {
  return _internal_has_offset();
}
inline void ContactShadowArchive::clear_offset() {
  offset_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ContactShadowArchive::_internal_offset() const {
  return offset_;
}
inline float ContactShadowArchive::offset() const {
  // @@protoc_insertion_point(field_get:TSD.ContactShadowArchive.offset)
  return _internal_offset();
}
inline void ContactShadowArchive::_internal_set_offset(float value) {
  _has_bits_[0] |= 0x00000001u;
  offset_ = value;
}
inline void ContactShadowArchive::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:TSD.ContactShadowArchive.offset)
}

// -------------------------------------------------------------------

// CurvedShadowArchive

// optional float curve = 1 [default = 0.6];
inline bool CurvedShadowArchive::_internal_has_curve() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CurvedShadowArchive::has_curve() const {
  return _internal_has_curve();
}
inline void CurvedShadowArchive::clear_curve() {
  curve_ = 0.6f;
  _has_bits_[0] &= ~0x00000001u;
}
inline float CurvedShadowArchive::_internal_curve() const {
  return curve_;
}
inline float CurvedShadowArchive::curve() const {
  // @@protoc_insertion_point(field_get:TSD.CurvedShadowArchive.curve)
  return _internal_curve();
}
inline void CurvedShadowArchive::_internal_set_curve(float value) {
  _has_bits_[0] |= 0x00000001u;
  curve_ = value;
}
inline void CurvedShadowArchive::set_curve(float value) {
  _internal_set_curve(value);
  // @@protoc_insertion_point(field_set:TSD.CurvedShadowArchive.curve)
}

// -------------------------------------------------------------------

// ReflectionArchive

// optional float opacity = 1 [default = 0.5];
inline bool ReflectionArchive::_internal_has_opacity() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReflectionArchive::has_opacity() const {
  return _internal_has_opacity();
}
inline void ReflectionArchive::clear_opacity() {
  opacity_ = 0.5f;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ReflectionArchive::_internal_opacity() const {
  return opacity_;
}
inline float ReflectionArchive::opacity() const {
  // @@protoc_insertion_point(field_get:TSD.ReflectionArchive.opacity)
  return _internal_opacity();
}
inline void ReflectionArchive::_internal_set_opacity(float value) {
  _has_bits_[0] |= 0x00000001u;
  opacity_ = value;
}
inline void ReflectionArchive::set_opacity(float value) {
  _internal_set_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.ReflectionArchive.opacity)
}

// -------------------------------------------------------------------

// ImageAdjustmentsArchive

// optional float exposure = 1;
inline bool ImageAdjustmentsArchive::_internal_has_exposure() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_exposure() const {
  return _internal_has_exposure();
}
inline void ImageAdjustmentsArchive::clear_exposure() {
  exposure_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ImageAdjustmentsArchive::_internal_exposure() const {
  return exposure_;
}
inline float ImageAdjustmentsArchive::exposure() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.exposure)
  return _internal_exposure();
}
inline void ImageAdjustmentsArchive::_internal_set_exposure(float value) {
  _has_bits_[0] |= 0x00000001u;
  exposure_ = value;
}
inline void ImageAdjustmentsArchive::set_exposure(float value) {
  _internal_set_exposure(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.exposure)
}

// optional float saturation = 2;
inline bool ImageAdjustmentsArchive::_internal_has_saturation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_saturation() const {
  return _internal_has_saturation();
}
inline void ImageAdjustmentsArchive::clear_saturation() {
  saturation_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ImageAdjustmentsArchive::_internal_saturation() const {
  return saturation_;
}
inline float ImageAdjustmentsArchive::saturation() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.saturation)
  return _internal_saturation();
}
inline void ImageAdjustmentsArchive::_internal_set_saturation(float value) {
  _has_bits_[0] |= 0x00000002u;
  saturation_ = value;
}
inline void ImageAdjustmentsArchive::set_saturation(float value) {
  _internal_set_saturation(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.saturation)
}

// optional float contrast = 3;
inline bool ImageAdjustmentsArchive::_internal_has_contrast() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_contrast() const {
  return _internal_has_contrast();
}
inline void ImageAdjustmentsArchive::clear_contrast() {
  contrast_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ImageAdjustmentsArchive::_internal_contrast() const {
  return contrast_;
}
inline float ImageAdjustmentsArchive::contrast() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.contrast)
  return _internal_contrast();
}
inline void ImageAdjustmentsArchive::_internal_set_contrast(float value) {
  _has_bits_[0] |= 0x00000004u;
  contrast_ = value;
}
inline void ImageAdjustmentsArchive::set_contrast(float value) {
  _internal_set_contrast(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.contrast)
}

// optional float highlights = 4;
inline bool ImageAdjustmentsArchive::_internal_has_highlights() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_highlights() const {
  return _internal_has_highlights();
}
inline void ImageAdjustmentsArchive::clear_highlights() {
  highlights_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float ImageAdjustmentsArchive::_internal_highlights() const {
  return highlights_;
}
inline float ImageAdjustmentsArchive::highlights() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.highlights)
  return _internal_highlights();
}
inline void ImageAdjustmentsArchive::_internal_set_highlights(float value) {
  _has_bits_[0] |= 0x00000008u;
  highlights_ = value;
}
inline void ImageAdjustmentsArchive::set_highlights(float value) {
  _internal_set_highlights(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.highlights)
}

// optional float shadows = 5;
inline bool ImageAdjustmentsArchive::_internal_has_shadows() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_shadows() const {
  return _internal_has_shadows();
}
inline void ImageAdjustmentsArchive::clear_shadows() {
  shadows_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float ImageAdjustmentsArchive::_internal_shadows() const {
  return shadows_;
}
inline float ImageAdjustmentsArchive::shadows() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.shadows)
  return _internal_shadows();
}
inline void ImageAdjustmentsArchive::_internal_set_shadows(float value) {
  _has_bits_[0] |= 0x00000010u;
  shadows_ = value;
}
inline void ImageAdjustmentsArchive::set_shadows(float value) {
  _internal_set_shadows(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.shadows)
}

// optional float sharpness = 6;
inline bool ImageAdjustmentsArchive::_internal_has_sharpness() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_sharpness() const {
  return _internal_has_sharpness();
}
inline void ImageAdjustmentsArchive::clear_sharpness() {
  sharpness_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float ImageAdjustmentsArchive::_internal_sharpness() const {
  return sharpness_;
}
inline float ImageAdjustmentsArchive::sharpness() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.sharpness)
  return _internal_sharpness();
}
inline void ImageAdjustmentsArchive::_internal_set_sharpness(float value) {
  _has_bits_[0] |= 0x00000020u;
  sharpness_ = value;
}
inline void ImageAdjustmentsArchive::set_sharpness(float value) {
  _internal_set_sharpness(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.sharpness)
}

// optional float denoise = 7;
inline bool ImageAdjustmentsArchive::_internal_has_denoise() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_denoise() const {
  return _internal_has_denoise();
}
inline void ImageAdjustmentsArchive::clear_denoise() {
  denoise_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float ImageAdjustmentsArchive::_internal_denoise() const {
  return denoise_;
}
inline float ImageAdjustmentsArchive::denoise() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.denoise)
  return _internal_denoise();
}
inline void ImageAdjustmentsArchive::_internal_set_denoise(float value) {
  _has_bits_[0] |= 0x00000040u;
  denoise_ = value;
}
inline void ImageAdjustmentsArchive::set_denoise(float value) {
  _internal_set_denoise(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.denoise)
}

// optional float temperature = 8;
inline bool ImageAdjustmentsArchive::_internal_has_temperature() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_temperature() const {
  return _internal_has_temperature();
}
inline void ImageAdjustmentsArchive::clear_temperature() {
  temperature_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float ImageAdjustmentsArchive::_internal_temperature() const {
  return temperature_;
}
inline float ImageAdjustmentsArchive::temperature() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.temperature)
  return _internal_temperature();
}
inline void ImageAdjustmentsArchive::_internal_set_temperature(float value) {
  _has_bits_[0] |= 0x00000080u;
  temperature_ = value;
}
inline void ImageAdjustmentsArchive::set_temperature(float value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.temperature)
}

// optional float tint = 9;
inline bool ImageAdjustmentsArchive::_internal_has_tint() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_tint() const {
  return _internal_has_tint();
}
inline void ImageAdjustmentsArchive::clear_tint() {
  tint_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float ImageAdjustmentsArchive::_internal_tint() const {
  return tint_;
}
inline float ImageAdjustmentsArchive::tint() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.tint)
  return _internal_tint();
}
inline void ImageAdjustmentsArchive::_internal_set_tint(float value) {
  _has_bits_[0] |= 0x00000100u;
  tint_ = value;
}
inline void ImageAdjustmentsArchive::set_tint(float value) {
  _internal_set_tint(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.tint)
}

// optional float bottom_level = 10;
inline bool ImageAdjustmentsArchive::_internal_has_bottom_level() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_bottom_level() const {
  return _internal_has_bottom_level();
}
inline void ImageAdjustmentsArchive::clear_bottom_level() {
  bottom_level_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float ImageAdjustmentsArchive::_internal_bottom_level() const {
  return bottom_level_;
}
inline float ImageAdjustmentsArchive::bottom_level() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.bottom_level)
  return _internal_bottom_level();
}
inline void ImageAdjustmentsArchive::_internal_set_bottom_level(float value) {
  _has_bits_[0] |= 0x00000200u;
  bottom_level_ = value;
}
inline void ImageAdjustmentsArchive::set_bottom_level(float value) {
  _internal_set_bottom_level(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.bottom_level)
}

// optional float top_level = 11 [default = 1];
inline bool ImageAdjustmentsArchive::_internal_has_top_level() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_top_level() const {
  return _internal_has_top_level();
}
inline void ImageAdjustmentsArchive::clear_top_level() {
  top_level_ = 1;
  _has_bits_[0] &= ~0x00002000u;
}
inline float ImageAdjustmentsArchive::_internal_top_level() const {
  return top_level_;
}
inline float ImageAdjustmentsArchive::top_level() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.top_level)
  return _internal_top_level();
}
inline void ImageAdjustmentsArchive::_internal_set_top_level(float value) {
  _has_bits_[0] |= 0x00002000u;
  top_level_ = value;
}
inline void ImageAdjustmentsArchive::set_top_level(float value) {
  _internal_set_top_level(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.top_level)
}

// optional float gamma = 12;
inline bool ImageAdjustmentsArchive::_internal_has_gamma() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_gamma() const {
  return _internal_has_gamma();
}
inline void ImageAdjustmentsArchive::clear_gamma() {
  gamma_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float ImageAdjustmentsArchive::_internal_gamma() const {
  return gamma_;
}
inline float ImageAdjustmentsArchive::gamma() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.gamma)
  return _internal_gamma();
}
inline void ImageAdjustmentsArchive::_internal_set_gamma(float value) {
  _has_bits_[0] |= 0x00000400u;
  gamma_ = value;
}
inline void ImageAdjustmentsArchive::set_gamma(float value) {
  _internal_set_gamma(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.gamma)
}

// optional bool enhance = 13 [default = false];
inline bool ImageAdjustmentsArchive::_internal_has_enhance() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_enhance() const {
  return _internal_has_enhance();
}
inline void ImageAdjustmentsArchive::clear_enhance() {
  enhance_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool ImageAdjustmentsArchive::_internal_enhance() const {
  return enhance_;
}
inline bool ImageAdjustmentsArchive::enhance() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.enhance)
  return _internal_enhance();
}
inline void ImageAdjustmentsArchive::_internal_set_enhance(bool value) {
  _has_bits_[0] |= 0x00000800u;
  enhance_ = value;
}
inline void ImageAdjustmentsArchive::set_enhance(bool value) {
  _internal_set_enhance(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.enhance)
}

// optional bool represents_sage_adjustments = 14 [default = false];
inline bool ImageAdjustmentsArchive::_internal_has_represents_sage_adjustments() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_represents_sage_adjustments() const {
  return _internal_has_represents_sage_adjustments();
}
inline void ImageAdjustmentsArchive::clear_represents_sage_adjustments() {
  represents_sage_adjustments_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool ImageAdjustmentsArchive::_internal_represents_sage_adjustments() const {
  return represents_sage_adjustments_;
}
inline bool ImageAdjustmentsArchive::represents_sage_adjustments() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.represents_sage_adjustments)
  return _internal_represents_sage_adjustments();
}
inline void ImageAdjustmentsArchive::_internal_set_represents_sage_adjustments(bool value) {
  _has_bits_[0] |= 0x00001000u;
  represents_sage_adjustments_ = value;
}
inline void ImageAdjustmentsArchive::set_represents_sage_adjustments(bool value) {
  _internal_set_represents_sage_adjustments(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.represents_sage_adjustments)
}

// -------------------------------------------------------------------

// ShapeStylePropertiesArchive

// optional .TSD.FillArchive fill = 1;
inline bool ShapeStylePropertiesArchive::_internal_has_fill() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || fill_ != nullptr);
  return value;
}
inline bool ShapeStylePropertiesArchive::has_fill() const {
  return _internal_has_fill();
}
inline void ShapeStylePropertiesArchive::clear_fill() {
  if (fill_ != nullptr) fill_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::FillArchive& ShapeStylePropertiesArchive::_internal_fill() const {
  const ::TSD::FillArchive* p = fill_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::FillArchive&>(
      ::TSD::_FillArchive_default_instance_);
}
inline const ::TSD::FillArchive& ShapeStylePropertiesArchive::fill() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStylePropertiesArchive.fill)
  return _internal_fill();
}
inline void ShapeStylePropertiesArchive::unsafe_arena_set_allocated_fill(
    ::TSD::FillArchive* fill) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fill_);
  }
  fill_ = fill;
  if (fill) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeStylePropertiesArchive.fill)
}
inline ::TSD::FillArchive* ShapeStylePropertiesArchive::release_fill() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::FillArchive* temp = fill_;
  fill_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::FillArchive* ShapeStylePropertiesArchive::unsafe_arena_release_fill() {
  // @@protoc_insertion_point(field_release:TSD.ShapeStylePropertiesArchive.fill)
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::FillArchive* temp = fill_;
  fill_ = nullptr;
  return temp;
}
inline ::TSD::FillArchive* ShapeStylePropertiesArchive::_internal_mutable_fill() {
  _has_bits_[0] |= 0x00000001u;
  if (fill_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::FillArchive>(GetArena());
    fill_ = p;
  }
  return fill_;
}
inline ::TSD::FillArchive* ShapeStylePropertiesArchive::mutable_fill() {
  // @@protoc_insertion_point(field_mutable:TSD.ShapeStylePropertiesArchive.fill)
  return _internal_mutable_fill();
}
inline void ShapeStylePropertiesArchive::set_allocated_fill(::TSD::FillArchive* fill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fill_;
  }
  if (fill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fill);
    if (message_arena != submessage_arena) {
      fill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fill, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fill_ = fill;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeStylePropertiesArchive.fill)
}

// optional .TSD.StrokeArchive stroke = 2;
inline bool ShapeStylePropertiesArchive::_internal_has_stroke() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || stroke_ != nullptr);
  return value;
}
inline bool ShapeStylePropertiesArchive::has_stroke() const {
  return _internal_has_stroke();
}
inline void ShapeStylePropertiesArchive::clear_stroke() {
  if (stroke_ != nullptr) stroke_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::StrokeArchive& ShapeStylePropertiesArchive::_internal_stroke() const {
  const ::TSD::StrokeArchive* p = stroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::StrokeArchive&>(
      ::TSD::_StrokeArchive_default_instance_);
}
inline const ::TSD::StrokeArchive& ShapeStylePropertiesArchive::stroke() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStylePropertiesArchive.stroke)
  return _internal_stroke();
}
inline void ShapeStylePropertiesArchive::unsafe_arena_set_allocated_stroke(
    ::TSD::StrokeArchive* stroke) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_);
  }
  stroke_ = stroke;
  if (stroke) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeStylePropertiesArchive.stroke)
}
inline ::TSD::StrokeArchive* ShapeStylePropertiesArchive::release_stroke() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::StrokeArchive* temp = stroke_;
  stroke_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::StrokeArchive* ShapeStylePropertiesArchive::unsafe_arena_release_stroke() {
  // @@protoc_insertion_point(field_release:TSD.ShapeStylePropertiesArchive.stroke)
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::StrokeArchive* temp = stroke_;
  stroke_ = nullptr;
  return temp;
}
inline ::TSD::StrokeArchive* ShapeStylePropertiesArchive::_internal_mutable_stroke() {
  _has_bits_[0] |= 0x00000002u;
  if (stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::StrokeArchive>(GetArena());
    stroke_ = p;
  }
  return stroke_;
}
inline ::TSD::StrokeArchive* ShapeStylePropertiesArchive::mutable_stroke() {
  // @@protoc_insertion_point(field_mutable:TSD.ShapeStylePropertiesArchive.stroke)
  return _internal_mutable_stroke();
}
inline void ShapeStylePropertiesArchive::set_allocated_stroke(::TSD::StrokeArchive* stroke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stroke_;
  }
  if (stroke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stroke);
    if (message_arena != submessage_arena) {
      stroke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stroke, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  stroke_ = stroke;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeStylePropertiesArchive.stroke)
}

// optional float opacity = 3;
inline bool ShapeStylePropertiesArchive::_internal_has_opacity() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ShapeStylePropertiesArchive::has_opacity() const {
  return _internal_has_opacity();
}
inline void ShapeStylePropertiesArchive::clear_opacity() {
  opacity_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float ShapeStylePropertiesArchive::_internal_opacity() const {
  return opacity_;
}
inline float ShapeStylePropertiesArchive::opacity() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStylePropertiesArchive.opacity)
  return _internal_opacity();
}
inline void ShapeStylePropertiesArchive::_internal_set_opacity(float value) {
  _has_bits_[0] |= 0x00000040u;
  opacity_ = value;
}
inline void ShapeStylePropertiesArchive::set_opacity(float value) {
  _internal_set_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.ShapeStylePropertiesArchive.opacity)
}

// optional .TSD.ShadowArchive shadow = 4;
inline bool ShapeStylePropertiesArchive::_internal_has_shadow() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || shadow_ != nullptr);
  return value;
}
inline bool ShapeStylePropertiesArchive::has_shadow() const {
  return _internal_has_shadow();
}
inline void ShapeStylePropertiesArchive::clear_shadow() {
  if (shadow_ != nullptr) shadow_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::ShadowArchive& ShapeStylePropertiesArchive::_internal_shadow() const {
  const ::TSD::ShadowArchive* p = shadow_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ShadowArchive&>(
      ::TSD::_ShadowArchive_default_instance_);
}
inline const ::TSD::ShadowArchive& ShapeStylePropertiesArchive::shadow() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStylePropertiesArchive.shadow)
  return _internal_shadow();
}
inline void ShapeStylePropertiesArchive::unsafe_arena_set_allocated_shadow(
    ::TSD::ShadowArchive* shadow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shadow_);
  }
  shadow_ = shadow;
  if (shadow) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeStylePropertiesArchive.shadow)
}
inline ::TSD::ShadowArchive* ShapeStylePropertiesArchive::release_shadow() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::ShadowArchive* temp = shadow_;
  shadow_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::ShadowArchive* ShapeStylePropertiesArchive::unsafe_arena_release_shadow() {
  // @@protoc_insertion_point(field_release:TSD.ShapeStylePropertiesArchive.shadow)
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::ShadowArchive* temp = shadow_;
  shadow_ = nullptr;
  return temp;
}
inline ::TSD::ShadowArchive* ShapeStylePropertiesArchive::_internal_mutable_shadow() {
  _has_bits_[0] |= 0x00000004u;
  if (shadow_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ShadowArchive>(GetArena());
    shadow_ = p;
  }
  return shadow_;
}
inline ::TSD::ShadowArchive* ShapeStylePropertiesArchive::mutable_shadow() {
  // @@protoc_insertion_point(field_mutable:TSD.ShapeStylePropertiesArchive.shadow)
  return _internal_mutable_shadow();
}
inline void ShapeStylePropertiesArchive::set_allocated_shadow(::TSD::ShadowArchive* shadow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete shadow_;
  }
  if (shadow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(shadow);
    if (message_arena != submessage_arena) {
      shadow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shadow, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  shadow_ = shadow;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeStylePropertiesArchive.shadow)
}

// optional .TSD.ReflectionArchive reflection = 5;
inline bool ShapeStylePropertiesArchive::_internal_has_reflection() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || reflection_ != nullptr);
  return value;
}
inline bool ShapeStylePropertiesArchive::has_reflection() const {
  return _internal_has_reflection();
}
inline void ShapeStylePropertiesArchive::clear_reflection() {
  if (reflection_ != nullptr) reflection_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::TSD::ReflectionArchive& ShapeStylePropertiesArchive::_internal_reflection() const {
  const ::TSD::ReflectionArchive* p = reflection_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ReflectionArchive&>(
      ::TSD::_ReflectionArchive_default_instance_);
}
inline const ::TSD::ReflectionArchive& ShapeStylePropertiesArchive::reflection() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStylePropertiesArchive.reflection)
  return _internal_reflection();
}
inline void ShapeStylePropertiesArchive::unsafe_arena_set_allocated_reflection(
    ::TSD::ReflectionArchive* reflection) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reflection_);
  }
  reflection_ = reflection;
  if (reflection) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeStylePropertiesArchive.reflection)
}
inline ::TSD::ReflectionArchive* ShapeStylePropertiesArchive::release_reflection() {
  _has_bits_[0] &= ~0x00000008u;
  ::TSD::ReflectionArchive* temp = reflection_;
  reflection_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::ReflectionArchive* ShapeStylePropertiesArchive::unsafe_arena_release_reflection() {
  // @@protoc_insertion_point(field_release:TSD.ShapeStylePropertiesArchive.reflection)
  _has_bits_[0] &= ~0x00000008u;
  ::TSD::ReflectionArchive* temp = reflection_;
  reflection_ = nullptr;
  return temp;
}
inline ::TSD::ReflectionArchive* ShapeStylePropertiesArchive::_internal_mutable_reflection() {
  _has_bits_[0] |= 0x00000008u;
  if (reflection_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ReflectionArchive>(GetArena());
    reflection_ = p;
  }
  return reflection_;
}
inline ::TSD::ReflectionArchive* ShapeStylePropertiesArchive::mutable_reflection() {
  // @@protoc_insertion_point(field_mutable:TSD.ShapeStylePropertiesArchive.reflection)
  return _internal_mutable_reflection();
}
inline void ShapeStylePropertiesArchive::set_allocated_reflection(::TSD::ReflectionArchive* reflection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reflection_;
  }
  if (reflection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(reflection);
    if (message_arena != submessage_arena) {
      reflection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reflection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  reflection_ = reflection;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeStylePropertiesArchive.reflection)
}

// optional .TSD.LineEndArchive head_line_end = 6;
inline bool ShapeStylePropertiesArchive::_internal_has_head_line_end() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || head_line_end_ != nullptr);
  return value;
}
inline bool ShapeStylePropertiesArchive::has_head_line_end() const {
  return _internal_has_head_line_end();
}
inline void ShapeStylePropertiesArchive::clear_head_line_end() {
  if (head_line_end_ != nullptr) head_line_end_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::TSD::LineEndArchive& ShapeStylePropertiesArchive::_internal_head_line_end() const {
  const ::TSD::LineEndArchive* p = head_line_end_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::LineEndArchive&>(
      ::TSD::_LineEndArchive_default_instance_);
}
inline const ::TSD::LineEndArchive& ShapeStylePropertiesArchive::head_line_end() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStylePropertiesArchive.head_line_end)
  return _internal_head_line_end();
}
inline void ShapeStylePropertiesArchive::unsafe_arena_set_allocated_head_line_end(
    ::TSD::LineEndArchive* head_line_end) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_line_end_);
  }
  head_line_end_ = head_line_end;
  if (head_line_end) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeStylePropertiesArchive.head_line_end)
}
inline ::TSD::LineEndArchive* ShapeStylePropertiesArchive::release_head_line_end() {
  _has_bits_[0] &= ~0x00000010u;
  ::TSD::LineEndArchive* temp = head_line_end_;
  head_line_end_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::LineEndArchive* ShapeStylePropertiesArchive::unsafe_arena_release_head_line_end() {
  // @@protoc_insertion_point(field_release:TSD.ShapeStylePropertiesArchive.head_line_end)
  _has_bits_[0] &= ~0x00000010u;
  ::TSD::LineEndArchive* temp = head_line_end_;
  head_line_end_ = nullptr;
  return temp;
}
inline ::TSD::LineEndArchive* ShapeStylePropertiesArchive::_internal_mutable_head_line_end() {
  _has_bits_[0] |= 0x00000010u;
  if (head_line_end_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::LineEndArchive>(GetArena());
    head_line_end_ = p;
  }
  return head_line_end_;
}
inline ::TSD::LineEndArchive* ShapeStylePropertiesArchive::mutable_head_line_end() {
  // @@protoc_insertion_point(field_mutable:TSD.ShapeStylePropertiesArchive.head_line_end)
  return _internal_mutable_head_line_end();
}
inline void ShapeStylePropertiesArchive::set_allocated_head_line_end(::TSD::LineEndArchive* head_line_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete head_line_end_;
  }
  if (head_line_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(head_line_end);
    if (message_arena != submessage_arena) {
      head_line_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head_line_end, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  head_line_end_ = head_line_end;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeStylePropertiesArchive.head_line_end)
}

// optional .TSD.LineEndArchive tail_line_end = 7;
inline bool ShapeStylePropertiesArchive::_internal_has_tail_line_end() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || tail_line_end_ != nullptr);
  return value;
}
inline bool ShapeStylePropertiesArchive::has_tail_line_end() const {
  return _internal_has_tail_line_end();
}
inline void ShapeStylePropertiesArchive::clear_tail_line_end() {
  if (tail_line_end_ != nullptr) tail_line_end_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::TSD::LineEndArchive& ShapeStylePropertiesArchive::_internal_tail_line_end() const {
  const ::TSD::LineEndArchive* p = tail_line_end_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::LineEndArchive&>(
      ::TSD::_LineEndArchive_default_instance_);
}
inline const ::TSD::LineEndArchive& ShapeStylePropertiesArchive::tail_line_end() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStylePropertiesArchive.tail_line_end)
  return _internal_tail_line_end();
}
inline void ShapeStylePropertiesArchive::unsafe_arena_set_allocated_tail_line_end(
    ::TSD::LineEndArchive* tail_line_end) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tail_line_end_);
  }
  tail_line_end_ = tail_line_end;
  if (tail_line_end) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeStylePropertiesArchive.tail_line_end)
}
inline ::TSD::LineEndArchive* ShapeStylePropertiesArchive::release_tail_line_end() {
  _has_bits_[0] &= ~0x00000020u;
  ::TSD::LineEndArchive* temp = tail_line_end_;
  tail_line_end_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::LineEndArchive* ShapeStylePropertiesArchive::unsafe_arena_release_tail_line_end() {
  // @@protoc_insertion_point(field_release:TSD.ShapeStylePropertiesArchive.tail_line_end)
  _has_bits_[0] &= ~0x00000020u;
  ::TSD::LineEndArchive* temp = tail_line_end_;
  tail_line_end_ = nullptr;
  return temp;
}
inline ::TSD::LineEndArchive* ShapeStylePropertiesArchive::_internal_mutable_tail_line_end() {
  _has_bits_[0] |= 0x00000020u;
  if (tail_line_end_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::LineEndArchive>(GetArena());
    tail_line_end_ = p;
  }
  return tail_line_end_;
}
inline ::TSD::LineEndArchive* ShapeStylePropertiesArchive::mutable_tail_line_end() {
  // @@protoc_insertion_point(field_mutable:TSD.ShapeStylePropertiesArchive.tail_line_end)
  return _internal_mutable_tail_line_end();
}
inline void ShapeStylePropertiesArchive::set_allocated_tail_line_end(::TSD::LineEndArchive* tail_line_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tail_line_end_;
  }
  if (tail_line_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tail_line_end);
    if (message_arena != submessage_arena) {
      tail_line_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tail_line_end, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  tail_line_end_ = tail_line_end;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeStylePropertiesArchive.tail_line_end)
}

// -------------------------------------------------------------------

// ShapeStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool ShapeStyleArchive::_internal_has_super() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || super_ != nullptr);
  return value;
}
inline bool ShapeStyleArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleArchive& ShapeStyleArchive::_internal_super() const {
  const ::TSS::StyleArchive* p = super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleArchive&>(
      ::TSS::_StyleArchive_default_instance_);
}
inline const ::TSS::StyleArchive& ShapeStyleArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStyleArchive.super)
  return _internal_super();
}
inline void ShapeStyleArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleArchive* super) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  super_ = super;
  if (super) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeStyleArchive.super)
}
inline ::TSS::StyleArchive* ShapeStyleArchive::release_super() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = super_;
  super_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSS::StyleArchive* ShapeStyleArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.ShapeStyleArchive.super)
  _has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = super_;
  super_ = nullptr;
  return temp;
}
inline ::TSS::StyleArchive* ShapeStyleArchive::_internal_mutable_super() {
  _has_bits_[0] |= 0x00000001u;
  if (super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleArchive>(GetArena());
    super_ = p;
  }
  return super_;
}
inline ::TSS::StyleArchive* ShapeStyleArchive::mutable_super() {
  // @@protoc_insertion_point(field_mutable:TSD.ShapeStyleArchive.super)
  return _internal_mutable_super();
}
inline void ShapeStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super)->GetArena();
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeStyleArchive.super)
}

// optional uint32 override_count = 10 [default = 0];
inline bool ShapeStyleArchive::_internal_has_override_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShapeStyleArchive::has_override_count() const {
  return _internal_has_override_count();
}
inline void ShapeStyleArchive::clear_override_count() {
  override_count_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ShapeStyleArchive::_internal_override_count() const {
  return override_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ShapeStyleArchive::override_count() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStyleArchive.override_count)
  return _internal_override_count();
}
inline void ShapeStyleArchive::_internal_set_override_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  override_count_ = value;
}
inline void ShapeStyleArchive::set_override_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_override_count(value);
  // @@protoc_insertion_point(field_set:TSD.ShapeStyleArchive.override_count)
}

// optional .TSD.ShapeStylePropertiesArchive shape_properties = 11;
inline bool ShapeStyleArchive::_internal_has_shape_properties() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || shape_properties_ != nullptr);
  return value;
}
inline bool ShapeStyleArchive::has_shape_properties() const {
  return _internal_has_shape_properties();
}
inline void ShapeStyleArchive::clear_shape_properties() {
  if (shape_properties_ != nullptr) shape_properties_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::ShapeStylePropertiesArchive& ShapeStyleArchive::_internal_shape_properties() const {
  const ::TSD::ShapeStylePropertiesArchive* p = shape_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ShapeStylePropertiesArchive&>(
      ::TSD::_ShapeStylePropertiesArchive_default_instance_);
}
inline const ::TSD::ShapeStylePropertiesArchive& ShapeStyleArchive::shape_properties() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStyleArchive.shape_properties)
  return _internal_shape_properties();
}
inline void ShapeStyleArchive::unsafe_arena_set_allocated_shape_properties(
    ::TSD::ShapeStylePropertiesArchive* shape_properties) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shape_properties_);
  }
  shape_properties_ = shape_properties;
  if (shape_properties) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeStyleArchive.shape_properties)
}
inline ::TSD::ShapeStylePropertiesArchive* ShapeStyleArchive::release_shape_properties() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::ShapeStylePropertiesArchive* temp = shape_properties_;
  shape_properties_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::ShapeStylePropertiesArchive* ShapeStyleArchive::unsafe_arena_release_shape_properties() {
  // @@protoc_insertion_point(field_release:TSD.ShapeStyleArchive.shape_properties)
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::ShapeStylePropertiesArchive* temp = shape_properties_;
  shape_properties_ = nullptr;
  return temp;
}
inline ::TSD::ShapeStylePropertiesArchive* ShapeStyleArchive::_internal_mutable_shape_properties() {
  _has_bits_[0] |= 0x00000002u;
  if (shape_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ShapeStylePropertiesArchive>(GetArena());
    shape_properties_ = p;
  }
  return shape_properties_;
}
inline ::TSD::ShapeStylePropertiesArchive* ShapeStyleArchive::mutable_shape_properties() {
  // @@protoc_insertion_point(field_mutable:TSD.ShapeStyleArchive.shape_properties)
  return _internal_mutable_shape_properties();
}
inline void ShapeStyleArchive::set_allocated_shape_properties(::TSD::ShapeStylePropertiesArchive* shape_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete shape_properties_;
  }
  if (shape_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(shape_properties);
    if (message_arena != submessage_arena) {
      shape_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shape_properties, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  shape_properties_ = shape_properties;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeStyleArchive.shape_properties)
}

// -------------------------------------------------------------------

// MediaStylePropertiesArchive

// optional .TSD.StrokeArchive stroke = 1;
inline bool MediaStylePropertiesArchive::_internal_has_stroke() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || stroke_ != nullptr);
  return value;
}
inline bool MediaStylePropertiesArchive::has_stroke() const {
  return _internal_has_stroke();
}
inline void MediaStylePropertiesArchive::clear_stroke() {
  if (stroke_ != nullptr) stroke_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::StrokeArchive& MediaStylePropertiesArchive::_internal_stroke() const {
  const ::TSD::StrokeArchive* p = stroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::StrokeArchive&>(
      ::TSD::_StrokeArchive_default_instance_);
}
inline const ::TSD::StrokeArchive& MediaStylePropertiesArchive::stroke() const {
  // @@protoc_insertion_point(field_get:TSD.MediaStylePropertiesArchive.stroke)
  return _internal_stroke();
}
inline void MediaStylePropertiesArchive::unsafe_arena_set_allocated_stroke(
    ::TSD::StrokeArchive* stroke) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_);
  }
  stroke_ = stroke;
  if (stroke) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MediaStylePropertiesArchive.stroke)
}
inline ::TSD::StrokeArchive* MediaStylePropertiesArchive::release_stroke() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::StrokeArchive* temp = stroke_;
  stroke_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::StrokeArchive* MediaStylePropertiesArchive::unsafe_arena_release_stroke() {
  // @@protoc_insertion_point(field_release:TSD.MediaStylePropertiesArchive.stroke)
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::StrokeArchive* temp = stroke_;
  stroke_ = nullptr;
  return temp;
}
inline ::TSD::StrokeArchive* MediaStylePropertiesArchive::_internal_mutable_stroke() {
  _has_bits_[0] |= 0x00000001u;
  if (stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::StrokeArchive>(GetArena());
    stroke_ = p;
  }
  return stroke_;
}
inline ::TSD::StrokeArchive* MediaStylePropertiesArchive::mutable_stroke() {
  // @@protoc_insertion_point(field_mutable:TSD.MediaStylePropertiesArchive.stroke)
  return _internal_mutable_stroke();
}
inline void MediaStylePropertiesArchive::set_allocated_stroke(::TSD::StrokeArchive* stroke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stroke_;
  }
  if (stroke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stroke);
    if (message_arena != submessage_arena) {
      stroke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stroke, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stroke_ = stroke;
  // @@protoc_insertion_point(field_set_allocated:TSD.MediaStylePropertiesArchive.stroke)
}

// optional float opacity = 2;
inline bool MediaStylePropertiesArchive::_internal_has_opacity() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MediaStylePropertiesArchive::has_opacity() const {
  return _internal_has_opacity();
}
inline void MediaStylePropertiesArchive::clear_opacity() {
  opacity_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float MediaStylePropertiesArchive::_internal_opacity() const {
  return opacity_;
}
inline float MediaStylePropertiesArchive::opacity() const {
  // @@protoc_insertion_point(field_get:TSD.MediaStylePropertiesArchive.opacity)
  return _internal_opacity();
}
inline void MediaStylePropertiesArchive::_internal_set_opacity(float value) {
  _has_bits_[0] |= 0x00000008u;
  opacity_ = value;
}
inline void MediaStylePropertiesArchive::set_opacity(float value) {
  _internal_set_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.MediaStylePropertiesArchive.opacity)
}

// optional .TSD.ShadowArchive shadow = 3;
inline bool MediaStylePropertiesArchive::_internal_has_shadow() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || shadow_ != nullptr);
  return value;
}
inline bool MediaStylePropertiesArchive::has_shadow() const {
  return _internal_has_shadow();
}
inline void MediaStylePropertiesArchive::clear_shadow() {
  if (shadow_ != nullptr) shadow_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::ShadowArchive& MediaStylePropertiesArchive::_internal_shadow() const {
  const ::TSD::ShadowArchive* p = shadow_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ShadowArchive&>(
      ::TSD::_ShadowArchive_default_instance_);
}
inline const ::TSD::ShadowArchive& MediaStylePropertiesArchive::shadow() const {
  // @@protoc_insertion_point(field_get:TSD.MediaStylePropertiesArchive.shadow)
  return _internal_shadow();
}
inline void MediaStylePropertiesArchive::unsafe_arena_set_allocated_shadow(
    ::TSD::ShadowArchive* shadow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shadow_);
  }
  shadow_ = shadow;
  if (shadow) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MediaStylePropertiesArchive.shadow)
}
inline ::TSD::ShadowArchive* MediaStylePropertiesArchive::release_shadow() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::ShadowArchive* temp = shadow_;
  shadow_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::ShadowArchive* MediaStylePropertiesArchive::unsafe_arena_release_shadow() {
  // @@protoc_insertion_point(field_release:TSD.MediaStylePropertiesArchive.shadow)
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::ShadowArchive* temp = shadow_;
  shadow_ = nullptr;
  return temp;
}
inline ::TSD::ShadowArchive* MediaStylePropertiesArchive::_internal_mutable_shadow() {
  _has_bits_[0] |= 0x00000002u;
  if (shadow_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ShadowArchive>(GetArena());
    shadow_ = p;
  }
  return shadow_;
}
inline ::TSD::ShadowArchive* MediaStylePropertiesArchive::mutable_shadow() {
  // @@protoc_insertion_point(field_mutable:TSD.MediaStylePropertiesArchive.shadow)
  return _internal_mutable_shadow();
}
inline void MediaStylePropertiesArchive::set_allocated_shadow(::TSD::ShadowArchive* shadow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete shadow_;
  }
  if (shadow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(shadow);
    if (message_arena != submessage_arena) {
      shadow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shadow, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  shadow_ = shadow;
  // @@protoc_insertion_point(field_set_allocated:TSD.MediaStylePropertiesArchive.shadow)
}

// optional .TSD.ReflectionArchive reflection = 4;
inline bool MediaStylePropertiesArchive::_internal_has_reflection() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || reflection_ != nullptr);
  return value;
}
inline bool MediaStylePropertiesArchive::has_reflection() const {
  return _internal_has_reflection();
}
inline void MediaStylePropertiesArchive::clear_reflection() {
  if (reflection_ != nullptr) reflection_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::ReflectionArchive& MediaStylePropertiesArchive::_internal_reflection() const {
  const ::TSD::ReflectionArchive* p = reflection_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ReflectionArchive&>(
      ::TSD::_ReflectionArchive_default_instance_);
}
inline const ::TSD::ReflectionArchive& MediaStylePropertiesArchive::reflection() const {
  // @@protoc_insertion_point(field_get:TSD.MediaStylePropertiesArchive.reflection)
  return _internal_reflection();
}
inline void MediaStylePropertiesArchive::unsafe_arena_set_allocated_reflection(
    ::TSD::ReflectionArchive* reflection) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reflection_);
  }
  reflection_ = reflection;
  if (reflection) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MediaStylePropertiesArchive.reflection)
}
inline ::TSD::ReflectionArchive* MediaStylePropertiesArchive::release_reflection() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::ReflectionArchive* temp = reflection_;
  reflection_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::ReflectionArchive* MediaStylePropertiesArchive::unsafe_arena_release_reflection() {
  // @@protoc_insertion_point(field_release:TSD.MediaStylePropertiesArchive.reflection)
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::ReflectionArchive* temp = reflection_;
  reflection_ = nullptr;
  return temp;
}
inline ::TSD::ReflectionArchive* MediaStylePropertiesArchive::_internal_mutable_reflection() {
  _has_bits_[0] |= 0x00000004u;
  if (reflection_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ReflectionArchive>(GetArena());
    reflection_ = p;
  }
  return reflection_;
}
inline ::TSD::ReflectionArchive* MediaStylePropertiesArchive::mutable_reflection() {
  // @@protoc_insertion_point(field_mutable:TSD.MediaStylePropertiesArchive.reflection)
  return _internal_mutable_reflection();
}
inline void MediaStylePropertiesArchive::set_allocated_reflection(::TSD::ReflectionArchive* reflection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reflection_;
  }
  if (reflection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(reflection);
    if (message_arena != submessage_arena) {
      reflection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reflection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  reflection_ = reflection;
  // @@protoc_insertion_point(field_set_allocated:TSD.MediaStylePropertiesArchive.reflection)
}

// -------------------------------------------------------------------

// MediaStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool MediaStyleArchive::_internal_has_super() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || super_ != nullptr);
  return value;
}
inline bool MediaStyleArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleArchive& MediaStyleArchive::_internal_super() const {
  const ::TSS::StyleArchive* p = super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleArchive&>(
      ::TSS::_StyleArchive_default_instance_);
}
inline const ::TSS::StyleArchive& MediaStyleArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.MediaStyleArchive.super)
  return _internal_super();
}
inline void MediaStyleArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleArchive* super) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  super_ = super;
  if (super) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MediaStyleArchive.super)
}
inline ::TSS::StyleArchive* MediaStyleArchive::release_super() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = super_;
  super_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSS::StyleArchive* MediaStyleArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.MediaStyleArchive.super)
  _has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = super_;
  super_ = nullptr;
  return temp;
}
inline ::TSS::StyleArchive* MediaStyleArchive::_internal_mutable_super() {
  _has_bits_[0] |= 0x00000001u;
  if (super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleArchive>(GetArena());
    super_ = p;
  }
  return super_;
}
inline ::TSS::StyleArchive* MediaStyleArchive::mutable_super() {
  // @@protoc_insertion_point(field_mutable:TSD.MediaStyleArchive.super)
  return _internal_mutable_super();
}
inline void MediaStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super)->GetArena();
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.MediaStyleArchive.super)
}

// optional uint32 override_count = 10 [default = 0];
inline bool MediaStyleArchive::_internal_has_override_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MediaStyleArchive::has_override_count() const {
  return _internal_has_override_count();
}
inline void MediaStyleArchive::clear_override_count() {
  override_count_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MediaStyleArchive::_internal_override_count() const {
  return override_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MediaStyleArchive::override_count() const {
  // @@protoc_insertion_point(field_get:TSD.MediaStyleArchive.override_count)
  return _internal_override_count();
}
inline void MediaStyleArchive::_internal_set_override_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  override_count_ = value;
}
inline void MediaStyleArchive::set_override_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_override_count(value);
  // @@protoc_insertion_point(field_set:TSD.MediaStyleArchive.override_count)
}

// optional .TSD.MediaStylePropertiesArchive media_properties = 11;
inline bool MediaStyleArchive::_internal_has_media_properties() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || media_properties_ != nullptr);
  return value;
}
inline bool MediaStyleArchive::has_media_properties() const {
  return _internal_has_media_properties();
}
inline void MediaStyleArchive::clear_media_properties() {
  if (media_properties_ != nullptr) media_properties_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::MediaStylePropertiesArchive& MediaStyleArchive::_internal_media_properties() const {
  const ::TSD::MediaStylePropertiesArchive* p = media_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::MediaStylePropertiesArchive&>(
      ::TSD::_MediaStylePropertiesArchive_default_instance_);
}
inline const ::TSD::MediaStylePropertiesArchive& MediaStyleArchive::media_properties() const {
  // @@protoc_insertion_point(field_get:TSD.MediaStyleArchive.media_properties)
  return _internal_media_properties();
}
inline void MediaStyleArchive::unsafe_arena_set_allocated_media_properties(
    ::TSD::MediaStylePropertiesArchive* media_properties) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(media_properties_);
  }
  media_properties_ = media_properties;
  if (media_properties) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MediaStyleArchive.media_properties)
}
inline ::TSD::MediaStylePropertiesArchive* MediaStyleArchive::release_media_properties() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::MediaStylePropertiesArchive* temp = media_properties_;
  media_properties_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::MediaStylePropertiesArchive* MediaStyleArchive::unsafe_arena_release_media_properties() {
  // @@protoc_insertion_point(field_release:TSD.MediaStyleArchive.media_properties)
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::MediaStylePropertiesArchive* temp = media_properties_;
  media_properties_ = nullptr;
  return temp;
}
inline ::TSD::MediaStylePropertiesArchive* MediaStyleArchive::_internal_mutable_media_properties() {
  _has_bits_[0] |= 0x00000002u;
  if (media_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::MediaStylePropertiesArchive>(GetArena());
    media_properties_ = p;
  }
  return media_properties_;
}
inline ::TSD::MediaStylePropertiesArchive* MediaStyleArchive::mutable_media_properties() {
  // @@protoc_insertion_point(field_mutable:TSD.MediaStyleArchive.media_properties)
  return _internal_mutable_media_properties();
}
inline void MediaStyleArchive::set_allocated_media_properties(::TSD::MediaStylePropertiesArchive* media_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete media_properties_;
  }
  if (media_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(media_properties);
    if (message_arena != submessage_arena) {
      media_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, media_properties, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  media_properties_ = media_properties;
  // @@protoc_insertion_point(field_set_allocated:TSD.MediaStyleArchive.media_properties)
}

// -------------------------------------------------------------------

// ThemePresetsArchive

// repeated .TSD.FillArchive gradient_fill_presets = 1;
inline int ThemePresetsArchive::_internal_gradient_fill_presets_size() const {
  return gradient_fill_presets_.size();
}
inline int ThemePresetsArchive::gradient_fill_presets_size() const {
  return _internal_gradient_fill_presets_size();
}
inline void ThemePresetsArchive::clear_gradient_fill_presets() {
  gradient_fill_presets_.Clear();
}
inline ::TSD::FillArchive* ThemePresetsArchive::mutable_gradient_fill_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.gradient_fill_presets)
  return gradient_fill_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >*
ThemePresetsArchive::mutable_gradient_fill_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.gradient_fill_presets)
  return &gradient_fill_presets_;
}
inline const ::TSD::FillArchive& ThemePresetsArchive::_internal_gradient_fill_presets(int index) const {
  return gradient_fill_presets_.Get(index);
}
inline const ::TSD::FillArchive& ThemePresetsArchive::gradient_fill_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.gradient_fill_presets)
  return _internal_gradient_fill_presets(index);
}
inline ::TSD::FillArchive* ThemePresetsArchive::_internal_add_gradient_fill_presets() {
  return gradient_fill_presets_.Add();
}
inline ::TSD::FillArchive* ThemePresetsArchive::add_gradient_fill_presets() {
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.gradient_fill_presets)
  return _internal_add_gradient_fill_presets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >&
ThemePresetsArchive::gradient_fill_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.gradient_fill_presets)
  return gradient_fill_presets_;
}

// repeated .TSD.FillArchive image_fill_presets = 2;
inline int ThemePresetsArchive::_internal_image_fill_presets_size() const {
  return image_fill_presets_.size();
}
inline int ThemePresetsArchive::image_fill_presets_size() const {
  return _internal_image_fill_presets_size();
}
inline void ThemePresetsArchive::clear_image_fill_presets() {
  image_fill_presets_.Clear();
}
inline ::TSD::FillArchive* ThemePresetsArchive::mutable_image_fill_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.image_fill_presets)
  return image_fill_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >*
ThemePresetsArchive::mutable_image_fill_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.image_fill_presets)
  return &image_fill_presets_;
}
inline const ::TSD::FillArchive& ThemePresetsArchive::_internal_image_fill_presets(int index) const {
  return image_fill_presets_.Get(index);
}
inline const ::TSD::FillArchive& ThemePresetsArchive::image_fill_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.image_fill_presets)
  return _internal_image_fill_presets(index);
}
inline ::TSD::FillArchive* ThemePresetsArchive::_internal_add_image_fill_presets() {
  return image_fill_presets_.Add();
}
inline ::TSD::FillArchive* ThemePresetsArchive::add_image_fill_presets() {
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.image_fill_presets)
  return _internal_add_image_fill_presets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >&
ThemePresetsArchive::image_fill_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.image_fill_presets)
  return image_fill_presets_;
}

// repeated .TSD.ShadowArchive shadow_presets = 3;
inline int ThemePresetsArchive::_internal_shadow_presets_size() const {
  return shadow_presets_.size();
}
inline int ThemePresetsArchive::shadow_presets_size() const {
  return _internal_shadow_presets_size();
}
inline void ThemePresetsArchive::clear_shadow_presets() {
  shadow_presets_.Clear();
}
inline ::TSD::ShadowArchive* ThemePresetsArchive::mutable_shadow_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.shadow_presets)
  return shadow_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::ShadowArchive >*
ThemePresetsArchive::mutable_shadow_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.shadow_presets)
  return &shadow_presets_;
}
inline const ::TSD::ShadowArchive& ThemePresetsArchive::_internal_shadow_presets(int index) const {
  return shadow_presets_.Get(index);
}
inline const ::TSD::ShadowArchive& ThemePresetsArchive::shadow_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.shadow_presets)
  return _internal_shadow_presets(index);
}
inline ::TSD::ShadowArchive* ThemePresetsArchive::_internal_add_shadow_presets() {
  return shadow_presets_.Add();
}
inline ::TSD::ShadowArchive* ThemePresetsArchive::add_shadow_presets() {
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.shadow_presets)
  return _internal_add_shadow_presets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::ShadowArchive >&
ThemePresetsArchive::shadow_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.shadow_presets)
  return shadow_presets_;
}

// repeated .TSP.Reference line_style_presets = 4;
inline int ThemePresetsArchive::_internal_line_style_presets_size() const {
  return line_style_presets_.size();
}
inline int ThemePresetsArchive::line_style_presets_size() const {
  return _internal_line_style_presets_size();
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_line_style_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.line_style_presets)
  return line_style_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_line_style_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.line_style_presets)
  return &line_style_presets_;
}
inline const ::TSP::Reference& ThemePresetsArchive::_internal_line_style_presets(int index) const {
  return line_style_presets_.Get(index);
}
inline const ::TSP::Reference& ThemePresetsArchive::line_style_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.line_style_presets)
  return _internal_line_style_presets(index);
}
inline ::TSP::Reference* ThemePresetsArchive::_internal_add_line_style_presets() {
  return line_style_presets_.Add();
}
inline ::TSP::Reference* ThemePresetsArchive::add_line_style_presets() {
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.line_style_presets)
  return _internal_add_line_style_presets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::line_style_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.line_style_presets)
  return line_style_presets_;
}

// repeated .TSP.Reference shape_style_presets = 5;
inline int ThemePresetsArchive::_internal_shape_style_presets_size() const {
  return shape_style_presets_.size();
}
inline int ThemePresetsArchive::shape_style_presets_size() const {
  return _internal_shape_style_presets_size();
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_shape_style_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.shape_style_presets)
  return shape_style_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_shape_style_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.shape_style_presets)
  return &shape_style_presets_;
}
inline const ::TSP::Reference& ThemePresetsArchive::_internal_shape_style_presets(int index) const {
  return shape_style_presets_.Get(index);
}
inline const ::TSP::Reference& ThemePresetsArchive::shape_style_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.shape_style_presets)
  return _internal_shape_style_presets(index);
}
inline ::TSP::Reference* ThemePresetsArchive::_internal_add_shape_style_presets() {
  return shape_style_presets_.Add();
}
inline ::TSP::Reference* ThemePresetsArchive::add_shape_style_presets() {
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.shape_style_presets)
  return _internal_add_shape_style_presets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::shape_style_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.shape_style_presets)
  return shape_style_presets_;
}

// repeated .TSP.Reference textbox_style_presets = 6;
inline int ThemePresetsArchive::_internal_textbox_style_presets_size() const {
  return textbox_style_presets_.size();
}
inline int ThemePresetsArchive::textbox_style_presets_size() const {
  return _internal_textbox_style_presets_size();
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_textbox_style_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.textbox_style_presets)
  return textbox_style_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_textbox_style_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.textbox_style_presets)
  return &textbox_style_presets_;
}
inline const ::TSP::Reference& ThemePresetsArchive::_internal_textbox_style_presets(int index) const {
  return textbox_style_presets_.Get(index);
}
inline const ::TSP::Reference& ThemePresetsArchive::textbox_style_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.textbox_style_presets)
  return _internal_textbox_style_presets(index);
}
inline ::TSP::Reference* ThemePresetsArchive::_internal_add_textbox_style_presets() {
  return textbox_style_presets_.Add();
}
inline ::TSP::Reference* ThemePresetsArchive::add_textbox_style_presets() {
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.textbox_style_presets)
  return _internal_add_textbox_style_presets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::textbox_style_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.textbox_style_presets)
  return textbox_style_presets_;
}

// repeated .TSP.Reference image_style_presets = 7;
inline int ThemePresetsArchive::_internal_image_style_presets_size() const {
  return image_style_presets_.size();
}
inline int ThemePresetsArchive::image_style_presets_size() const {
  return _internal_image_style_presets_size();
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_image_style_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.image_style_presets)
  return image_style_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_image_style_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.image_style_presets)
  return &image_style_presets_;
}
inline const ::TSP::Reference& ThemePresetsArchive::_internal_image_style_presets(int index) const {
  return image_style_presets_.Get(index);
}
inline const ::TSP::Reference& ThemePresetsArchive::image_style_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.image_style_presets)
  return _internal_image_style_presets(index);
}
inline ::TSP::Reference* ThemePresetsArchive::_internal_add_image_style_presets() {
  return image_style_presets_.Add();
}
inline ::TSP::Reference* ThemePresetsArchive::add_image_style_presets() {
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.image_style_presets)
  return _internal_add_image_style_presets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::image_style_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.image_style_presets)
  return image_style_presets_;
}

// repeated .TSP.Reference movie_style_presets = 8;
inline int ThemePresetsArchive::_internal_movie_style_presets_size() const {
  return movie_style_presets_.size();
}
inline int ThemePresetsArchive::movie_style_presets_size() const {
  return _internal_movie_style_presets_size();
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_movie_style_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.movie_style_presets)
  return movie_style_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_movie_style_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.movie_style_presets)
  return &movie_style_presets_;
}
inline const ::TSP::Reference& ThemePresetsArchive::_internal_movie_style_presets(int index) const {
  return movie_style_presets_.Get(index);
}
inline const ::TSP::Reference& ThemePresetsArchive::movie_style_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.movie_style_presets)
  return _internal_movie_style_presets(index);
}
inline ::TSP::Reference* ThemePresetsArchive::_internal_add_movie_style_presets() {
  return movie_style_presets_.Add();
}
inline ::TSP::Reference* ThemePresetsArchive::add_movie_style_presets() {
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.movie_style_presets)
  return _internal_add_movie_style_presets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::movie_style_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.movie_style_presets)
  return movie_style_presets_;
}

// repeated .TSP.Reference drawing_line_style_presets = 9;
inline int ThemePresetsArchive::_internal_drawing_line_style_presets_size() const {
  return drawing_line_style_presets_.size();
}
inline int ThemePresetsArchive::drawing_line_style_presets_size() const {
  return _internal_drawing_line_style_presets_size();
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_drawing_line_style_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.drawing_line_style_presets)
  return drawing_line_style_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_drawing_line_style_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.drawing_line_style_presets)
  return &drawing_line_style_presets_;
}
inline const ::TSP::Reference& ThemePresetsArchive::_internal_drawing_line_style_presets(int index) const {
  return drawing_line_style_presets_.Get(index);
}
inline const ::TSP::Reference& ThemePresetsArchive::drawing_line_style_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.drawing_line_style_presets)
  return _internal_drawing_line_style_presets(index);
}
inline ::TSP::Reference* ThemePresetsArchive::_internal_add_drawing_line_style_presets() {
  return drawing_line_style_presets_.Add();
}
inline ::TSP::Reference* ThemePresetsArchive::add_drawing_line_style_presets() {
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.drawing_line_style_presets)
  return _internal_add_drawing_line_style_presets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::drawing_line_style_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.drawing_line_style_presets)
  return drawing_line_style_presets_;
}

// -------------------------------------------------------------------

// ThemeReplaceFillPresetCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ThemeReplaceFillPresetCommandArchive::_internal_has_super() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || super_ != nullptr);
  return value;
}
inline bool ThemeReplaceFillPresetCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ThemeReplaceFillPresetCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ThemeReplaceFillPresetCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.ThemeReplaceFillPresetCommandArchive.super)
  return _internal_super();
}
inline void ThemeReplaceFillPresetCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  super_ = super;
  if (super) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.super)
}
inline ::TSK::CommandArchive* ThemeReplaceFillPresetCommandArchive::release_super() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = super_;
  super_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSK::CommandArchive* ThemeReplaceFillPresetCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.ThemeReplaceFillPresetCommandArchive.super)
  _has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = super_;
  super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ThemeReplaceFillPresetCommandArchive::_internal_mutable_super() {
  _has_bits_[0] |= 0x00000001u;
  if (super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArena());
    super_ = p;
  }
  return super_;
}
inline ::TSK::CommandArchive* ThemeReplaceFillPresetCommandArchive::mutable_super() {
  // @@protoc_insertion_point(field_mutable:TSD.ThemeReplaceFillPresetCommandArchive.super)
  return _internal_mutable_super();
}
inline void ThemeReplaceFillPresetCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super)->GetArena();
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.super)
}

// required .TSP.Reference theme = 2;
inline bool ThemeReplaceFillPresetCommandArchive::_internal_has_theme() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || theme_ != nullptr);
  return value;
}
inline bool ThemeReplaceFillPresetCommandArchive::has_theme() const {
  return _internal_has_theme();
}
inline const ::TSP::Reference& ThemeReplaceFillPresetCommandArchive::_internal_theme() const {
  const ::TSP::Reference* p = theme_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ThemeReplaceFillPresetCommandArchive::theme() const {
  // @@protoc_insertion_point(field_get:TSD.ThemeReplaceFillPresetCommandArchive.theme)
  return _internal_theme();
}
inline void ThemeReplaceFillPresetCommandArchive::unsafe_arena_set_allocated_theme(
    ::TSP::Reference* theme) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(theme_);
  }
  theme_ = theme;
  if (theme) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.theme)
}
inline ::TSP::Reference* ThemeReplaceFillPresetCommandArchive::release_theme() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = theme_;
  theme_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* ThemeReplaceFillPresetCommandArchive::unsafe_arena_release_theme() {
  // @@protoc_insertion_point(field_release:TSD.ThemeReplaceFillPresetCommandArchive.theme)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = theme_;
  theme_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ThemeReplaceFillPresetCommandArchive::_internal_mutable_theme() {
  _has_bits_[0] |= 0x00000002u;
  if (theme_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    theme_ = p;
  }
  return theme_;
}
inline ::TSP::Reference* ThemeReplaceFillPresetCommandArchive::mutable_theme() {
  // @@protoc_insertion_point(field_mutable:TSD.ThemeReplaceFillPresetCommandArchive.theme)
  return _internal_mutable_theme();
}
inline void ThemeReplaceFillPresetCommandArchive::set_allocated_theme(::TSP::Reference* theme) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(theme_);
  }
  if (theme) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(theme)->GetArena();
    if (message_arena != submessage_arena) {
      theme = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, theme, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  theme_ = theme;
  // @@protoc_insertion_point(field_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.theme)
}

// required .TSD.FillArchive fill = 3;
inline bool ThemeReplaceFillPresetCommandArchive::_internal_has_fill() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || fill_ != nullptr);
  return value;
}
inline bool ThemeReplaceFillPresetCommandArchive::has_fill() const {
  return _internal_has_fill();
}
inline void ThemeReplaceFillPresetCommandArchive::clear_fill() {
  if (fill_ != nullptr) fill_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::FillArchive& ThemeReplaceFillPresetCommandArchive::_internal_fill() const {
  const ::TSD::FillArchive* p = fill_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::FillArchive&>(
      ::TSD::_FillArchive_default_instance_);
}
inline const ::TSD::FillArchive& ThemeReplaceFillPresetCommandArchive::fill() const {
  // @@protoc_insertion_point(field_get:TSD.ThemeReplaceFillPresetCommandArchive.fill)
  return _internal_fill();
}
inline void ThemeReplaceFillPresetCommandArchive::unsafe_arena_set_allocated_fill(
    ::TSD::FillArchive* fill) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fill_);
  }
  fill_ = fill;
  if (fill) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.fill)
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::release_fill() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::FillArchive* temp = fill_;
  fill_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::unsafe_arena_release_fill() {
  // @@protoc_insertion_point(field_release:TSD.ThemeReplaceFillPresetCommandArchive.fill)
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::FillArchive* temp = fill_;
  fill_ = nullptr;
  return temp;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::_internal_mutable_fill() {
  _has_bits_[0] |= 0x00000004u;
  if (fill_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::FillArchive>(GetArena());
    fill_ = p;
  }
  return fill_;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::mutable_fill() {
  // @@protoc_insertion_point(field_mutable:TSD.ThemeReplaceFillPresetCommandArchive.fill)
  return _internal_mutable_fill();
}
inline void ThemeReplaceFillPresetCommandArchive::set_allocated_fill(::TSD::FillArchive* fill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fill_;
  }
  if (fill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fill);
    if (message_arena != submessage_arena) {
      fill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fill, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  fill_ = fill;
  // @@protoc_insertion_point(field_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.fill)
}

// required .TSD.FillArchive old_fill = 4;
inline bool ThemeReplaceFillPresetCommandArchive::_internal_has_old_fill() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || old_fill_ != nullptr);
  return value;
}
inline bool ThemeReplaceFillPresetCommandArchive::has_old_fill() const {
  return _internal_has_old_fill();
}
inline void ThemeReplaceFillPresetCommandArchive::clear_old_fill() {
  if (old_fill_ != nullptr) old_fill_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::TSD::FillArchive& ThemeReplaceFillPresetCommandArchive::_internal_old_fill() const {
  const ::TSD::FillArchive* p = old_fill_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::FillArchive&>(
      ::TSD::_FillArchive_default_instance_);
}
inline const ::TSD::FillArchive& ThemeReplaceFillPresetCommandArchive::old_fill() const {
  // @@protoc_insertion_point(field_get:TSD.ThemeReplaceFillPresetCommandArchive.old_fill)
  return _internal_old_fill();
}
inline void ThemeReplaceFillPresetCommandArchive::unsafe_arena_set_allocated_old_fill(
    ::TSD::FillArchive* old_fill) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_fill_);
  }
  old_fill_ = old_fill;
  if (old_fill) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.old_fill)
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::release_old_fill() {
  _has_bits_[0] &= ~0x00000008u;
  ::TSD::FillArchive* temp = old_fill_;
  old_fill_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::unsafe_arena_release_old_fill() {
  // @@protoc_insertion_point(field_release:TSD.ThemeReplaceFillPresetCommandArchive.old_fill)
  _has_bits_[0] &= ~0x00000008u;
  ::TSD::FillArchive* temp = old_fill_;
  old_fill_ = nullptr;
  return temp;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::_internal_mutable_old_fill() {
  _has_bits_[0] |= 0x00000008u;
  if (old_fill_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::FillArchive>(GetArena());
    old_fill_ = p;
  }
  return old_fill_;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::mutable_old_fill() {
  // @@protoc_insertion_point(field_mutable:TSD.ThemeReplaceFillPresetCommandArchive.old_fill)
  return _internal_mutable_old_fill();
}
inline void ThemeReplaceFillPresetCommandArchive::set_allocated_old_fill(::TSD::FillArchive* old_fill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete old_fill_;
  }
  if (old_fill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(old_fill);
    if (message_arena != submessage_arena) {
      old_fill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_fill, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  old_fill_ = old_fill;
  // @@protoc_insertion_point(field_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.old_fill)
}

// required uint32 index = 5;
inline bool ThemeReplaceFillPresetCommandArchive::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ThemeReplaceFillPresetCommandArchive::has_index() const {
  return _internal_has_index();
}
inline void ThemeReplaceFillPresetCommandArchive::clear_index() {
  index_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ThemeReplaceFillPresetCommandArchive::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ThemeReplaceFillPresetCommandArchive::index() const {
  // @@protoc_insertion_point(field_get:TSD.ThemeReplaceFillPresetCommandArchive.index)
  return _internal_index();
}
inline void ThemeReplaceFillPresetCommandArchive::_internal_set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  index_ = value;
}
inline void ThemeReplaceFillPresetCommandArchive::set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:TSD.ThemeReplaceFillPresetCommandArchive.index)
}

// -------------------------------------------------------------------

// DrawableArchive

// optional .TSD.GeometryArchive geometry = 1;
inline bool DrawableArchive::_internal_has_geometry() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || geometry_ != nullptr);
  return value;
}
inline bool DrawableArchive::has_geometry() const {
  return _internal_has_geometry();
}
inline void DrawableArchive::clear_geometry() {
  if (geometry_ != nullptr) geometry_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::GeometryArchive& DrawableArchive::_internal_geometry() const {
  const ::TSD::GeometryArchive* p = geometry_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::GeometryArchive&>(
      ::TSD::_GeometryArchive_default_instance_);
}
inline const ::TSD::GeometryArchive& DrawableArchive::geometry() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.geometry)
  return _internal_geometry();
}
inline void DrawableArchive::unsafe_arena_set_allocated_geometry(
    ::TSD::GeometryArchive* geometry) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry_);
  }
  geometry_ = geometry;
  if (geometry) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.DrawableArchive.geometry)
}
inline ::TSD::GeometryArchive* DrawableArchive::release_geometry() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::GeometryArchive* temp = geometry_;
  geometry_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::GeometryArchive* DrawableArchive::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_release:TSD.DrawableArchive.geometry)
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::GeometryArchive* temp = geometry_;
  geometry_ = nullptr;
  return temp;
}
inline ::TSD::GeometryArchive* DrawableArchive::_internal_mutable_geometry() {
  _has_bits_[0] |= 0x00000004u;
  if (geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::GeometryArchive>(GetArena());
    geometry_ = p;
  }
  return geometry_;
}
inline ::TSD::GeometryArchive* DrawableArchive::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.geometry)
  return _internal_mutable_geometry();
}
inline void DrawableArchive::set_allocated_geometry(::TSD::GeometryArchive* geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete geometry_;
  }
  if (geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(geometry);
    if (message_arena != submessage_arena) {
      geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:TSD.DrawableArchive.geometry)
}

// optional .TSP.Reference parent = 2;
inline bool DrawableArchive::_internal_has_parent() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || parent_ != nullptr);
  return value;
}
inline bool DrawableArchive::has_parent() const {
  return _internal_has_parent();
}
inline const ::TSP::Reference& DrawableArchive::_internal_parent() const {
  const ::TSP::Reference* p = parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DrawableArchive::parent() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.parent)
  return _internal_parent();
}
inline void DrawableArchive::unsafe_arena_set_allocated_parent(
    ::TSP::Reference* parent) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  parent_ = parent;
  if (parent) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.DrawableArchive.parent)
}
inline ::TSP::Reference* DrawableArchive::release_parent() {
  _has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = parent_;
  parent_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* DrawableArchive::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:TSD.DrawableArchive.parent)
  _has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = parent_;
  parent_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DrawableArchive::_internal_mutable_parent() {
  _has_bits_[0] |= 0x00000008u;
  if (parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    parent_ = p;
  }
  return parent_;
}
inline ::TSP::Reference* DrawableArchive::mutable_parent() {
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.parent)
  return _internal_mutable_parent();
}
inline void DrawableArchive::set_allocated_parent(::TSP::Reference* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent)->GetArena();
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:TSD.DrawableArchive.parent)
}

// optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 3;
inline bool DrawableArchive::_internal_has_exterior_text_wrap() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || exterior_text_wrap_ != nullptr);
  return value;
}
inline bool DrawableArchive::has_exterior_text_wrap() const {
  return _internal_has_exterior_text_wrap();
}
inline void DrawableArchive::clear_exterior_text_wrap() {
  if (exterior_text_wrap_ != nullptr) exterior_text_wrap_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::TSD::ExteriorTextWrapArchive& DrawableArchive::_internal_exterior_text_wrap() const {
  const ::TSD::ExteriorTextWrapArchive* p = exterior_text_wrap_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ExteriorTextWrapArchive&>(
      ::TSD::_ExteriorTextWrapArchive_default_instance_);
}
inline const ::TSD::ExteriorTextWrapArchive& DrawableArchive::exterior_text_wrap() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.exterior_text_wrap)
  return _internal_exterior_text_wrap();
}
inline void DrawableArchive::unsafe_arena_set_allocated_exterior_text_wrap(
    ::TSD::ExteriorTextWrapArchive* exterior_text_wrap) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(exterior_text_wrap_);
  }
  exterior_text_wrap_ = exterior_text_wrap;
  if (exterior_text_wrap) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.DrawableArchive.exterior_text_wrap)
}
inline ::TSD::ExteriorTextWrapArchive* DrawableArchive::release_exterior_text_wrap() {
  _has_bits_[0] &= ~0x00000010u;
  ::TSD::ExteriorTextWrapArchive* temp = exterior_text_wrap_;
  exterior_text_wrap_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::ExteriorTextWrapArchive* DrawableArchive::unsafe_arena_release_exterior_text_wrap() {
  // @@protoc_insertion_point(field_release:TSD.DrawableArchive.exterior_text_wrap)
  _has_bits_[0] &= ~0x00000010u;
  ::TSD::ExteriorTextWrapArchive* temp = exterior_text_wrap_;
  exterior_text_wrap_ = nullptr;
  return temp;
}
inline ::TSD::ExteriorTextWrapArchive* DrawableArchive::_internal_mutable_exterior_text_wrap() {
  _has_bits_[0] |= 0x00000010u;
  if (exterior_text_wrap_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ExteriorTextWrapArchive>(GetArena());
    exterior_text_wrap_ = p;
  }
  return exterior_text_wrap_;
}
inline ::TSD::ExteriorTextWrapArchive* DrawableArchive::mutable_exterior_text_wrap() {
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.exterior_text_wrap)
  return _internal_mutable_exterior_text_wrap();
}
inline void DrawableArchive::set_allocated_exterior_text_wrap(::TSD::ExteriorTextWrapArchive* exterior_text_wrap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete exterior_text_wrap_;
  }
  if (exterior_text_wrap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(exterior_text_wrap);
    if (message_arena != submessage_arena) {
      exterior_text_wrap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exterior_text_wrap, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  exterior_text_wrap_ = exterior_text_wrap;
  // @@protoc_insertion_point(field_set_allocated:TSD.DrawableArchive.exterior_text_wrap)
}

// optional string hyperlink_url = 4;
inline bool DrawableArchive::_internal_has_hyperlink_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DrawableArchive::has_hyperlink_url() const {
  return _internal_has_hyperlink_url();
}
inline void DrawableArchive::clear_hyperlink_url() {
  hyperlink_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DrawableArchive::hyperlink_url() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.hyperlink_url)
  return _internal_hyperlink_url();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void DrawableArchive::set_hyperlink_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 hyperlink_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.DrawableArchive.hyperlink_url)
}
inline std::string* DrawableArchive::mutable_hyperlink_url() {
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.hyperlink_url)
  return _internal_mutable_hyperlink_url();
}
inline const std::string& DrawableArchive::_internal_hyperlink_url() const {
  return hyperlink_url_.Get();
}
inline void DrawableArchive::_internal_set_hyperlink_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hyperlink_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* DrawableArchive::_internal_mutable_hyperlink_url() {
  _has_bits_[0] |= 0x00000001u;
  return hyperlink_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DrawableArchive::release_hyperlink_url() {
  // @@protoc_insertion_point(field_release:TSD.DrawableArchive.hyperlink_url)
  if (!_internal_has_hyperlink_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hyperlink_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DrawableArchive::set_allocated_hyperlink_url(std::string* hyperlink_url) {
  if (hyperlink_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hyperlink_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hyperlink_url,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.DrawableArchive.hyperlink_url)
}

// optional bool locked = 5;
inline bool DrawableArchive::_internal_has_locked() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DrawableArchive::has_locked() const {
  return _internal_has_locked();
}
inline void DrawableArchive::clear_locked() {
  locked_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool DrawableArchive::_internal_locked() const {
  return locked_;
}
inline bool DrawableArchive::locked() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.locked)
  return _internal_locked();
}
inline void DrawableArchive::_internal_set_locked(bool value) {
  _has_bits_[0] |= 0x00000100u;
  locked_ = value;
}
inline void DrawableArchive::set_locked(bool value) {
  _internal_set_locked(value);
  // @@protoc_insertion_point(field_set:TSD.DrawableArchive.locked)
}

// optional .TSP.Reference comment = 6;
inline bool DrawableArchive::_internal_has_comment() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || comment_ != nullptr);
  return value;
}
inline bool DrawableArchive::has_comment() const {
  return _internal_has_comment();
}
inline const ::TSP::Reference& DrawableArchive::_internal_comment() const {
  const ::TSP::Reference* p = comment_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DrawableArchive::comment() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.comment)
  return _internal_comment();
}
inline void DrawableArchive::unsafe_arena_set_allocated_comment(
    ::TSP::Reference* comment) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(comment_);
  }
  comment_ = comment;
  if (comment) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.DrawableArchive.comment)
}
inline ::TSP::Reference* DrawableArchive::release_comment() {
  _has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = comment_;
  comment_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* DrawableArchive::unsafe_arena_release_comment() {
  // @@protoc_insertion_point(field_release:TSD.DrawableArchive.comment)
  _has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = comment_;
  comment_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DrawableArchive::_internal_mutable_comment() {
  _has_bits_[0] |= 0x00000020u;
  if (comment_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    comment_ = p;
  }
  return comment_;
}
inline ::TSP::Reference* DrawableArchive::mutable_comment() {
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.comment)
  return _internal_mutable_comment();
}
inline void DrawableArchive::set_allocated_comment(::TSP::Reference* comment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(comment_);
  }
  if (comment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(comment)->GetArena();
    if (message_arena != submessage_arena) {
      comment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, comment, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  comment_ = comment;
  // @@protoc_insertion_point(field_set_allocated:TSD.DrawableArchive.comment)
}

// optional bool aspect_ratio_locked = 7;
inline bool DrawableArchive::_internal_has_aspect_ratio_locked() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DrawableArchive::has_aspect_ratio_locked() const {
  return _internal_has_aspect_ratio_locked();
}
inline void DrawableArchive::clear_aspect_ratio_locked() {
  aspect_ratio_locked_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool DrawableArchive::_internal_aspect_ratio_locked() const {
  return aspect_ratio_locked_;
}
inline bool DrawableArchive::aspect_ratio_locked() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.aspect_ratio_locked)
  return _internal_aspect_ratio_locked();
}
inline void DrawableArchive::_internal_set_aspect_ratio_locked(bool value) {
  _has_bits_[0] |= 0x00000200u;
  aspect_ratio_locked_ = value;
}
inline void DrawableArchive::set_aspect_ratio_locked(bool value) {
  _internal_set_aspect_ratio_locked(value);
  // @@protoc_insertion_point(field_set:TSD.DrawableArchive.aspect_ratio_locked)
}

// optional string accessibility_description = 8;
inline bool DrawableArchive::_internal_has_accessibility_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DrawableArchive::has_accessibility_description() const {
  return _internal_has_accessibility_description();
}
inline void DrawableArchive::clear_accessibility_description() {
  accessibility_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DrawableArchive::accessibility_description() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.accessibility_description)
  return _internal_accessibility_description();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void DrawableArchive::set_accessibility_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 accessibility_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.DrawableArchive.accessibility_description)
}
inline std::string* DrawableArchive::mutable_accessibility_description() {
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.accessibility_description)
  return _internal_mutable_accessibility_description();
}
inline const std::string& DrawableArchive::_internal_accessibility_description() const {
  return accessibility_description_.Get();
}
inline void DrawableArchive::_internal_set_accessibility_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  accessibility_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* DrawableArchive::_internal_mutable_accessibility_description() {
  _has_bits_[0] |= 0x00000002u;
  return accessibility_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DrawableArchive::release_accessibility_description() {
  // @@protoc_insertion_point(field_release:TSD.DrawableArchive.accessibility_description)
  if (!_internal_has_accessibility_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return accessibility_description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DrawableArchive::set_allocated_accessibility_description(std::string* accessibility_description) {
  if (accessibility_description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  accessibility_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), accessibility_description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.DrawableArchive.accessibility_description)
}

// repeated .TSP.Reference pencil_annotations = 9;
inline int DrawableArchive::_internal_pencil_annotations_size() const {
  return pencil_annotations_.size();
}
inline int DrawableArchive::pencil_annotations_size() const {
  return _internal_pencil_annotations_size();
}
inline ::TSP::Reference* DrawableArchive::mutable_pencil_annotations(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.pencil_annotations)
  return pencil_annotations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
DrawableArchive::mutable_pencil_annotations() {
  // @@protoc_insertion_point(field_mutable_list:TSD.DrawableArchive.pencil_annotations)
  return &pencil_annotations_;
}
inline const ::TSP::Reference& DrawableArchive::_internal_pencil_annotations(int index) const {
  return pencil_annotations_.Get(index);
}
inline const ::TSP::Reference& DrawableArchive::pencil_annotations(int index) const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.pencil_annotations)
  return _internal_pencil_annotations(index);
}
inline ::TSP::Reference* DrawableArchive::_internal_add_pencil_annotations() {
  return pencil_annotations_.Add();
}
inline ::TSP::Reference* DrawableArchive::add_pencil_annotations() {
  // @@protoc_insertion_point(field_add:TSD.DrawableArchive.pencil_annotations)
  return _internal_add_pencil_annotations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
DrawableArchive::pencil_annotations() const {
  // @@protoc_insertion_point(field_list:TSD.DrawableArchive.pencil_annotations)
  return pencil_annotations_;
}

// optional .TSP.Reference title = 10;
inline bool DrawableArchive::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || title_ != nullptr);
  return value;
}
inline bool DrawableArchive::has_title() const {
  return _internal_has_title();
}
inline const ::TSP::Reference& DrawableArchive::_internal_title() const {
  const ::TSP::Reference* p = title_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DrawableArchive::title() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.title)
  return _internal_title();
}
inline void DrawableArchive::unsafe_arena_set_allocated_title(
    ::TSP::Reference* title) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(title_);
  }
  title_ = title;
  if (title) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.DrawableArchive.title)
}
inline ::TSP::Reference* DrawableArchive::release_title() {
  _has_bits_[0] &= ~0x00000040u;
  ::TSP::Reference* temp = title_;
  title_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* DrawableArchive::unsafe_arena_release_title() {
  // @@protoc_insertion_point(field_release:TSD.DrawableArchive.title)
  _has_bits_[0] &= ~0x00000040u;
  ::TSP::Reference* temp = title_;
  title_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DrawableArchive::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000040u;
  if (title_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    title_ = p;
  }
  return title_;
}
inline ::TSP::Reference* DrawableArchive::mutable_title() {
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.title)
  return _internal_mutable_title();
}
inline void DrawableArchive::set_allocated_title(::TSP::Reference* title) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(title_);
  }
  if (title) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(title)->GetArena();
    if (message_arena != submessage_arena) {
      title = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, title, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  title_ = title;
  // @@protoc_insertion_point(field_set_allocated:TSD.DrawableArchive.title)
}

// optional .TSP.Reference caption = 11;
inline bool DrawableArchive::_internal_has_caption() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || caption_ != nullptr);
  return value;
}
inline bool DrawableArchive::has_caption() const {
  return _internal_has_caption();
}
inline const ::TSP::Reference& DrawableArchive::_internal_caption() const {
  const ::TSP::Reference* p = caption_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DrawableArchive::caption() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.caption)
  return _internal_caption();
}
inline void DrawableArchive::unsafe_arena_set_allocated_caption(
    ::TSP::Reference* caption) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(caption_);
  }
  caption_ = caption;
  if (caption) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.DrawableArchive.caption)
}
inline ::TSP::Reference* DrawableArchive::release_caption() {
  _has_bits_[0] &= ~0x00000080u;
  ::TSP::Reference* temp = caption_;
  caption_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* DrawableArchive::unsafe_arena_release_caption() {
  // @@protoc_insertion_point(field_release:TSD.DrawableArchive.caption)
  _has_bits_[0] &= ~0x00000080u;
  ::TSP::Reference* temp = caption_;
  caption_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DrawableArchive::_internal_mutable_caption() {
  _has_bits_[0] |= 0x00000080u;
  if (caption_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    caption_ = p;
  }
  return caption_;
}
inline ::TSP::Reference* DrawableArchive::mutable_caption() {
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.caption)
  return _internal_mutable_caption();
}
inline void DrawableArchive::set_allocated_caption(::TSP::Reference* caption) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(caption_);
  }
  if (caption) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(caption)->GetArena();
    if (message_arena != submessage_arena) {
      caption = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, caption, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  caption_ = caption;
  // @@protoc_insertion_point(field_set_allocated:TSD.DrawableArchive.caption)
}

// optional bool title_hidden = 12;
inline bool DrawableArchive::_internal_has_title_hidden() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool DrawableArchive::has_title_hidden() const {
  return _internal_has_title_hidden();
}
inline void DrawableArchive::clear_title_hidden() {
  title_hidden_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool DrawableArchive::_internal_title_hidden() const {
  return title_hidden_;
}
inline bool DrawableArchive::title_hidden() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.title_hidden)
  return _internal_title_hidden();
}
inline void DrawableArchive::_internal_set_title_hidden(bool value) {
  _has_bits_[0] |= 0x00000400u;
  title_hidden_ = value;
}
inline void DrawableArchive::set_title_hidden(bool value) {
  _internal_set_title_hidden(value);
  // @@protoc_insertion_point(field_set:TSD.DrawableArchive.title_hidden)
}

// optional bool caption_hidden = 13;
inline bool DrawableArchive::_internal_has_caption_hidden() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool DrawableArchive::has_caption_hidden() const {
  return _internal_has_caption_hidden();
}
inline void DrawableArchive::clear_caption_hidden() {
  caption_hidden_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool DrawableArchive::_internal_caption_hidden() const {
  return caption_hidden_;
}
inline bool DrawableArchive::caption_hidden() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.caption_hidden)
  return _internal_caption_hidden();
}
inline void DrawableArchive::_internal_set_caption_hidden(bool value) {
  _has_bits_[0] |= 0x00000800u;
  caption_hidden_ = value;
}
inline void DrawableArchive::set_caption_hidden(bool value) {
  _internal_set_caption_hidden(value);
  // @@protoc_insertion_point(field_set:TSD.DrawableArchive.caption_hidden)
}

// -------------------------------------------------------------------

// ContainerArchive

// optional .TSD.GeometryArchive geometry = 1;
inline bool ContainerArchive::_internal_has_geometry() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || geometry_ != nullptr);
  return value;
}
inline bool ContainerArchive::has_geometry() const {
  return _internal_has_geometry();
}
inline void ContainerArchive::clear_geometry() {
  if (geometry_ != nullptr) geometry_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::GeometryArchive& ContainerArchive::_internal_geometry() const {
  const ::TSD::GeometryArchive* p = geometry_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::GeometryArchive&>(
      ::TSD::_GeometryArchive_default_instance_);
}
inline const ::TSD::GeometryArchive& ContainerArchive::geometry() const {
  // @@protoc_insertion_point(field_get:TSD.ContainerArchive.geometry)
  return _internal_geometry();
}
inline void ContainerArchive::unsafe_arena_set_allocated_geometry(
    ::TSD::GeometryArchive* geometry) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry_);
  }
  geometry_ = geometry;
  if (geometry) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ContainerArchive.geometry)
}
inline ::TSD::GeometryArchive* ContainerArchive::release_geometry() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::GeometryArchive* temp = geometry_;
  geometry_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::GeometryArchive* ContainerArchive::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_release:TSD.ContainerArchive.geometry)
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::GeometryArchive* temp = geometry_;
  geometry_ = nullptr;
  return temp;
}
inline ::TSD::GeometryArchive* ContainerArchive::_internal_mutable_geometry() {
  _has_bits_[0] |= 0x00000001u;
  if (geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::GeometryArchive>(GetArena());
    geometry_ = p;
  }
  return geometry_;
}
inline ::TSD::GeometryArchive* ContainerArchive::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable:TSD.ContainerArchive.geometry)
  return _internal_mutable_geometry();
}
inline void ContainerArchive::set_allocated_geometry(::TSD::GeometryArchive* geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete geometry_;
  }
  if (geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(geometry);
    if (message_arena != submessage_arena) {
      geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:TSD.ContainerArchive.geometry)
}

// optional .TSP.Reference parent = 2;
inline bool ContainerArchive::_internal_has_parent() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || parent_ != nullptr);
  return value;
}
inline bool ContainerArchive::has_parent() const {
  return _internal_has_parent();
}
inline const ::TSP::Reference& ContainerArchive::_internal_parent() const {
  const ::TSP::Reference* p = parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ContainerArchive::parent() const {
  // @@protoc_insertion_point(field_get:TSD.ContainerArchive.parent)
  return _internal_parent();
}
inline void ContainerArchive::unsafe_arena_set_allocated_parent(
    ::TSP::Reference* parent) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  parent_ = parent;
  if (parent) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ContainerArchive.parent)
}
inline ::TSP::Reference* ContainerArchive::release_parent() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = parent_;
  parent_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* ContainerArchive::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:TSD.ContainerArchive.parent)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = parent_;
  parent_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ContainerArchive::_internal_mutable_parent() {
  _has_bits_[0] |= 0x00000002u;
  if (parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    parent_ = p;
  }
  return parent_;
}
inline ::TSP::Reference* ContainerArchive::mutable_parent() {
  // @@protoc_insertion_point(field_mutable:TSD.ContainerArchive.parent)
  return _internal_mutable_parent();
}
inline void ContainerArchive::set_allocated_parent(::TSP::Reference* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent)->GetArena();
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:TSD.ContainerArchive.parent)
}

// repeated .TSP.Reference children = 3;
inline int ContainerArchive::_internal_children_size() const {
  return children_.size();
}
inline int ContainerArchive::children_size() const {
  return _internal_children_size();
}
inline ::TSP::Reference* ContainerArchive::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ContainerArchive.children)
  return children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ContainerArchive::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ContainerArchive.children)
  return &children_;
}
inline const ::TSP::Reference& ContainerArchive::_internal_children(int index) const {
  return children_.Get(index);
}
inline const ::TSP::Reference& ContainerArchive::children(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ContainerArchive.children)
  return _internal_children(index);
}
inline ::TSP::Reference* ContainerArchive::_internal_add_children() {
  return children_.Add();
}
inline ::TSP::Reference* ContainerArchive::add_children() {
  // @@protoc_insertion_point(field_add:TSD.ContainerArchive.children)
  return _internal_add_children();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ContainerArchive::children() const {
  // @@protoc_insertion_point(field_list:TSD.ContainerArchive.children)
  return children_;
}

// -------------------------------------------------------------------

// GroupArchive

// required .TSD.DrawableArchive super = 1;
inline bool GroupArchive::_internal_has_super() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || super_ != nullptr);
  return value;
}
inline bool GroupArchive::has_super() const {
  return _internal_has_super();
}
inline void GroupArchive::clear_super() {
  if (super_ != nullptr) super_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::DrawableArchive& GroupArchive::_internal_super() const {
  const ::TSD::DrawableArchive* p = super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DrawableArchive&>(
      ::TSD::_DrawableArchive_default_instance_);
}
inline const ::TSD::DrawableArchive& GroupArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.GroupArchive.super)
  return _internal_super();
}
inline void GroupArchive::unsafe_arena_set_allocated_super(
    ::TSD::DrawableArchive* super) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  super_ = super;
  if (super) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.GroupArchive.super)
}
inline ::TSD::DrawableArchive* GroupArchive::release_super() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = super_;
  super_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::DrawableArchive* GroupArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.GroupArchive.super)
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = super_;
  super_ = nullptr;
  return temp;
}
inline ::TSD::DrawableArchive* GroupArchive::_internal_mutable_super() {
  _has_bits_[0] |= 0x00000001u;
  if (super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DrawableArchive>(GetArena());
    super_ = p;
  }
  return super_;
}
inline ::TSD::DrawableArchive* GroupArchive::mutable_super() {
  // @@protoc_insertion_point(field_mutable:TSD.GroupArchive.super)
  return _internal_mutable_super();
}
inline void GroupArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.GroupArchive.super)
}

// repeated .TSP.Reference children = 2;
inline int GroupArchive::_internal_children_size() const {
  return children_.size();
}
inline int GroupArchive::children_size() const {
  return _internal_children_size();
}
inline ::TSP::Reference* GroupArchive::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.GroupArchive.children)
  return children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
GroupArchive::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:TSD.GroupArchive.children)
  return &children_;
}
inline const ::TSP::Reference& GroupArchive::_internal_children(int index) const {
  return children_.Get(index);
}
inline const ::TSP::Reference& GroupArchive::children(int index) const {
  // @@protoc_insertion_point(field_get:TSD.GroupArchive.children)
  return _internal_children(index);
}
inline ::TSP::Reference* GroupArchive::_internal_add_children() {
  return children_.Add();
}
inline ::TSP::Reference* GroupArchive::add_children() {
  // @@protoc_insertion_point(field_add:TSD.GroupArchive.children)
  return _internal_add_children();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
GroupArchive::children() const {
  // @@protoc_insertion_point(field_list:TSD.GroupArchive.children)
  return children_;
}

// optional .TSP.Reference fake_shape_for_empty_group = 3;
inline bool GroupArchive::_internal_has_fake_shape_for_empty_group() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || fake_shape_for_empty_group_ != nullptr);
  return value;
}
inline bool GroupArchive::has_fake_shape_for_empty_group() const {
  return _internal_has_fake_shape_for_empty_group();
}
inline const ::TSP::Reference& GroupArchive::_internal_fake_shape_for_empty_group() const {
  const ::TSP::Reference* p = fake_shape_for_empty_group_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& GroupArchive::fake_shape_for_empty_group() const {
  // @@protoc_insertion_point(field_get:TSD.GroupArchive.fake_shape_for_empty_group)
  return _internal_fake_shape_for_empty_group();
}
inline void GroupArchive::unsafe_arena_set_allocated_fake_shape_for_empty_group(
    ::TSP::Reference* fake_shape_for_empty_group) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fake_shape_for_empty_group_);
  }
  fake_shape_for_empty_group_ = fake_shape_for_empty_group;
  if (fake_shape_for_empty_group) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.GroupArchive.fake_shape_for_empty_group)
}
inline ::TSP::Reference* GroupArchive::release_fake_shape_for_empty_group() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = fake_shape_for_empty_group_;
  fake_shape_for_empty_group_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* GroupArchive::unsafe_arena_release_fake_shape_for_empty_group() {
  // @@protoc_insertion_point(field_release:TSD.GroupArchive.fake_shape_for_empty_group)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = fake_shape_for_empty_group_;
  fake_shape_for_empty_group_ = nullptr;
  return temp;
}
inline ::TSP::Reference* GroupArchive::_internal_mutable_fake_shape_for_empty_group() {
  _has_bits_[0] |= 0x00000002u;
  if (fake_shape_for_empty_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    fake_shape_for_empty_group_ = p;
  }
  return fake_shape_for_empty_group_;
}
inline ::TSP::Reference* GroupArchive::mutable_fake_shape_for_empty_group() {
  // @@protoc_insertion_point(field_mutable:TSD.GroupArchive.fake_shape_for_empty_group)
  return _internal_mutable_fake_shape_for_empty_group();
}
inline void GroupArchive::set_allocated_fake_shape_for_empty_group(::TSP::Reference* fake_shape_for_empty_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fake_shape_for_empty_group_);
  }
  if (fake_shape_for_empty_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fake_shape_for_empty_group)->GetArena();
    if (message_arena != submessage_arena) {
      fake_shape_for_empty_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fake_shape_for_empty_group, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  fake_shape_for_empty_group_ = fake_shape_for_empty_group;
  // @@protoc_insertion_point(field_set_allocated:TSD.GroupArchive.fake_shape_for_empty_group)
}

// -------------------------------------------------------------------

// FreehandDrawingAnimationArchive

// optional double duration = 1;
inline bool FreehandDrawingAnimationArchive::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FreehandDrawingAnimationArchive::has_duration() const {
  return _internal_has_duration();
}
inline void FreehandDrawingAnimationArchive::clear_duration() {
  duration_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double FreehandDrawingAnimationArchive::_internal_duration() const {
  return duration_;
}
inline double FreehandDrawingAnimationArchive::duration() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingAnimationArchive.duration)
  return _internal_duration();
}
inline void FreehandDrawingAnimationArchive::_internal_set_duration(double value) {
  _has_bits_[0] |= 0x00000001u;
  duration_ = value;
}
inline void FreehandDrawingAnimationArchive::set_duration(double value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:TSD.FreehandDrawingAnimationArchive.duration)
}

// optional bool should_loop = 2;
inline bool FreehandDrawingAnimationArchive::_internal_has_should_loop() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FreehandDrawingAnimationArchive::has_should_loop() const {
  return _internal_has_should_loop();
}
inline void FreehandDrawingAnimationArchive::clear_should_loop() {
  should_loop_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool FreehandDrawingAnimationArchive::_internal_should_loop() const {
  return should_loop_;
}
inline bool FreehandDrawingAnimationArchive::should_loop() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingAnimationArchive.should_loop)
  return _internal_should_loop();
}
inline void FreehandDrawingAnimationArchive::_internal_set_should_loop(bool value) {
  _has_bits_[0] |= 0x00000002u;
  should_loop_ = value;
}
inline void FreehandDrawingAnimationArchive::set_should_loop(bool value) {
  _internal_set_should_loop(value);
  // @@protoc_insertion_point(field_set:TSD.FreehandDrawingAnimationArchive.should_loop)
}

// -------------------------------------------------------------------

// FreehandDrawingArchive

// optional .TSP.Reference spacer_shape = 1;
inline bool FreehandDrawingArchive::_internal_has_spacer_shape() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || spacer_shape_ != nullptr);
  return value;
}
inline bool FreehandDrawingArchive::has_spacer_shape() const {
  return _internal_has_spacer_shape();
}
inline const ::TSP::Reference& FreehandDrawingArchive::_internal_spacer_shape() const {
  const ::TSP::Reference* p = spacer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& FreehandDrawingArchive::spacer_shape() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingArchive.spacer_shape)
  return _internal_spacer_shape();
}
inline void FreehandDrawingArchive::unsafe_arena_set_allocated_spacer_shape(
    ::TSP::Reference* spacer_shape) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spacer_shape_);
  }
  spacer_shape_ = spacer_shape;
  if (spacer_shape) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.FreehandDrawingArchive.spacer_shape)
}
inline ::TSP::Reference* FreehandDrawingArchive::release_spacer_shape() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = spacer_shape_;
  spacer_shape_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* FreehandDrawingArchive::unsafe_arena_release_spacer_shape() {
  // @@protoc_insertion_point(field_release:TSD.FreehandDrawingArchive.spacer_shape)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = spacer_shape_;
  spacer_shape_ = nullptr;
  return temp;
}
inline ::TSP::Reference* FreehandDrawingArchive::_internal_mutable_spacer_shape() {
  _has_bits_[0] |= 0x00000001u;
  if (spacer_shape_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    spacer_shape_ = p;
  }
  return spacer_shape_;
}
inline ::TSP::Reference* FreehandDrawingArchive::mutable_spacer_shape() {
  // @@protoc_insertion_point(field_mutable:TSD.FreehandDrawingArchive.spacer_shape)
  return _internal_mutable_spacer_shape();
}
inline void FreehandDrawingArchive::set_allocated_spacer_shape(::TSP::Reference* spacer_shape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(spacer_shape_);
  }
  if (spacer_shape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spacer_shape)->GetArena();
    if (message_arena != submessage_arena) {
      spacer_shape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spacer_shape, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  spacer_shape_ = spacer_shape;
  // @@protoc_insertion_point(field_set_allocated:TSD.FreehandDrawingArchive.spacer_shape)
}

// optional double opacity = 2;
inline bool FreehandDrawingArchive::_internal_has_opacity() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FreehandDrawingArchive::has_opacity() const {
  return _internal_has_opacity();
}
inline void FreehandDrawingArchive::clear_opacity() {
  opacity_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double FreehandDrawingArchive::_internal_opacity() const {
  return opacity_;
}
inline double FreehandDrawingArchive::opacity() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingArchive.opacity)
  return _internal_opacity();
}
inline void FreehandDrawingArchive::_internal_set_opacity(double value) {
  _has_bits_[0] |= 0x00000004u;
  opacity_ = value;
}
inline void FreehandDrawingArchive::set_opacity(double value) {
  _internal_set_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.FreehandDrawingArchive.opacity)
}

// optional .TSD.FreehandDrawingAnimationArchive animation = 3;
inline bool FreehandDrawingArchive::_internal_has_animation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || animation_ != nullptr);
  return value;
}
inline bool FreehandDrawingArchive::has_animation() const {
  return _internal_has_animation();
}
inline void FreehandDrawingArchive::clear_animation() {
  if (animation_ != nullptr) animation_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::FreehandDrawingAnimationArchive& FreehandDrawingArchive::_internal_animation() const {
  const ::TSD::FreehandDrawingAnimationArchive* p = animation_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::FreehandDrawingAnimationArchive&>(
      ::TSD::_FreehandDrawingAnimationArchive_default_instance_);
}
inline const ::TSD::FreehandDrawingAnimationArchive& FreehandDrawingArchive::animation() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingArchive.animation)
  return _internal_animation();
}
inline void FreehandDrawingArchive::unsafe_arena_set_allocated_animation(
    ::TSD::FreehandDrawingAnimationArchive* animation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(animation_);
  }
  animation_ = animation;
  if (animation) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.FreehandDrawingArchive.animation)
}
inline ::TSD::FreehandDrawingAnimationArchive* FreehandDrawingArchive::release_animation() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::FreehandDrawingAnimationArchive* temp = animation_;
  animation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::FreehandDrawingAnimationArchive* FreehandDrawingArchive::unsafe_arena_release_animation() {
  // @@protoc_insertion_point(field_release:TSD.FreehandDrawingArchive.animation)
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::FreehandDrawingAnimationArchive* temp = animation_;
  animation_ = nullptr;
  return temp;
}
inline ::TSD::FreehandDrawingAnimationArchive* FreehandDrawingArchive::_internal_mutable_animation() {
  _has_bits_[0] |= 0x00000002u;
  if (animation_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::FreehandDrawingAnimationArchive>(GetArena());
    animation_ = p;
  }
  return animation_;
}
inline ::TSD::FreehandDrawingAnimationArchive* FreehandDrawingArchive::mutable_animation() {
  // @@protoc_insertion_point(field_mutable:TSD.FreehandDrawingArchive.animation)
  return _internal_mutable_animation();
}
inline void FreehandDrawingArchive::set_allocated_animation(::TSD::FreehandDrawingAnimationArchive* animation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete animation_;
  }
  if (animation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(animation);
    if (message_arena != submessage_arena) {
      animation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, animation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  animation_ = animation;
  // @@protoc_insertion_point(field_set_allocated:TSD.FreehandDrawingArchive.animation)
}

// -------------------------------------------------------------------

// ShapeArchive

// required .TSD.DrawableArchive super = 1;
inline bool ShapeArchive::_internal_has_super() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || super_ != nullptr);
  return value;
}
inline bool ShapeArchive::has_super() const {
  return _internal_has_super();
}
inline void ShapeArchive::clear_super() {
  if (super_ != nullptr) super_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::DrawableArchive& ShapeArchive::_internal_super() const {
  const ::TSD::DrawableArchive* p = super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DrawableArchive&>(
      ::TSD::_DrawableArchive_default_instance_);
}
inline const ::TSD::DrawableArchive& ShapeArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeArchive.super)
  return _internal_super();
}
inline void ShapeArchive::unsafe_arena_set_allocated_super(
    ::TSD::DrawableArchive* super) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  super_ = super;
  if (super) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeArchive.super)
}
inline ::TSD::DrawableArchive* ShapeArchive::release_super() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = super_;
  super_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::DrawableArchive* ShapeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.ShapeArchive.super)
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = super_;
  super_ = nullptr;
  return temp;
}
inline ::TSD::DrawableArchive* ShapeArchive::_internal_mutable_super() {
  _has_bits_[0] |= 0x00000001u;
  if (super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DrawableArchive>(GetArena());
    super_ = p;
  }
  return super_;
}
inline ::TSD::DrawableArchive* ShapeArchive::mutable_super() {
  // @@protoc_insertion_point(field_mutable:TSD.ShapeArchive.super)
  return _internal_mutable_super();
}
inline void ShapeArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeArchive.super)
}

// optional .TSP.Reference style = 2;
inline bool ShapeArchive::_internal_has_style() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || style_ != nullptr);
  return value;
}
inline bool ShapeArchive::has_style() const {
  return _internal_has_style();
}
inline const ::TSP::Reference& ShapeArchive::_internal_style() const {
  const ::TSP::Reference* p = style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ShapeArchive::style() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeArchive.style)
  return _internal_style();
}
inline void ShapeArchive::unsafe_arena_set_allocated_style(
    ::TSP::Reference* style) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(style_);
  }
  style_ = style;
  if (style) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeArchive.style)
}
inline ::TSP::Reference* ShapeArchive::release_style() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = style_;
  style_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* ShapeArchive::unsafe_arena_release_style() {
  // @@protoc_insertion_point(field_release:TSD.ShapeArchive.style)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = style_;
  style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ShapeArchive::_internal_mutable_style() {
  _has_bits_[0] |= 0x00000002u;
  if (style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    style_ = p;
  }
  return style_;
}
inline ::TSP::Reference* ShapeArchive::mutable_style() {
  // @@protoc_insertion_point(field_mutable:TSD.ShapeArchive.style)
  return _internal_mutable_style();
}
inline void ShapeArchive::set_allocated_style(::TSP::Reference* style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(style_);
  }
  if (style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(style)->GetArena();
    if (message_arena != submessage_arena) {
      style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, style, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  style_ = style;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeArchive.style)
}

// optional .TSD.PathSourceArchive pathsource = 3;
inline bool ShapeArchive::_internal_has_pathsource() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || pathsource_ != nullptr);
  return value;
}
inline bool ShapeArchive::has_pathsource() const {
  return _internal_has_pathsource();
}
inline void ShapeArchive::clear_pathsource() {
  if (pathsource_ != nullptr) pathsource_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::PathSourceArchive& ShapeArchive::_internal_pathsource() const {
  const ::TSD::PathSourceArchive* p = pathsource_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::PathSourceArchive&>(
      ::TSD::_PathSourceArchive_default_instance_);
}
inline const ::TSD::PathSourceArchive& ShapeArchive::pathsource() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeArchive.pathsource)
  return _internal_pathsource();
}
inline void ShapeArchive::unsafe_arena_set_allocated_pathsource(
    ::TSD::PathSourceArchive* pathsource) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathsource_);
  }
  pathsource_ = pathsource;
  if (pathsource) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeArchive.pathsource)
}
inline ::TSD::PathSourceArchive* ShapeArchive::release_pathsource() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::PathSourceArchive* temp = pathsource_;
  pathsource_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::PathSourceArchive* ShapeArchive::unsafe_arena_release_pathsource() {
  // @@protoc_insertion_point(field_release:TSD.ShapeArchive.pathsource)
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::PathSourceArchive* temp = pathsource_;
  pathsource_ = nullptr;
  return temp;
}
inline ::TSD::PathSourceArchive* ShapeArchive::_internal_mutable_pathsource() {
  _has_bits_[0] |= 0x00000004u;
  if (pathsource_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::PathSourceArchive>(GetArena());
    pathsource_ = p;
  }
  return pathsource_;
}
inline ::TSD::PathSourceArchive* ShapeArchive::mutable_pathsource() {
  // @@protoc_insertion_point(field_mutable:TSD.ShapeArchive.pathsource)
  return _internal_mutable_pathsource();
}
inline void ShapeArchive::set_allocated_pathsource(::TSD::PathSourceArchive* pathsource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pathsource_;
  }
  if (pathsource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pathsource);
    if (message_arena != submessage_arena) {
      pathsource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathsource, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  pathsource_ = pathsource;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeArchive.pathsource)
}

// optional .TSD.LineEndArchive head_line_end = 4 [deprecated = true];
inline bool ShapeArchive::_internal_has_head_line_end() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || head_line_end_ != nullptr);
  return value;
}
inline bool ShapeArchive::has_head_line_end() const {
  return _internal_has_head_line_end();
}
inline void ShapeArchive::clear_head_line_end() {
  if (head_line_end_ != nullptr) head_line_end_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::TSD::LineEndArchive& ShapeArchive::_internal_head_line_end() const {
  const ::TSD::LineEndArchive* p = head_line_end_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::LineEndArchive&>(
      ::TSD::_LineEndArchive_default_instance_);
}
inline const ::TSD::LineEndArchive& ShapeArchive::head_line_end() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeArchive.head_line_end)
  return _internal_head_line_end();
}
inline void ShapeArchive::unsafe_arena_set_allocated_head_line_end(
    ::TSD::LineEndArchive* head_line_end) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_line_end_);
  }
  head_line_end_ = head_line_end;
  if (head_line_end) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeArchive.head_line_end)
}
inline ::TSD::LineEndArchive* ShapeArchive::release_head_line_end() {
  _has_bits_[0] &= ~0x00000008u;
  ::TSD::LineEndArchive* temp = head_line_end_;
  head_line_end_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::LineEndArchive* ShapeArchive::unsafe_arena_release_head_line_end() {
  // @@protoc_insertion_point(field_release:TSD.ShapeArchive.head_line_end)
  _has_bits_[0] &= ~0x00000008u;
  ::TSD::LineEndArchive* temp = head_line_end_;
  head_line_end_ = nullptr;
  return temp;
}
inline ::TSD::LineEndArchive* ShapeArchive::_internal_mutable_head_line_end() {
  _has_bits_[0] |= 0x00000008u;
  if (head_line_end_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::LineEndArchive>(GetArena());
    head_line_end_ = p;
  }
  return head_line_end_;
}
inline ::TSD::LineEndArchive* ShapeArchive::mutable_head_line_end() {
  // @@protoc_insertion_point(field_mutable:TSD.ShapeArchive.head_line_end)
  return _internal_mutable_head_line_end();
}
inline void ShapeArchive::set_allocated_head_line_end(::TSD::LineEndArchive* head_line_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete head_line_end_;
  }
  if (head_line_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(head_line_end);
    if (message_arena != submessage_arena) {
      head_line_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head_line_end, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  head_line_end_ = head_line_end;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeArchive.head_line_end)
}

// optional .TSD.LineEndArchive tail_line_end = 5 [deprecated = true];
inline bool ShapeArchive::_internal_has_tail_line_end() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || tail_line_end_ != nullptr);
  return value;
}
inline bool ShapeArchive::has_tail_line_end() const {
  return _internal_has_tail_line_end();
}
inline void ShapeArchive::clear_tail_line_end() {
  if (tail_line_end_ != nullptr) tail_line_end_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::TSD::LineEndArchive& ShapeArchive::_internal_tail_line_end() const {
  const ::TSD::LineEndArchive* p = tail_line_end_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::LineEndArchive&>(
      ::TSD::_LineEndArchive_default_instance_);
}
inline const ::TSD::LineEndArchive& ShapeArchive::tail_line_end() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeArchive.tail_line_end)
  return _internal_tail_line_end();
}
inline void ShapeArchive::unsafe_arena_set_allocated_tail_line_end(
    ::TSD::LineEndArchive* tail_line_end) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tail_line_end_);
  }
  tail_line_end_ = tail_line_end;
  if (tail_line_end) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeArchive.tail_line_end)
}
inline ::TSD::LineEndArchive* ShapeArchive::release_tail_line_end() {
  _has_bits_[0] &= ~0x00000010u;
  ::TSD::LineEndArchive* temp = tail_line_end_;
  tail_line_end_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::LineEndArchive* ShapeArchive::unsafe_arena_release_tail_line_end() {
  // @@protoc_insertion_point(field_release:TSD.ShapeArchive.tail_line_end)
  _has_bits_[0] &= ~0x00000010u;
  ::TSD::LineEndArchive* temp = tail_line_end_;
  tail_line_end_ = nullptr;
  return temp;
}
inline ::TSD::LineEndArchive* ShapeArchive::_internal_mutable_tail_line_end() {
  _has_bits_[0] |= 0x00000010u;
  if (tail_line_end_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::LineEndArchive>(GetArena());
    tail_line_end_ = p;
  }
  return tail_line_end_;
}
inline ::TSD::LineEndArchive* ShapeArchive::mutable_tail_line_end() {
  // @@protoc_insertion_point(field_mutable:TSD.ShapeArchive.tail_line_end)
  return _internal_mutable_tail_line_end();
}
inline void ShapeArchive::set_allocated_tail_line_end(::TSD::LineEndArchive* tail_line_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tail_line_end_;
  }
  if (tail_line_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tail_line_end);
    if (message_arena != submessage_arena) {
      tail_line_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tail_line_end, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  tail_line_end_ = tail_line_end;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeArchive.tail_line_end)
}

// optional float strokePatternOffsetDistance = 6;
inline bool ShapeArchive::_internal_has_strokepatternoffsetdistance() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ShapeArchive::has_strokepatternoffsetdistance() const {
  return _internal_has_strokepatternoffsetdistance();
}
inline void ShapeArchive::clear_strokepatternoffsetdistance() {
  strokepatternoffsetdistance_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float ShapeArchive::_internal_strokepatternoffsetdistance() const {
  return strokepatternoffsetdistance_;
}
inline float ShapeArchive::strokepatternoffsetdistance() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeArchive.strokePatternOffsetDistance)
  return _internal_strokepatternoffsetdistance();
}
inline void ShapeArchive::_internal_set_strokepatternoffsetdistance(float value) {
  _has_bits_[0] |= 0x00000020u;
  strokepatternoffsetdistance_ = value;
}
inline void ShapeArchive::set_strokepatternoffsetdistance(float value) {
  _internal_set_strokepatternoffsetdistance(value);
  // @@protoc_insertion_point(field_set:TSD.ShapeArchive.strokePatternOffsetDistance)
}

// -------------------------------------------------------------------

// ConnectionLineArchive

// required .TSD.ShapeArchive super = 1;
inline bool ConnectionLineArchive::_internal_has_super() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || super_ != nullptr);
  return value;
}
inline bool ConnectionLineArchive::has_super() const {
  return _internal_has_super();
}
inline void ConnectionLineArchive::clear_super() {
  if (super_ != nullptr) super_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::ShapeArchive& ConnectionLineArchive::_internal_super() const {
  const ::TSD::ShapeArchive* p = super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ShapeArchive&>(
      ::TSD::_ShapeArchive_default_instance_);
}
inline const ::TSD::ShapeArchive& ConnectionLineArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLineArchive.super)
  return _internal_super();
}
inline void ConnectionLineArchive::unsafe_arena_set_allocated_super(
    ::TSD::ShapeArchive* super) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  super_ = super;
  if (super) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ConnectionLineArchive.super)
}
inline ::TSD::ShapeArchive* ConnectionLineArchive::release_super() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::ShapeArchive* temp = super_;
  super_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::ShapeArchive* ConnectionLineArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.ConnectionLineArchive.super)
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::ShapeArchive* temp = super_;
  super_ = nullptr;
  return temp;
}
inline ::TSD::ShapeArchive* ConnectionLineArchive::_internal_mutable_super() {
  _has_bits_[0] |= 0x00000001u;
  if (super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ShapeArchive>(GetArena());
    super_ = p;
  }
  return super_;
}
inline ::TSD::ShapeArchive* ConnectionLineArchive::mutable_super() {
  // @@protoc_insertion_point(field_mutable:TSD.ConnectionLineArchive.super)
  return _internal_mutable_super();
}
inline void ConnectionLineArchive::set_allocated_super(::TSD::ShapeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.ConnectionLineArchive.super)
}

// optional .TSP.Reference connected_from = 2;
inline bool ConnectionLineArchive::_internal_has_connected_from() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || connected_from_ != nullptr);
  return value;
}
inline bool ConnectionLineArchive::has_connected_from() const {
  return _internal_has_connected_from();
}
inline const ::TSP::Reference& ConnectionLineArchive::_internal_connected_from() const {
  const ::TSP::Reference* p = connected_from_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ConnectionLineArchive::connected_from() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLineArchive.connected_from)
  return _internal_connected_from();
}
inline void ConnectionLineArchive::unsafe_arena_set_allocated_connected_from(
    ::TSP::Reference* connected_from) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_from_);
  }
  connected_from_ = connected_from;
  if (connected_from) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ConnectionLineArchive.connected_from)
}
inline ::TSP::Reference* ConnectionLineArchive::release_connected_from() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = connected_from_;
  connected_from_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* ConnectionLineArchive::unsafe_arena_release_connected_from() {
  // @@protoc_insertion_point(field_release:TSD.ConnectionLineArchive.connected_from)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = connected_from_;
  connected_from_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ConnectionLineArchive::_internal_mutable_connected_from() {
  _has_bits_[0] |= 0x00000002u;
  if (connected_from_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    connected_from_ = p;
  }
  return connected_from_;
}
inline ::TSP::Reference* ConnectionLineArchive::mutable_connected_from() {
  // @@protoc_insertion_point(field_mutable:TSD.ConnectionLineArchive.connected_from)
  return _internal_mutable_connected_from();
}
inline void ConnectionLineArchive::set_allocated_connected_from(::TSP::Reference* connected_from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_from_);
  }
  if (connected_from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_from)->GetArena();
    if (message_arena != submessage_arena) {
      connected_from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connected_from, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  connected_from_ = connected_from;
  // @@protoc_insertion_point(field_set_allocated:TSD.ConnectionLineArchive.connected_from)
}

// optional .TSP.Reference connected_to = 3;
inline bool ConnectionLineArchive::_internal_has_connected_to() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || connected_to_ != nullptr);
  return value;
}
inline bool ConnectionLineArchive::has_connected_to() const {
  return _internal_has_connected_to();
}
inline const ::TSP::Reference& ConnectionLineArchive::_internal_connected_to() const {
  const ::TSP::Reference* p = connected_to_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ConnectionLineArchive::connected_to() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLineArchive.connected_to)
  return _internal_connected_to();
}
inline void ConnectionLineArchive::unsafe_arena_set_allocated_connected_to(
    ::TSP::Reference* connected_to) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_to_);
  }
  connected_to_ = connected_to;
  if (connected_to) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ConnectionLineArchive.connected_to)
}
inline ::TSP::Reference* ConnectionLineArchive::release_connected_to() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = connected_to_;
  connected_to_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* ConnectionLineArchive::unsafe_arena_release_connected_to() {
  // @@protoc_insertion_point(field_release:TSD.ConnectionLineArchive.connected_to)
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = connected_to_;
  connected_to_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ConnectionLineArchive::_internal_mutable_connected_to() {
  _has_bits_[0] |= 0x00000004u;
  if (connected_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    connected_to_ = p;
  }
  return connected_to_;
}
inline ::TSP::Reference* ConnectionLineArchive::mutable_connected_to() {
  // @@protoc_insertion_point(field_mutable:TSD.ConnectionLineArchive.connected_to)
  return _internal_mutable_connected_to();
}
inline void ConnectionLineArchive::set_allocated_connected_to(::TSP::Reference* connected_to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_to_);
  }
  if (connected_to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_to)->GetArena();
    if (message_arena != submessage_arena) {
      connected_to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connected_to, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  connected_to_ = connected_to;
  // @@protoc_insertion_point(field_set_allocated:TSD.ConnectionLineArchive.connected_to)
}

// optional .TSP.UUID connected_to_uuid = 4;
inline bool ConnectionLineArchive::_internal_has_connected_to_uuid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || connected_to_uuid_ != nullptr);
  return value;
}
inline bool ConnectionLineArchive::has_connected_to_uuid() const {
  return _internal_has_connected_to_uuid();
}
inline const ::TSP::UUID& ConnectionLineArchive::_internal_connected_to_uuid() const {
  const ::TSP::UUID* p = connected_to_uuid_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::UUID&>(
      ::TSP::_UUID_default_instance_);
}
inline const ::TSP::UUID& ConnectionLineArchive::connected_to_uuid() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLineArchive.connected_to_uuid)
  return _internal_connected_to_uuid();
}
inline void ConnectionLineArchive::unsafe_arena_set_allocated_connected_to_uuid(
    ::TSP::UUID* connected_to_uuid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_to_uuid_);
  }
  connected_to_uuid_ = connected_to_uuid;
  if (connected_to_uuid) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ConnectionLineArchive.connected_to_uuid)
}
inline ::TSP::UUID* ConnectionLineArchive::release_connected_to_uuid() {
  _has_bits_[0] &= ~0x00000008u;
  ::TSP::UUID* temp = connected_to_uuid_;
  connected_to_uuid_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::UUID* ConnectionLineArchive::unsafe_arena_release_connected_to_uuid() {
  // @@protoc_insertion_point(field_release:TSD.ConnectionLineArchive.connected_to_uuid)
  _has_bits_[0] &= ~0x00000008u;
  ::TSP::UUID* temp = connected_to_uuid_;
  connected_to_uuid_ = nullptr;
  return temp;
}
inline ::TSP::UUID* ConnectionLineArchive::_internal_mutable_connected_to_uuid() {
  _has_bits_[0] |= 0x00000008u;
  if (connected_to_uuid_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::UUID>(GetArena());
    connected_to_uuid_ = p;
  }
  return connected_to_uuid_;
}
inline ::TSP::UUID* ConnectionLineArchive::mutable_connected_to_uuid() {
  // @@protoc_insertion_point(field_mutable:TSD.ConnectionLineArchive.connected_to_uuid)
  return _internal_mutable_connected_to_uuid();
}
inline void ConnectionLineArchive::set_allocated_connected_to_uuid(::TSP::UUID* connected_to_uuid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_to_uuid_);
  }
  if (connected_to_uuid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_to_uuid)->GetArena();
    if (message_arena != submessage_arena) {
      connected_to_uuid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connected_to_uuid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  connected_to_uuid_ = connected_to_uuid;
  // @@protoc_insertion_point(field_set_allocated:TSD.ConnectionLineArchive.connected_to_uuid)
}

// optional .TSP.UUID connected_from_uuid = 5;
inline bool ConnectionLineArchive::_internal_has_connected_from_uuid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || connected_from_uuid_ != nullptr);
  return value;
}
inline bool ConnectionLineArchive::has_connected_from_uuid() const {
  return _internal_has_connected_from_uuid();
}
inline const ::TSP::UUID& ConnectionLineArchive::_internal_connected_from_uuid() const {
  const ::TSP::UUID* p = connected_from_uuid_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::UUID&>(
      ::TSP::_UUID_default_instance_);
}
inline const ::TSP::UUID& ConnectionLineArchive::connected_from_uuid() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLineArchive.connected_from_uuid)
  return _internal_connected_from_uuid();
}
inline void ConnectionLineArchive::unsafe_arena_set_allocated_connected_from_uuid(
    ::TSP::UUID* connected_from_uuid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_from_uuid_);
  }
  connected_from_uuid_ = connected_from_uuid;
  if (connected_from_uuid) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ConnectionLineArchive.connected_from_uuid)
}
inline ::TSP::UUID* ConnectionLineArchive::release_connected_from_uuid() {
  _has_bits_[0] &= ~0x00000010u;
  ::TSP::UUID* temp = connected_from_uuid_;
  connected_from_uuid_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::UUID* ConnectionLineArchive::unsafe_arena_release_connected_from_uuid() {
  // @@protoc_insertion_point(field_release:TSD.ConnectionLineArchive.connected_from_uuid)
  _has_bits_[0] &= ~0x00000010u;
  ::TSP::UUID* temp = connected_from_uuid_;
  connected_from_uuid_ = nullptr;
  return temp;
}
inline ::TSP::UUID* ConnectionLineArchive::_internal_mutable_connected_from_uuid() {
  _has_bits_[0] |= 0x00000010u;
  if (connected_from_uuid_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::UUID>(GetArena());
    connected_from_uuid_ = p;
  }
  return connected_from_uuid_;
}
inline ::TSP::UUID* ConnectionLineArchive::mutable_connected_from_uuid() {
  // @@protoc_insertion_point(field_mutable:TSD.ConnectionLineArchive.connected_from_uuid)
  return _internal_mutable_connected_from_uuid();
}
inline void ConnectionLineArchive::set_allocated_connected_from_uuid(::TSP::UUID* connected_from_uuid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_from_uuid_);
  }
  if (connected_from_uuid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_from_uuid)->GetArena();
    if (message_arena != submessage_arena) {
      connected_from_uuid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connected_from_uuid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  connected_from_uuid_ = connected_from_uuid;
  // @@protoc_insertion_point(field_set_allocated:TSD.ConnectionLineArchive.connected_from_uuid)
}

// -------------------------------------------------------------------

// ImageArchive

// required .TSD.DrawableArchive super = 1;
inline bool ImageArchive::_internal_has_super() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || super_ != nullptr);
  return value;
}
inline bool ImageArchive::has_super() const {
  return _internal_has_super();
}
inline void ImageArchive::clear_super() {
  if (super_ != nullptr) super_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::DrawableArchive& ImageArchive::_internal_super() const {
  const ::TSD::DrawableArchive* p = super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DrawableArchive&>(
      ::TSD::_DrawableArchive_default_instance_);
}
inline const ::TSD::DrawableArchive& ImageArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.super)
  return _internal_super();
}
inline void ImageArchive::unsafe_arena_set_allocated_super(
    ::TSD::DrawableArchive* super) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  super_ = super;
  if (super) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.super)
}
inline ::TSD::DrawableArchive* ImageArchive::release_super() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = super_;
  super_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::DrawableArchive* ImageArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.super)
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = super_;
  super_ = nullptr;
  return temp;
}
inline ::TSD::DrawableArchive* ImageArchive::_internal_mutable_super() {
  _has_bits_[0] |= 0x00000001u;
  if (super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DrawableArchive>(GetArena());
    super_ = p;
  }
  return super_;
}
inline ::TSD::DrawableArchive* ImageArchive::mutable_super() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.super)
  return _internal_mutable_super();
}
inline void ImageArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.super)
}

// optional .TSP.DataReference data = 11;
inline bool ImageArchive::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || data_ != nullptr);
  return value;
}
inline bool ImageArchive::has_data() const {
  return _internal_has_data();
}
inline const ::TSP::DataReference& ImageArchive::_internal_data() const {
  const ::TSP::DataReference* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageArchive::data() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.data)
  return _internal_data();
}
inline void ImageArchive::unsafe_arena_set_allocated_data(
    ::TSP::DataReference* data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.data)
}
inline ::TSP::DataReference* ImageArchive::release_data() {
  _has_bits_[0] &= ~0x00000200u;
  ::TSP::DataReference* temp = data_;
  data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* ImageArchive::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.data)
  _has_bits_[0] &= ~0x00000200u;
  ::TSP::DataReference* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageArchive::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000200u;
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    data_ = p;
  }
  return data_;
}
inline ::TSP::DataReference* ImageArchive::mutable_data() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.data)
  return _internal_mutable_data();
}
inline void ImageArchive::set_allocated_data(::TSP::DataReference* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data)->GetArena();
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.data)
}

// optional .TSP.Reference style = 3;
inline bool ImageArchive::_internal_has_style() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || style_ != nullptr);
  return value;
}
inline bool ImageArchive::has_style() const {
  return _internal_has_style();
}
inline const ::TSP::Reference& ImageArchive::_internal_style() const {
  const ::TSP::Reference* p = style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ImageArchive::style() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.style)
  return _internal_style();
}
inline void ImageArchive::unsafe_arena_set_allocated_style(
    ::TSP::Reference* style) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(style_);
  }
  style_ = style;
  if (style) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.style)
}
inline ::TSP::Reference* ImageArchive::release_style() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = style_;
  style_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* ImageArchive::unsafe_arena_release_style() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.style)
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = style_;
  style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ImageArchive::_internal_mutable_style() {
  _has_bits_[0] |= 0x00000004u;
  if (style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    style_ = p;
  }
  return style_;
}
inline ::TSP::Reference* ImageArchive::mutable_style() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.style)
  return _internal_mutable_style();
}
inline void ImageArchive::set_allocated_style(::TSP::Reference* style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(style_);
  }
  if (style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(style)->GetArena();
    if (message_arena != submessage_arena) {
      style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, style, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  style_ = style;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.style)
}

// optional .TSP.Size originalSize = 4;
inline bool ImageArchive::_internal_has_originalsize() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || originalsize_ != nullptr);
  return value;
}
inline bool ImageArchive::has_originalsize() const {
  return _internal_has_originalsize();
}
inline const ::TSP::Size& ImageArchive::_internal_originalsize() const {
  const ::TSP::Size* p = originalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& ImageArchive::originalsize() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.originalSize)
  return _internal_originalsize();
}
inline void ImageArchive::unsafe_arena_set_allocated_originalsize(
    ::TSP::Size* originalsize) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(originalsize_);
  }
  originalsize_ = originalsize;
  if (originalsize) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.originalSize)
}
inline ::TSP::Size* ImageArchive::release_originalsize() {
  _has_bits_[0] &= ~0x00000008u;
  ::TSP::Size* temp = originalsize_;
  originalsize_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* ImageArchive::unsafe_arena_release_originalsize() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.originalSize)
  _has_bits_[0] &= ~0x00000008u;
  ::TSP::Size* temp = originalsize_;
  originalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* ImageArchive::_internal_mutable_originalsize() {
  _has_bits_[0] |= 0x00000008u;
  if (originalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    originalsize_ = p;
  }
  return originalsize_;
}
inline ::TSP::Size* ImageArchive::mutable_originalsize() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.originalSize)
  return _internal_mutable_originalsize();
}
inline void ImageArchive::set_allocated_originalsize(::TSP::Size* originalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(originalsize_);
  }
  if (originalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(originalsize)->GetArena();
    if (message_arena != submessage_arena) {
      originalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, originalsize, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  originalsize_ = originalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.originalSize)
}

// optional .TSP.Reference mask = 5;
inline bool ImageArchive::_internal_has_mask() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || mask_ != nullptr);
  return value;
}
inline bool ImageArchive::has_mask() const {
  return _internal_has_mask();
}
inline const ::TSP::Reference& ImageArchive::_internal_mask() const {
  const ::TSP::Reference* p = mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ImageArchive::mask() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.mask)
  return _internal_mask();
}
inline void ImageArchive::unsafe_arena_set_allocated_mask(
    ::TSP::Reference* mask) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mask_);
  }
  mask_ = mask;
  if (mask) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.mask)
}
inline ::TSP::Reference* ImageArchive::release_mask() {
  _has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = mask_;
  mask_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* ImageArchive::unsafe_arena_release_mask() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.mask)
  _has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = mask_;
  mask_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ImageArchive::_internal_mutable_mask() {
  _has_bits_[0] |= 0x00000010u;
  if (mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    mask_ = p;
  }
  return mask_;
}
inline ::TSP::Reference* ImageArchive::mutable_mask() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.mask)
  return _internal_mutable_mask();
}
inline void ImageArchive::set_allocated_mask(::TSP::Reference* mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mask_);
  }
  if (mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mask)->GetArena();
    if (message_arena != submessage_arena) {
      mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mask, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  mask_ = mask;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.mask)
}

// optional .TSP.DataReference thumbnailData = 12;
inline bool ImageArchive::_internal_has_thumbnaildata() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || thumbnaildata_ != nullptr);
  return value;
}
inline bool ImageArchive::has_thumbnaildata() const {
  return _internal_has_thumbnaildata();
}
inline const ::TSP::DataReference& ImageArchive::_internal_thumbnaildata() const {
  const ::TSP::DataReference* p = thumbnaildata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageArchive::thumbnaildata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.thumbnailData)
  return _internal_thumbnaildata();
}
inline void ImageArchive::unsafe_arena_set_allocated_thumbnaildata(
    ::TSP::DataReference* thumbnaildata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(thumbnaildata_);
  }
  thumbnaildata_ = thumbnaildata;
  if (thumbnaildata) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.thumbnailData)
}
inline ::TSP::DataReference* ImageArchive::release_thumbnaildata() {
  _has_bits_[0] &= ~0x00000400u;
  ::TSP::DataReference* temp = thumbnaildata_;
  thumbnaildata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* ImageArchive::unsafe_arena_release_thumbnaildata() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.thumbnailData)
  _has_bits_[0] &= ~0x00000400u;
  ::TSP::DataReference* temp = thumbnaildata_;
  thumbnaildata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageArchive::_internal_mutable_thumbnaildata() {
  _has_bits_[0] |= 0x00000400u;
  if (thumbnaildata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    thumbnaildata_ = p;
  }
  return thumbnaildata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_thumbnaildata() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.thumbnailData)
  return _internal_mutable_thumbnaildata();
}
inline void ImageArchive::set_allocated_thumbnaildata(::TSP::DataReference* thumbnaildata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(thumbnaildata_);
  }
  if (thumbnaildata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(thumbnaildata)->GetArena();
    if (message_arena != submessage_arena) {
      thumbnaildata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thumbnaildata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  thumbnaildata_ = thumbnaildata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.thumbnailData)
}

// optional uint32 flags = 7;
inline bool ImageArchive::_internal_has_flags() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool ImageArchive::has_flags() const {
  return _internal_has_flags();
}
inline void ImageArchive::clear_flags() {
  flags_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageArchive::_internal_flags() const {
  return flags_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageArchive::flags() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.flags)
  return _internal_flags();
}
inline void ImageArchive::_internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00040000u;
  flags_ = value;
}
inline void ImageArchive::set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:TSD.ImageArchive.flags)
}

// optional .TSP.DataReference originalData = 13;
inline bool ImageArchive::_internal_has_originaldata() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || originaldata_ != nullptr);
  return value;
}
inline bool ImageArchive::has_originaldata() const {
  return _internal_has_originaldata();
}
inline const ::TSP::DataReference& ImageArchive::_internal_originaldata() const {
  const ::TSP::DataReference* p = originaldata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageArchive::originaldata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.originalData)
  return _internal_originaldata();
}
inline void ImageArchive::unsafe_arena_set_allocated_originaldata(
    ::TSP::DataReference* originaldata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(originaldata_);
  }
  originaldata_ = originaldata;
  if (originaldata) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.originalData)
}
inline ::TSP::DataReference* ImageArchive::release_originaldata() {
  _has_bits_[0] &= ~0x00000800u;
  ::TSP::DataReference* temp = originaldata_;
  originaldata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* ImageArchive::unsafe_arena_release_originaldata() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.originalData)
  _has_bits_[0] &= ~0x00000800u;
  ::TSP::DataReference* temp = originaldata_;
  originaldata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageArchive::_internal_mutable_originaldata() {
  _has_bits_[0] |= 0x00000800u;
  if (originaldata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    originaldata_ = p;
  }
  return originaldata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_originaldata() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.originalData)
  return _internal_mutable_originaldata();
}
inline void ImageArchive::set_allocated_originaldata(::TSP::DataReference* originaldata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(originaldata_);
  }
  if (originaldata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(originaldata)->GetArena();
    if (message_arena != submessage_arena) {
      originaldata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, originaldata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  originaldata_ = originaldata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.originalData)
}

// optional .TSP.Size naturalSize = 9;
inline bool ImageArchive::_internal_has_naturalsize() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || naturalsize_ != nullptr);
  return value;
}
inline bool ImageArchive::has_naturalsize() const {
  return _internal_has_naturalsize();
}
inline const ::TSP::Size& ImageArchive::_internal_naturalsize() const {
  const ::TSP::Size* p = naturalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& ImageArchive::naturalsize() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.naturalSize)
  return _internal_naturalsize();
}
inline void ImageArchive::unsafe_arena_set_allocated_naturalsize(
    ::TSP::Size* naturalsize) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize_);
  }
  naturalsize_ = naturalsize;
  if (naturalsize) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.naturalSize)
}
inline ::TSP::Size* ImageArchive::release_naturalsize() {
  _has_bits_[0] &= ~0x00000080u;
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* ImageArchive::unsafe_arena_release_naturalsize() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.naturalSize)
  _has_bits_[0] &= ~0x00000080u;
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* ImageArchive::_internal_mutable_naturalsize() {
  _has_bits_[0] |= 0x00000080u;
  if (naturalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    naturalsize_ = p;
  }
  return naturalsize_;
}
inline ::TSP::Size* ImageArchive::mutable_naturalsize() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.naturalSize)
  return _internal_mutable_naturalsize();
}
inline void ImageArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize_);
  }
  if (naturalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize)->GetArena();
    if (message_arena != submessage_arena) {
      naturalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, naturalsize, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  naturalsize_ = naturalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.naturalSize)
}

// optional .TSP.Path instantAlphaPath = 10;
inline bool ImageArchive::_internal_has_instantalphapath() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || instantalphapath_ != nullptr);
  return value;
}
inline bool ImageArchive::has_instantalphapath() const {
  return _internal_has_instantalphapath();
}
inline const ::TSP::Path& ImageArchive::_internal_instantalphapath() const {
  const ::TSP::Path* p = instantalphapath_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Path&>(
      ::TSP::_Path_default_instance_);
}
inline const ::TSP::Path& ImageArchive::instantalphapath() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.instantAlphaPath)
  return _internal_instantalphapath();
}
inline void ImageArchive::unsafe_arena_set_allocated_instantalphapath(
    ::TSP::Path* instantalphapath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instantalphapath_);
  }
  instantalphapath_ = instantalphapath;
  if (instantalphapath) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.instantAlphaPath)
}
inline ::TSP::Path* ImageArchive::release_instantalphapath() {
  _has_bits_[0] &= ~0x00000100u;
  ::TSP::Path* temp = instantalphapath_;
  instantalphapath_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Path* ImageArchive::unsafe_arena_release_instantalphapath() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.instantAlphaPath)
  _has_bits_[0] &= ~0x00000100u;
  ::TSP::Path* temp = instantalphapath_;
  instantalphapath_ = nullptr;
  return temp;
}
inline ::TSP::Path* ImageArchive::_internal_mutable_instantalphapath() {
  _has_bits_[0] |= 0x00000100u;
  if (instantalphapath_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Path>(GetArena());
    instantalphapath_ = p;
  }
  return instantalphapath_;
}
inline ::TSP::Path* ImageArchive::mutable_instantalphapath() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.instantAlphaPath)
  return _internal_mutable_instantalphapath();
}
inline void ImageArchive::set_allocated_instantalphapath(::TSP::Path* instantalphapath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(instantalphapath_);
  }
  if (instantalphapath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instantalphapath)->GetArena();
    if (message_arena != submessage_arena) {
      instantalphapath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instantalphapath, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  instantalphapath_ = instantalphapath;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.instantAlphaPath)
}

// optional .TSD.ImageAdjustmentsArchive imageAdjustments = 14;
inline bool ImageArchive::_internal_has_imageadjustments() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || imageadjustments_ != nullptr);
  return value;
}
inline bool ImageArchive::has_imageadjustments() const {
  return _internal_has_imageadjustments();
}
inline void ImageArchive::clear_imageadjustments() {
  if (imageadjustments_ != nullptr) imageadjustments_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::TSD::ImageAdjustmentsArchive& ImageArchive::_internal_imageadjustments() const {
  const ::TSD::ImageAdjustmentsArchive* p = imageadjustments_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ImageAdjustmentsArchive&>(
      ::TSD::_ImageAdjustmentsArchive_default_instance_);
}
inline const ::TSD::ImageAdjustmentsArchive& ImageArchive::imageadjustments() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.imageAdjustments)
  return _internal_imageadjustments();
}
inline void ImageArchive::unsafe_arena_set_allocated_imageadjustments(
    ::TSD::ImageAdjustmentsArchive* imageadjustments) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(imageadjustments_);
  }
  imageadjustments_ = imageadjustments;
  if (imageadjustments) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.imageAdjustments)
}
inline ::TSD::ImageAdjustmentsArchive* ImageArchive::release_imageadjustments() {
  _has_bits_[0] &= ~0x00001000u;
  ::TSD::ImageAdjustmentsArchive* temp = imageadjustments_;
  imageadjustments_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::ImageAdjustmentsArchive* ImageArchive::unsafe_arena_release_imageadjustments() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.imageAdjustments)
  _has_bits_[0] &= ~0x00001000u;
  ::TSD::ImageAdjustmentsArchive* temp = imageadjustments_;
  imageadjustments_ = nullptr;
  return temp;
}
inline ::TSD::ImageAdjustmentsArchive* ImageArchive::_internal_mutable_imageadjustments() {
  _has_bits_[0] |= 0x00001000u;
  if (imageadjustments_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ImageAdjustmentsArchive>(GetArena());
    imageadjustments_ = p;
  }
  return imageadjustments_;
}
inline ::TSD::ImageAdjustmentsArchive* ImageArchive::mutable_imageadjustments() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.imageAdjustments)
  return _internal_mutable_imageadjustments();
}
inline void ImageArchive::set_allocated_imageadjustments(::TSD::ImageAdjustmentsArchive* imageadjustments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete imageadjustments_;
  }
  if (imageadjustments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(imageadjustments);
    if (message_arena != submessage_arena) {
      imageadjustments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imageadjustments, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  imageadjustments_ = imageadjustments;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.imageAdjustments)
}

// optional .TSP.DataReference enhancedImageData = 17;
inline bool ImageArchive::_internal_has_enhancedimagedata() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || enhancedimagedata_ != nullptr);
  return value;
}
inline bool ImageArchive::has_enhancedimagedata() const {
  return _internal_has_enhancedimagedata();
}
inline const ::TSP::DataReference& ImageArchive::_internal_enhancedimagedata() const {
  const ::TSP::DataReference* p = enhancedimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageArchive::enhancedimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.enhancedImageData)
  return _internal_enhancedimagedata();
}
inline void ImageArchive::unsafe_arena_set_allocated_enhancedimagedata(
    ::TSP::DataReference* enhancedimagedata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enhancedimagedata_);
  }
  enhancedimagedata_ = enhancedimagedata;
  if (enhancedimagedata) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.enhancedImageData)
}
inline ::TSP::DataReference* ImageArchive::release_enhancedimagedata() {
  _has_bits_[0] &= ~0x00008000u;
  ::TSP::DataReference* temp = enhancedimagedata_;
  enhancedimagedata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* ImageArchive::unsafe_arena_release_enhancedimagedata() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.enhancedImageData)
  _has_bits_[0] &= ~0x00008000u;
  ::TSP::DataReference* temp = enhancedimagedata_;
  enhancedimagedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageArchive::_internal_mutable_enhancedimagedata() {
  _has_bits_[0] |= 0x00008000u;
  if (enhancedimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    enhancedimagedata_ = p;
  }
  return enhancedimagedata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_enhancedimagedata() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.enhancedImageData)
  return _internal_mutable_enhancedimagedata();
}
inline void ImageArchive::set_allocated_enhancedimagedata(::TSP::DataReference* enhancedimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(enhancedimagedata_);
  }
  if (enhancedimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enhancedimagedata)->GetArena();
    if (message_arena != submessage_arena) {
      enhancedimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enhancedimagedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  enhancedimagedata_ = enhancedimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.enhancedImageData)
}

// optional .TSP.DataReference adjustedImageData = 15;
inline bool ImageArchive::_internal_has_adjustedimagedata() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || adjustedimagedata_ != nullptr);
  return value;
}
inline bool ImageArchive::has_adjustedimagedata() const {
  return _internal_has_adjustedimagedata();
}
inline const ::TSP::DataReference& ImageArchive::_internal_adjustedimagedata() const {
  const ::TSP::DataReference* p = adjustedimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageArchive::adjustedimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.adjustedImageData)
  return _internal_adjustedimagedata();
}
inline void ImageArchive::unsafe_arena_set_allocated_adjustedimagedata(
    ::TSP::DataReference* adjustedimagedata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adjustedimagedata_);
  }
  adjustedimagedata_ = adjustedimagedata;
  if (adjustedimagedata) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.adjustedImageData)
}
inline ::TSP::DataReference* ImageArchive::release_adjustedimagedata() {
  _has_bits_[0] &= ~0x00002000u;
  ::TSP::DataReference* temp = adjustedimagedata_;
  adjustedimagedata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* ImageArchive::unsafe_arena_release_adjustedimagedata() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.adjustedImageData)
  _has_bits_[0] &= ~0x00002000u;
  ::TSP::DataReference* temp = adjustedimagedata_;
  adjustedimagedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageArchive::_internal_mutable_adjustedimagedata() {
  _has_bits_[0] |= 0x00002000u;
  if (adjustedimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    adjustedimagedata_ = p;
  }
  return adjustedimagedata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_adjustedimagedata() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.adjustedImageData)
  return _internal_mutable_adjustedimagedata();
}
inline void ImageArchive::set_allocated_adjustedimagedata(::TSP::DataReference* adjustedimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(adjustedimagedata_);
  }
  if (adjustedimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adjustedimagedata)->GetArena();
    if (message_arena != submessage_arena) {
      adjustedimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adjustedimagedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  adjustedimagedata_ = adjustedimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.adjustedImageData)
}

// optional .TSP.DataReference thumbnailAdjustedImageData = 16;
inline bool ImageArchive::_internal_has_thumbnailadjustedimagedata() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || thumbnailadjustedimagedata_ != nullptr);
  return value;
}
inline bool ImageArchive::has_thumbnailadjustedimagedata() const {
  return _internal_has_thumbnailadjustedimagedata();
}
inline const ::TSP::DataReference& ImageArchive::_internal_thumbnailadjustedimagedata() const {
  const ::TSP::DataReference* p = thumbnailadjustedimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageArchive::thumbnailadjustedimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.thumbnailAdjustedImageData)
  return _internal_thumbnailadjustedimagedata();
}
inline void ImageArchive::unsafe_arena_set_allocated_thumbnailadjustedimagedata(
    ::TSP::DataReference* thumbnailadjustedimagedata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(thumbnailadjustedimagedata_);
  }
  thumbnailadjustedimagedata_ = thumbnailadjustedimagedata;
  if (thumbnailadjustedimagedata) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.thumbnailAdjustedImageData)
}
inline ::TSP::DataReference* ImageArchive::release_thumbnailadjustedimagedata() {
  _has_bits_[0] &= ~0x00004000u;
  ::TSP::DataReference* temp = thumbnailadjustedimagedata_;
  thumbnailadjustedimagedata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* ImageArchive::unsafe_arena_release_thumbnailadjustedimagedata() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.thumbnailAdjustedImageData)
  _has_bits_[0] &= ~0x00004000u;
  ::TSP::DataReference* temp = thumbnailadjustedimagedata_;
  thumbnailadjustedimagedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageArchive::_internal_mutable_thumbnailadjustedimagedata() {
  _has_bits_[0] |= 0x00004000u;
  if (thumbnailadjustedimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    thumbnailadjustedimagedata_ = p;
  }
  return thumbnailadjustedimagedata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_thumbnailadjustedimagedata() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.thumbnailAdjustedImageData)
  return _internal_mutable_thumbnailadjustedimagedata();
}
inline void ImageArchive::set_allocated_thumbnailadjustedimagedata(::TSP::DataReference* thumbnailadjustedimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(thumbnailadjustedimagedata_);
  }
  if (thumbnailadjustedimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(thumbnailadjustedimagedata)->GetArena();
    if (message_arena != submessage_arena) {
      thumbnailadjustedimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thumbnailadjustedimagedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  thumbnailadjustedimagedata_ = thumbnailadjustedimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.thumbnailAdjustedImageData)
}

// optional bool interpretsUntaggedImageDataAsGeneric = 18;
inline bool ImageArchive::_internal_has_interpretsuntaggedimagedataasgeneric() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool ImageArchive::has_interpretsuntaggedimagedataasgeneric() const {
  return _internal_has_interpretsuntaggedimagedataasgeneric();
}
inline void ImageArchive::clear_interpretsuntaggedimagedataasgeneric() {
  interpretsuntaggedimagedataasgeneric_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool ImageArchive::_internal_interpretsuntaggedimagedataasgeneric() const {
  return interpretsuntaggedimagedataasgeneric_;
}
inline bool ImageArchive::interpretsuntaggedimagedataasgeneric() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.interpretsUntaggedImageDataAsGeneric)
  return _internal_interpretsuntaggedimagedataasgeneric();
}
inline void ImageArchive::_internal_set_interpretsuntaggedimagedataasgeneric(bool value) {
  _has_bits_[0] |= 0x00080000u;
  interpretsuntaggedimagedataasgeneric_ = value;
}
inline void ImageArchive::set_interpretsuntaggedimagedataasgeneric(bool value) {
  _internal_set_interpretsuntaggedimagedataasgeneric(value);
  // @@protoc_insertion_point(field_set:TSD.ImageArchive.interpretsUntaggedImageDataAsGeneric)
}

// optional .TSP.Reference database_data = 2;
inline bool ImageArchive::_internal_has_database_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || database_data_ != nullptr);
  return value;
}
inline bool ImageArchive::has_database_data() const {
  return _internal_has_database_data();
}
inline const ::TSP::Reference& ImageArchive::_internal_database_data() const {
  const ::TSP::Reference* p = database_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ImageArchive::database_data() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.database_data)
  return _internal_database_data();
}
inline void ImageArchive::unsafe_arena_set_allocated_database_data(
    ::TSP::Reference* database_data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_data_);
  }
  database_data_ = database_data;
  if (database_data) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.database_data)
}
inline ::TSP::Reference* ImageArchive::release_database_data() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = database_data_;
  database_data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* ImageArchive::unsafe_arena_release_database_data() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.database_data)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = database_data_;
  database_data_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ImageArchive::_internal_mutable_database_data() {
  _has_bits_[0] |= 0x00000002u;
  if (database_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    database_data_ = p;
  }
  return database_data_;
}
inline ::TSP::Reference* ImageArchive::mutable_database_data() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.database_data)
  return _internal_mutable_database_data();
}
inline void ImageArchive::set_allocated_database_data(::TSP::Reference* database_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_data_);
  }
  if (database_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_data)->GetArena();
    if (message_arena != submessage_arena) {
      database_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  database_data_ = database_data;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.database_data)
}

// optional .TSP.Reference database_thumbnailData = 6;
inline bool ImageArchive::_internal_has_database_thumbnaildata() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || database_thumbnaildata_ != nullptr);
  return value;
}
inline bool ImageArchive::has_database_thumbnaildata() const {
  return _internal_has_database_thumbnaildata();
}
inline const ::TSP::Reference& ImageArchive::_internal_database_thumbnaildata() const {
  const ::TSP::Reference* p = database_thumbnaildata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ImageArchive::database_thumbnaildata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.database_thumbnailData)
  return _internal_database_thumbnaildata();
}
inline void ImageArchive::unsafe_arena_set_allocated_database_thumbnaildata(
    ::TSP::Reference* database_thumbnaildata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_thumbnaildata_);
  }
  database_thumbnaildata_ = database_thumbnaildata;
  if (database_thumbnaildata) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.database_thumbnailData)
}
inline ::TSP::Reference* ImageArchive::release_database_thumbnaildata() {
  _has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = database_thumbnaildata_;
  database_thumbnaildata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* ImageArchive::unsafe_arena_release_database_thumbnaildata() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.database_thumbnailData)
  _has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = database_thumbnaildata_;
  database_thumbnaildata_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ImageArchive::_internal_mutable_database_thumbnaildata() {
  _has_bits_[0] |= 0x00000020u;
  if (database_thumbnaildata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    database_thumbnaildata_ = p;
  }
  return database_thumbnaildata_;
}
inline ::TSP::Reference* ImageArchive::mutable_database_thumbnaildata() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.database_thumbnailData)
  return _internal_mutable_database_thumbnaildata();
}
inline void ImageArchive::set_allocated_database_thumbnaildata(::TSP::Reference* database_thumbnaildata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_thumbnaildata_);
  }
  if (database_thumbnaildata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_thumbnaildata)->GetArena();
    if (message_arena != submessage_arena) {
      database_thumbnaildata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_thumbnaildata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  database_thumbnaildata_ = database_thumbnaildata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.database_thumbnailData)
}

// optional .TSP.Reference database_originalData = 8;
inline bool ImageArchive::_internal_has_database_originaldata() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || database_originaldata_ != nullptr);
  return value;
}
inline bool ImageArchive::has_database_originaldata() const {
  return _internal_has_database_originaldata();
}
inline const ::TSP::Reference& ImageArchive::_internal_database_originaldata() const {
  const ::TSP::Reference* p = database_originaldata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ImageArchive::database_originaldata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.database_originalData)
  return _internal_database_originaldata();
}
inline void ImageArchive::unsafe_arena_set_allocated_database_originaldata(
    ::TSP::Reference* database_originaldata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_originaldata_);
  }
  database_originaldata_ = database_originaldata;
  if (database_originaldata) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.database_originalData)
}
inline ::TSP::Reference* ImageArchive::release_database_originaldata() {
  _has_bits_[0] &= ~0x00000040u;
  ::TSP::Reference* temp = database_originaldata_;
  database_originaldata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* ImageArchive::unsafe_arena_release_database_originaldata() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.database_originalData)
  _has_bits_[0] &= ~0x00000040u;
  ::TSP::Reference* temp = database_originaldata_;
  database_originaldata_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ImageArchive::_internal_mutable_database_originaldata() {
  _has_bits_[0] |= 0x00000040u;
  if (database_originaldata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    database_originaldata_ = p;
  }
  return database_originaldata_;
}
inline ::TSP::Reference* ImageArchive::mutable_database_originaldata() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.database_originalData)
  return _internal_mutable_database_originaldata();
}
inline void ImageArchive::set_allocated_database_originaldata(::TSP::Reference* database_originaldata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_originaldata_);
  }
  if (database_originaldata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_originaldata)->GetArena();
    if (message_arena != submessage_arena) {
      database_originaldata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_originaldata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  database_originaldata_ = database_originaldata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.database_originalData)
}

// optional .TSP.Path traced_path = 19;
inline bool ImageArchive::_internal_has_traced_path() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || traced_path_ != nullptr);
  return value;
}
inline bool ImageArchive::has_traced_path() const {
  return _internal_has_traced_path();
}
inline const ::TSP::Path& ImageArchive::_internal_traced_path() const {
  const ::TSP::Path* p = traced_path_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Path&>(
      ::TSP::_Path_default_instance_);
}
inline const ::TSP::Path& ImageArchive::traced_path() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.traced_path)
  return _internal_traced_path();
}
inline void ImageArchive::unsafe_arena_set_allocated_traced_path(
    ::TSP::Path* traced_path) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(traced_path_);
  }
  traced_path_ = traced_path;
  if (traced_path) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.traced_path)
}
inline ::TSP::Path* ImageArchive::release_traced_path() {
  _has_bits_[0] &= ~0x00010000u;
  ::TSP::Path* temp = traced_path_;
  traced_path_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Path* ImageArchive::unsafe_arena_release_traced_path() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.traced_path)
  _has_bits_[0] &= ~0x00010000u;
  ::TSP::Path* temp = traced_path_;
  traced_path_ = nullptr;
  return temp;
}
inline ::TSP::Path* ImageArchive::_internal_mutable_traced_path() {
  _has_bits_[0] |= 0x00010000u;
  if (traced_path_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Path>(GetArena());
    traced_path_ = p;
  }
  return traced_path_;
}
inline ::TSP::Path* ImageArchive::mutable_traced_path() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.traced_path)
  return _internal_mutable_traced_path();
}
inline void ImageArchive::set_allocated_traced_path(::TSP::Path* traced_path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(traced_path_);
  }
  if (traced_path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(traced_path)->GetArena();
    if (message_arena != submessage_arena) {
      traced_path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, traced_path, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  traced_path_ = traced_path;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.traced_path)
}

// optional .TSD.Attribution attribution = 20;
inline bool ImageArchive::_internal_has_attribution() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || attribution_ != nullptr);
  return value;
}
inline bool ImageArchive::has_attribution() const {
  return _internal_has_attribution();
}
inline void ImageArchive::clear_attribution() {
  if (attribution_ != nullptr) attribution_->Clear();
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::TSD::Attribution& ImageArchive::_internal_attribution() const {
  const ::TSD::Attribution* p = attribution_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::Attribution&>(
      ::TSD::_Attribution_default_instance_);
}
inline const ::TSD::Attribution& ImageArchive::attribution() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.attribution)
  return _internal_attribution();
}
inline void ImageArchive::unsafe_arena_set_allocated_attribution(
    ::TSD::Attribution* attribution) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attribution_);
  }
  attribution_ = attribution;
  if (attribution) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.attribution)
}
inline ::TSD::Attribution* ImageArchive::release_attribution() {
  _has_bits_[0] &= ~0x00020000u;
  ::TSD::Attribution* temp = attribution_;
  attribution_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::Attribution* ImageArchive::unsafe_arena_release_attribution() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.attribution)
  _has_bits_[0] &= ~0x00020000u;
  ::TSD::Attribution* temp = attribution_;
  attribution_ = nullptr;
  return temp;
}
inline ::TSD::Attribution* ImageArchive::_internal_mutable_attribution() {
  _has_bits_[0] |= 0x00020000u;
  if (attribution_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::Attribution>(GetArena());
    attribution_ = p;
  }
  return attribution_;
}
inline ::TSD::Attribution* ImageArchive::mutable_attribution() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.attribution)
  return _internal_mutable_attribution();
}
inline void ImageArchive::set_allocated_attribution(::TSD::Attribution* attribution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete attribution_;
  }
  if (attribution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(attribution);
    if (message_arena != submessage_arena) {
      attribution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attribution, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  attribution_ = attribution;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.attribution)
}

// optional bool should_trace_pdf_content = 21;
inline bool ImageArchive::_internal_has_should_trace_pdf_content() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool ImageArchive::has_should_trace_pdf_content() const {
  return _internal_has_should_trace_pdf_content();
}
inline void ImageArchive::clear_should_trace_pdf_content() {
  should_trace_pdf_content_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool ImageArchive::_internal_should_trace_pdf_content() const {
  return should_trace_pdf_content_;
}
inline bool ImageArchive::should_trace_pdf_content() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.should_trace_pdf_content)
  return _internal_should_trace_pdf_content();
}
inline void ImageArchive::_internal_set_should_trace_pdf_content(bool value) {
  _has_bits_[0] |= 0x00100000u;
  should_trace_pdf_content_ = value;
}
inline void ImageArchive::set_should_trace_pdf_content(bool value) {
  _internal_set_should_trace_pdf_content(value);
  // @@protoc_insertion_point(field_set:TSD.ImageArchive.should_trace_pdf_content)
}

// -------------------------------------------------------------------

// MaskArchive

// required .TSD.DrawableArchive super = 1;
inline bool MaskArchive::_internal_has_super() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || super_ != nullptr);
  return value;
}
inline bool MaskArchive::has_super() const {
  return _internal_has_super();
}
inline void MaskArchive::clear_super() {
  if (super_ != nullptr) super_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::DrawableArchive& MaskArchive::_internal_super() const {
  const ::TSD::DrawableArchive* p = super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DrawableArchive&>(
      ::TSD::_DrawableArchive_default_instance_);
}
inline const ::TSD::DrawableArchive& MaskArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.MaskArchive.super)
  return _internal_super();
}
inline void MaskArchive::unsafe_arena_set_allocated_super(
    ::TSD::DrawableArchive* super) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  super_ = super;
  if (super) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MaskArchive.super)
}
inline ::TSD::DrawableArchive* MaskArchive::release_super() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = super_;
  super_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::DrawableArchive* MaskArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.MaskArchive.super)
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = super_;
  super_ = nullptr;
  return temp;
}
inline ::TSD::DrawableArchive* MaskArchive::_internal_mutable_super() {
  _has_bits_[0] |= 0x00000001u;
  if (super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DrawableArchive>(GetArena());
    super_ = p;
  }
  return super_;
}
inline ::TSD::DrawableArchive* MaskArchive::mutable_super() {
  // @@protoc_insertion_point(field_mutable:TSD.MaskArchive.super)
  return _internal_mutable_super();
}
inline void MaskArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.MaskArchive.super)
}

// optional .TSD.PathSourceArchive pathsource = 2;
inline bool MaskArchive::_internal_has_pathsource() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || pathsource_ != nullptr);
  return value;
}
inline bool MaskArchive::has_pathsource() const {
  return _internal_has_pathsource();
}
inline void MaskArchive::clear_pathsource() {
  if (pathsource_ != nullptr) pathsource_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::PathSourceArchive& MaskArchive::_internal_pathsource() const {
  const ::TSD::PathSourceArchive* p = pathsource_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::PathSourceArchive&>(
      ::TSD::_PathSourceArchive_default_instance_);
}
inline const ::TSD::PathSourceArchive& MaskArchive::pathsource() const {
  // @@protoc_insertion_point(field_get:TSD.MaskArchive.pathsource)
  return _internal_pathsource();
}
inline void MaskArchive::unsafe_arena_set_allocated_pathsource(
    ::TSD::PathSourceArchive* pathsource) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathsource_);
  }
  pathsource_ = pathsource;
  if (pathsource) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MaskArchive.pathsource)
}
inline ::TSD::PathSourceArchive* MaskArchive::release_pathsource() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::PathSourceArchive* temp = pathsource_;
  pathsource_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::PathSourceArchive* MaskArchive::unsafe_arena_release_pathsource() {
  // @@protoc_insertion_point(field_release:TSD.MaskArchive.pathsource)
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::PathSourceArchive* temp = pathsource_;
  pathsource_ = nullptr;
  return temp;
}
inline ::TSD::PathSourceArchive* MaskArchive::_internal_mutable_pathsource() {
  _has_bits_[0] |= 0x00000002u;
  if (pathsource_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::PathSourceArchive>(GetArena());
    pathsource_ = p;
  }
  return pathsource_;
}
inline ::TSD::PathSourceArchive* MaskArchive::mutable_pathsource() {
  // @@protoc_insertion_point(field_mutable:TSD.MaskArchive.pathsource)
  return _internal_mutable_pathsource();
}
inline void MaskArchive::set_allocated_pathsource(::TSD::PathSourceArchive* pathsource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pathsource_;
  }
  if (pathsource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pathsource);
    if (message_arena != submessage_arena) {
      pathsource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathsource, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pathsource_ = pathsource;
  // @@protoc_insertion_point(field_set_allocated:TSD.MaskArchive.pathsource)
}

// -------------------------------------------------------------------

// ImageDataAttributes

// optional .TSP.Size pixel_size = 1;
inline bool ImageDataAttributes::_internal_has_pixel_size() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || pixel_size_ != nullptr);
  return value;
}
inline bool ImageDataAttributes::has_pixel_size() const {
  return _internal_has_pixel_size();
}
inline const ::TSP::Size& ImageDataAttributes::_internal_pixel_size() const {
  const ::TSP::Size* p = pixel_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& ImageDataAttributes::pixel_size() const {
  // @@protoc_insertion_point(field_get:TSD.ImageDataAttributes.pixel_size)
  return _internal_pixel_size();
}
inline void ImageDataAttributes::unsafe_arena_set_allocated_pixel_size(
    ::TSP::Size* pixel_size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pixel_size_);
  }
  pixel_size_ = pixel_size;
  if (pixel_size) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageDataAttributes.pixel_size)
}
inline ::TSP::Size* ImageDataAttributes::release_pixel_size() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Size* temp = pixel_size_;
  pixel_size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* ImageDataAttributes::unsafe_arena_release_pixel_size() {
  // @@protoc_insertion_point(field_release:TSD.ImageDataAttributes.pixel_size)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Size* temp = pixel_size_;
  pixel_size_ = nullptr;
  return temp;
}
inline ::TSP::Size* ImageDataAttributes::_internal_mutable_pixel_size() {
  _has_bits_[0] |= 0x00000001u;
  if (pixel_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    pixel_size_ = p;
  }
  return pixel_size_;
}
inline ::TSP::Size* ImageDataAttributes::mutable_pixel_size() {
  // @@protoc_insertion_point(field_mutable:TSD.ImageDataAttributes.pixel_size)
  return _internal_mutable_pixel_size();
}
inline void ImageDataAttributes::set_allocated_pixel_size(::TSP::Size* pixel_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pixel_size_);
  }
  if (pixel_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pixel_size)->GetArena();
    if (message_arena != submessage_arena) {
      pixel_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pixel_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pixel_size_ = pixel_size;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageDataAttributes.pixel_size)
}

// optional bool image_is_srgb = 2;
inline bool ImageDataAttributes::_internal_has_image_is_srgb() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ImageDataAttributes::has_image_is_srgb() const {
  return _internal_has_image_is_srgb();
}
inline void ImageDataAttributes::clear_image_is_srgb() {
  image_is_srgb_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ImageDataAttributes::_internal_image_is_srgb() const {
  return image_is_srgb_;
}
inline bool ImageDataAttributes::image_is_srgb() const {
  // @@protoc_insertion_point(field_get:TSD.ImageDataAttributes.image_is_srgb)
  return _internal_image_is_srgb();
}
inline void ImageDataAttributes::_internal_set_image_is_srgb(bool value) {
  _has_bits_[0] |= 0x00000002u;
  image_is_srgb_ = value;
}
inline void ImageDataAttributes::set_image_is_srgb(bool value) {
  _internal_set_image_is_srgb(value);
  // @@protoc_insertion_point(field_set:TSD.ImageDataAttributes.image_is_srgb)
}

// optional bool should_be_interpreted_as_generic_if_untagged = 3;
inline bool ImageDataAttributes::_internal_has_should_be_interpreted_as_generic_if_untagged() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ImageDataAttributes::has_should_be_interpreted_as_generic_if_untagged() const {
  return _internal_has_should_be_interpreted_as_generic_if_untagged();
}
inline void ImageDataAttributes::clear_should_be_interpreted_as_generic_if_untagged() {
  should_be_interpreted_as_generic_if_untagged_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ImageDataAttributes::_internal_should_be_interpreted_as_generic_if_untagged() const {
  return should_be_interpreted_as_generic_if_untagged_;
}
inline bool ImageDataAttributes::should_be_interpreted_as_generic_if_untagged() const {
  // @@protoc_insertion_point(field_get:TSD.ImageDataAttributes.should_be_interpreted_as_generic_if_untagged)
  return _internal_should_be_interpreted_as_generic_if_untagged();
}
inline void ImageDataAttributes::_internal_set_should_be_interpreted_as_generic_if_untagged(bool value) {
  _has_bits_[0] |= 0x00000004u;
  should_be_interpreted_as_generic_if_untagged_ = value;
}
inline void ImageDataAttributes::set_should_be_interpreted_as_generic_if_untagged(bool value) {
  _internal_set_should_be_interpreted_as_generic_if_untagged(value);
  // @@protoc_insertion_point(field_set:TSD.ImageDataAttributes.should_be_interpreted_as_generic_if_untagged)
}

// -------------------------------------------------------------------

// MovieArchive

// required .TSD.DrawableArchive super = 1;
inline bool MovieArchive::_internal_has_super() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || super_ != nullptr);
  return value;
}
inline bool MovieArchive::has_super() const {
  return _internal_has_super();
}
inline void MovieArchive::clear_super() {
  if (super_ != nullptr) super_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::DrawableArchive& MovieArchive::_internal_super() const {
  const ::TSD::DrawableArchive* p = super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DrawableArchive&>(
      ::TSD::_DrawableArchive_default_instance_);
}
inline const ::TSD::DrawableArchive& MovieArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.super)
  return _internal_super();
}
inline void MovieArchive::unsafe_arena_set_allocated_super(
    ::TSD::DrawableArchive* super) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  super_ = super;
  if (super) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.super)
}
inline ::TSD::DrawableArchive* MovieArchive::release_super() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::DrawableArchive* temp = super_;
  super_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::DrawableArchive* MovieArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.super)
  _has_bits_[0] &= ~0x00000004u;
  ::TSD::DrawableArchive* temp = super_;
  super_ = nullptr;
  return temp;
}
inline ::TSD::DrawableArchive* MovieArchive::_internal_mutable_super() {
  _has_bits_[0] |= 0x00000004u;
  if (super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DrawableArchive>(GetArena());
    super_ = p;
  }
  return super_;
}
inline ::TSD::DrawableArchive* MovieArchive::mutable_super() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.super)
  return _internal_mutable_super();
}
inline void MovieArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.super)
}

// optional .TSP.DataReference movieData = 14;
inline bool MovieArchive::_internal_has_moviedata() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || moviedata_ != nullptr);
  return value;
}
inline bool MovieArchive::has_moviedata() const {
  return _internal_has_moviedata();
}
inline const ::TSP::DataReference& MovieArchive::_internal_moviedata() const {
  const ::TSP::DataReference* p = moviedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& MovieArchive::moviedata() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.movieData)
  return _internal_moviedata();
}
inline void MovieArchive::unsafe_arena_set_allocated_moviedata(
    ::TSP::DataReference* moviedata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(moviedata_);
  }
  moviedata_ = moviedata;
  if (moviedata) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.movieData)
}
inline ::TSP::DataReference* MovieArchive::release_moviedata() {
  _has_bits_[0] &= ~0x00000040u;
  ::TSP::DataReference* temp = moviedata_;
  moviedata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* MovieArchive::unsafe_arena_release_moviedata() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.movieData)
  _has_bits_[0] &= ~0x00000040u;
  ::TSP::DataReference* temp = moviedata_;
  moviedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* MovieArchive::_internal_mutable_moviedata() {
  _has_bits_[0] |= 0x00000040u;
  if (moviedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    moviedata_ = p;
  }
  return moviedata_;
}
inline ::TSP::DataReference* MovieArchive::mutable_moviedata() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.movieData)
  return _internal_mutable_moviedata();
}
inline void MovieArchive::set_allocated_moviedata(::TSP::DataReference* moviedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(moviedata_);
  }
  if (moviedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(moviedata)->GetArena();
    if (message_arena != submessage_arena) {
      moviedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, moviedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  moviedata_ = moviedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.movieData)
}

// optional .TSP.DataReference importedAuxiliaryMovieData = 22;
inline bool MovieArchive::_internal_has_importedauxiliarymoviedata() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || importedauxiliarymoviedata_ != nullptr);
  return value;
}
inline bool MovieArchive::has_importedauxiliarymoviedata() const {
  return _internal_has_importedauxiliarymoviedata();
}
inline const ::TSP::DataReference& MovieArchive::_internal_importedauxiliarymoviedata() const {
  const ::TSP::DataReference* p = importedauxiliarymoviedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& MovieArchive::importedauxiliarymoviedata() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.importedAuxiliaryMovieData)
  return _internal_importedauxiliarymoviedata();
}
inline void MovieArchive::unsafe_arena_set_allocated_importedauxiliarymoviedata(
    ::TSP::DataReference* importedauxiliarymoviedata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(importedauxiliarymoviedata_);
  }
  importedauxiliarymoviedata_ = importedauxiliarymoviedata;
  if (importedauxiliarymoviedata) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.importedAuxiliaryMovieData)
}
inline ::TSP::DataReference* MovieArchive::release_importedauxiliarymoviedata() {
  _has_bits_[0] &= ~0x00001000u;
  ::TSP::DataReference* temp = importedauxiliarymoviedata_;
  importedauxiliarymoviedata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* MovieArchive::unsafe_arena_release_importedauxiliarymoviedata() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.importedAuxiliaryMovieData)
  _has_bits_[0] &= ~0x00001000u;
  ::TSP::DataReference* temp = importedauxiliarymoviedata_;
  importedauxiliarymoviedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* MovieArchive::_internal_mutable_importedauxiliarymoviedata() {
  _has_bits_[0] |= 0x00001000u;
  if (importedauxiliarymoviedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    importedauxiliarymoviedata_ = p;
  }
  return importedauxiliarymoviedata_;
}
inline ::TSP::DataReference* MovieArchive::mutable_importedauxiliarymoviedata() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.importedAuxiliaryMovieData)
  return _internal_mutable_importedauxiliarymoviedata();
}
inline void MovieArchive::set_allocated_importedauxiliarymoviedata(::TSP::DataReference* importedauxiliarymoviedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(importedauxiliarymoviedata_);
  }
  if (importedauxiliarymoviedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(importedauxiliarymoviedata)->GetArena();
    if (message_arena != submessage_arena) {
      importedauxiliarymoviedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, importedauxiliarymoviedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  importedauxiliarymoviedata_ = importedauxiliarymoviedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.importedAuxiliaryMovieData)
}

// optional string imported_auxiliary_movie_data_original_filename = 25;
inline bool MovieArchive::_internal_has_imported_auxiliary_movie_data_original_filename() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MovieArchive::has_imported_auxiliary_movie_data_original_filename() const {
  return _internal_has_imported_auxiliary_movie_data_original_filename();
}
inline void MovieArchive::clear_imported_auxiliary_movie_data_original_filename() {
  imported_auxiliary_movie_data_original_filename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MovieArchive::imported_auxiliary_movie_data_original_filename() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.imported_auxiliary_movie_data_original_filename)
  return _internal_imported_auxiliary_movie_data_original_filename();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void MovieArchive::set_imported_auxiliary_movie_data_original_filename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 imported_auxiliary_movie_data_original_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.imported_auxiliary_movie_data_original_filename)
}
inline std::string* MovieArchive::mutable_imported_auxiliary_movie_data_original_filename() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.imported_auxiliary_movie_data_original_filename)
  return _internal_mutable_imported_auxiliary_movie_data_original_filename();
}
inline const std::string& MovieArchive::_internal_imported_auxiliary_movie_data_original_filename() const {
  return imported_auxiliary_movie_data_original_filename_.Get();
}
inline void MovieArchive::_internal_set_imported_auxiliary_movie_data_original_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  imported_auxiliary_movie_data_original_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* MovieArchive::_internal_mutable_imported_auxiliary_movie_data_original_filename() {
  _has_bits_[0] |= 0x00000002u;
  return imported_auxiliary_movie_data_original_filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MovieArchive::release_imported_auxiliary_movie_data_original_filename() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.imported_auxiliary_movie_data_original_filename)
  if (!_internal_has_imported_auxiliary_movie_data_original_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return imported_auxiliary_movie_data_original_filename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MovieArchive::set_allocated_imported_auxiliary_movie_data_original_filename(std::string* imported_auxiliary_movie_data_original_filename) {
  if (imported_auxiliary_movie_data_original_filename != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  imported_auxiliary_movie_data_original_filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), imported_auxiliary_movie_data_original_filename,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.imported_auxiliary_movie_data_original_filename)
}

// optional string movieRemoteURL = 17;
inline bool MovieArchive::_internal_has_movieremoteurl() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MovieArchive::has_movieremoteurl() const {
  return _internal_has_movieremoteurl();
}
inline void MovieArchive::clear_movieremoteurl() {
  movieremoteurl_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MovieArchive::movieremoteurl() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.movieRemoteURL)
  return _internal_movieremoteurl();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void MovieArchive::set_movieremoteurl(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 movieremoteurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.movieRemoteURL)
}
inline std::string* MovieArchive::mutable_movieremoteurl() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.movieRemoteURL)
  return _internal_mutable_movieremoteurl();
}
inline const std::string& MovieArchive::_internal_movieremoteurl() const {
  return movieremoteurl_.Get();
}
inline void MovieArchive::_internal_set_movieremoteurl(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  movieremoteurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* MovieArchive::_internal_mutable_movieremoteurl() {
  _has_bits_[0] |= 0x00000001u;
  return movieremoteurl_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MovieArchive::release_movieremoteurl() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.movieRemoteURL)
  if (!_internal_has_movieremoteurl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return movieremoteurl_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MovieArchive::set_allocated_movieremoteurl(std::string* movieremoteurl) {
  if (movieremoteurl != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  movieremoteurl_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), movieremoteurl,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.movieRemoteURL)
}

// optional float startTime = 3;
inline bool MovieArchive::_internal_has_starttime() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool MovieArchive::has_starttime() const {
  return _internal_has_starttime();
}
inline void MovieArchive::clear_starttime() {
  starttime_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline float MovieArchive::_internal_starttime() const {
  return starttime_;
}
inline float MovieArchive::starttime() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.startTime)
  return _internal_starttime();
}
inline void MovieArchive::_internal_set_starttime(float value) {
  _has_bits_[0] |= 0x00008000u;
  starttime_ = value;
}
inline void MovieArchive::set_starttime(float value) {
  _internal_set_starttime(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.startTime)
}

// optional float endTime = 4;
inline bool MovieArchive::_internal_has_endtime() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool MovieArchive::has_endtime() const {
  return _internal_has_endtime();
}
inline void MovieArchive::clear_endtime() {
  endtime_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline float MovieArchive::_internal_endtime() const {
  return endtime_;
}
inline float MovieArchive::endtime() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.endTime)
  return _internal_endtime();
}
inline void MovieArchive::_internal_set_endtime(float value) {
  _has_bits_[0] |= 0x00010000u;
  endtime_ = value;
}
inline void MovieArchive::set_endtime(float value) {
  _internal_set_endtime(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.endTime)
}

// optional float posterTime = 5;
inline bool MovieArchive::_internal_has_postertime() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool MovieArchive::has_postertime() const {
  return _internal_has_postertime();
}
inline void MovieArchive::clear_postertime() {
  postertime_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline float MovieArchive::_internal_postertime() const {
  return postertime_;
}
inline float MovieArchive::postertime() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.posterTime)
  return _internal_postertime();
}
inline void MovieArchive::_internal_set_postertime(float value) {
  _has_bits_[0] |= 0x00020000u;
  postertime_ = value;
}
inline void MovieArchive::set_postertime(float value) {
  _internal_set_postertime(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.posterTime)
}

// optional uint32 loopOptionAsInteger = 6 [deprecated = true];
inline bool MovieArchive::_internal_has_loopoptionasinteger() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool MovieArchive::has_loopoptionasinteger() const {
  return _internal_has_loopoptionasinteger();
}
inline void MovieArchive::clear_loopoptionasinteger() {
  loopoptionasinteger_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MovieArchive::_internal_loopoptionasinteger() const {
  return loopoptionasinteger_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MovieArchive::loopoptionasinteger() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.loopOptionAsInteger)
  return _internal_loopoptionasinteger();
}
inline void MovieArchive::_internal_set_loopoptionasinteger(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00040000u;
  loopoptionasinteger_ = value;
}
inline void MovieArchive::set_loopoptionasinteger(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_loopoptionasinteger(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.loopOptionAsInteger)
}

// optional .TSD.MovieArchive.MovieLoopOption loop_option = 24 [default = None];
inline bool MovieArchive::_internal_has_loop_option() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool MovieArchive::has_loop_option() const {
  return _internal_has_loop_option();
}
inline void MovieArchive::clear_loop_option() {
  loop_option_ = 0;
  _has_bits_[0] &= ~0x04000000u;
}
inline ::TSD::MovieArchive_MovieLoopOption MovieArchive::_internal_loop_option() const {
  return static_cast< ::TSD::MovieArchive_MovieLoopOption >(loop_option_);
}
inline ::TSD::MovieArchive_MovieLoopOption MovieArchive::loop_option() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.loop_option)
  return _internal_loop_option();
}
inline void MovieArchive::_internal_set_loop_option(::TSD::MovieArchive_MovieLoopOption value) {
  assert(::TSD::MovieArchive_MovieLoopOption_IsValid(value));
  _has_bits_[0] |= 0x04000000u;
  loop_option_ = value;
}
inline void MovieArchive::set_loop_option(::TSD::MovieArchive_MovieLoopOption value) {
  _internal_set_loop_option(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.loop_option)
}

// optional float volume = 7;
inline bool MovieArchive::_internal_has_volume() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool MovieArchive::has_volume() const {
  return _internal_has_volume();
}
inline void MovieArchive::clear_volume() {
  volume_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline float MovieArchive::_internal_volume() const {
  return volume_;
}
inline float MovieArchive::volume() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.volume)
  return _internal_volume();
}
inline void MovieArchive::_internal_set_volume(float value) {
  _has_bits_[0] |= 0x00080000u;
  volume_ = value;
}
inline void MovieArchive::set_volume(float value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.volume)
}

// optional bool autoPlay = 8 [deprecated = true];
inline bool MovieArchive::_internal_has_autoplay() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool MovieArchive::has_autoplay() const {
  return _internal_has_autoplay();
}
inline void MovieArchive::clear_autoplay() {
  autoplay_ = false;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool MovieArchive::_internal_autoplay() const {
  return autoplay_;
}
inline bool MovieArchive::autoplay() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.autoPlay)
  return _internal_autoplay();
}
inline void MovieArchive::_internal_set_autoplay(bool value) {
  _has_bits_[0] |= 0x00400000u;
  autoplay_ = value;
}
inline void MovieArchive::set_autoplay(bool value) {
  _internal_set_autoplay(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.autoPlay)
}

// optional bool audioOnly = 9;
inline bool MovieArchive::_internal_has_audioonly() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool MovieArchive::has_audioonly() const {
  return _internal_has_audioonly();
}
inline void MovieArchive::clear_audioonly() {
  audioonly_ = false;
  _has_bits_[0] &= ~0x00800000u;
}
inline bool MovieArchive::_internal_audioonly() const {
  return audioonly_;
}
inline bool MovieArchive::audioonly() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.audioOnly)
  return _internal_audioonly();
}
inline void MovieArchive::_internal_set_audioonly(bool value) {
  _has_bits_[0] |= 0x00800000u;
  audioonly_ = value;
}
inline void MovieArchive::set_audioonly(bool value) {
  _internal_set_audioonly(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.audioOnly)
}

// optional bool streaming = 18;
inline bool MovieArchive::_internal_has_streaming() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool MovieArchive::has_streaming() const {
  return _internal_has_streaming();
}
inline void MovieArchive::clear_streaming() {
  streaming_ = false;
  _has_bits_[0] &= ~0x01000000u;
}
inline bool MovieArchive::_internal_streaming() const {
  return streaming_;
}
inline bool MovieArchive::streaming() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.streaming)
  return _internal_streaming();
}
inline void MovieArchive::_internal_set_streaming(bool value) {
  _has_bits_[0] |= 0x01000000u;
  streaming_ = value;
}
inline void MovieArchive::set_streaming(bool value) {
  _internal_set_streaming(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.streaming)
}

// optional bool nativeAudioRecording = 27;
inline bool MovieArchive::_internal_has_nativeaudiorecording() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool MovieArchive::has_nativeaudiorecording() const {
  return _internal_has_nativeaudiorecording();
}
inline void MovieArchive::clear_nativeaudiorecording() {
  nativeaudiorecording_ = false;
  _has_bits_[0] &= ~0x02000000u;
}
inline bool MovieArchive::_internal_nativeaudiorecording() const {
  return nativeaudiorecording_;
}
inline bool MovieArchive::nativeaudiorecording() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.nativeAudioRecording)
  return _internal_nativeaudiorecording();
}
inline void MovieArchive::_internal_set_nativeaudiorecording(bool value) {
  _has_bits_[0] |= 0x02000000u;
  nativeaudiorecording_ = value;
}
inline void MovieArchive::set_nativeaudiorecording(bool value) {
  _internal_set_nativeaudiorecording(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.nativeAudioRecording)
}

// optional bool playsAcrossSlides = 28;
inline bool MovieArchive::_internal_has_playsacrossslides() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool MovieArchive::has_playsacrossslides() const {
  return _internal_has_playsacrossslides();
}
inline void MovieArchive::clear_playsacrossslides() {
  playsacrossslides_ = false;
  _has_bits_[0] &= ~0x08000000u;
}
inline bool MovieArchive::_internal_playsacrossslides() const {
  return playsacrossslides_;
}
inline bool MovieArchive::playsacrossslides() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.playsAcrossSlides)
  return _internal_playsacrossslides();
}
inline void MovieArchive::_internal_set_playsacrossslides(bool value) {
  _has_bits_[0] |= 0x08000000u;
  playsacrossslides_ = value;
}
inline void MovieArchive::set_playsacrossslides(bool value) {
  _internal_set_playsacrossslides(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.playsAcrossSlides)
}

// optional .TSP.DataReference posterImageData = 15;
inline bool MovieArchive::_internal_has_posterimagedata() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || posterimagedata_ != nullptr);
  return value;
}
inline bool MovieArchive::has_posterimagedata() const {
  return _internal_has_posterimagedata();
}
inline const ::TSP::DataReference& MovieArchive::_internal_posterimagedata() const {
  const ::TSP::DataReference* p = posterimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& MovieArchive::posterimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.posterImageData)
  return _internal_posterimagedata();
}
inline void MovieArchive::unsafe_arena_set_allocated_posterimagedata(
    ::TSP::DataReference* posterimagedata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posterimagedata_);
  }
  posterimagedata_ = posterimagedata;
  if (posterimagedata) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.posterImageData)
}
inline ::TSP::DataReference* MovieArchive::release_posterimagedata() {
  _has_bits_[0] &= ~0x00000080u;
  ::TSP::DataReference* temp = posterimagedata_;
  posterimagedata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* MovieArchive::unsafe_arena_release_posterimagedata() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.posterImageData)
  _has_bits_[0] &= ~0x00000080u;
  ::TSP::DataReference* temp = posterimagedata_;
  posterimagedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* MovieArchive::_internal_mutable_posterimagedata() {
  _has_bits_[0] |= 0x00000080u;
  if (posterimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    posterimagedata_ = p;
  }
  return posterimagedata_;
}
inline ::TSP::DataReference* MovieArchive::mutable_posterimagedata() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.posterImageData)
  return _internal_mutable_posterimagedata();
}
inline void MovieArchive::set_allocated_posterimagedata(::TSP::DataReference* posterimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(posterimagedata_);
  }
  if (posterimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posterimagedata)->GetArena();
    if (message_arena != submessage_arena) {
      posterimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posterimagedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  posterimagedata_ = posterimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.posterImageData)
}

// optional .TSP.DataReference audioOnlyImageData = 16;
inline bool MovieArchive::_internal_has_audioonlyimagedata() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || audioonlyimagedata_ != nullptr);
  return value;
}
inline bool MovieArchive::has_audioonlyimagedata() const {
  return _internal_has_audioonlyimagedata();
}
inline const ::TSP::DataReference& MovieArchive::_internal_audioonlyimagedata() const {
  const ::TSP::DataReference* p = audioonlyimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& MovieArchive::audioonlyimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.audioOnlyImageData)
  return _internal_audioonlyimagedata();
}
inline void MovieArchive::unsafe_arena_set_allocated_audioonlyimagedata(
    ::TSP::DataReference* audioonlyimagedata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audioonlyimagedata_);
  }
  audioonlyimagedata_ = audioonlyimagedata;
  if (audioonlyimagedata) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.audioOnlyImageData)
}
inline ::TSP::DataReference* MovieArchive::release_audioonlyimagedata() {
  _has_bits_[0] &= ~0x00000100u;
  ::TSP::DataReference* temp = audioonlyimagedata_;
  audioonlyimagedata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* MovieArchive::unsafe_arena_release_audioonlyimagedata() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.audioOnlyImageData)
  _has_bits_[0] &= ~0x00000100u;
  ::TSP::DataReference* temp = audioonlyimagedata_;
  audioonlyimagedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* MovieArchive::_internal_mutable_audioonlyimagedata() {
  _has_bits_[0] |= 0x00000100u;
  if (audioonlyimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    audioonlyimagedata_ = p;
  }
  return audioonlyimagedata_;
}
inline ::TSP::DataReference* MovieArchive::mutable_audioonlyimagedata() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.audioOnlyImageData)
  return _internal_mutable_audioonlyimagedata();
}
inline void MovieArchive::set_allocated_audioonlyimagedata(::TSP::DataReference* audioonlyimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(audioonlyimagedata_);
  }
  if (audioonlyimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audioonlyimagedata)->GetArena();
    if (message_arena != submessage_arena) {
      audioonlyimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audioonlyimagedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  audioonlyimagedata_ = audioonlyimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.audioOnlyImageData)
}

// optional bool poster_image_generated_with_alpha_support = 23;
inline bool MovieArchive::_internal_has_poster_image_generated_with_alpha_support() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool MovieArchive::has_poster_image_generated_with_alpha_support() const {
  return _internal_has_poster_image_generated_with_alpha_support();
}
inline void MovieArchive::clear_poster_image_generated_with_alpha_support() {
  poster_image_generated_with_alpha_support_ = false;
  _has_bits_[0] &= ~0x10000000u;
}
inline bool MovieArchive::_internal_poster_image_generated_with_alpha_support() const {
  return poster_image_generated_with_alpha_support_;
}
inline bool MovieArchive::poster_image_generated_with_alpha_support() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.poster_image_generated_with_alpha_support)
  return _internal_poster_image_generated_with_alpha_support();
}
inline void MovieArchive::_internal_set_poster_image_generated_with_alpha_support(bool value) {
  _has_bits_[0] |= 0x10000000u;
  poster_image_generated_with_alpha_support_ = value;
}
inline void MovieArchive::set_poster_image_generated_with_alpha_support(bool value) {
  _internal_set_poster_image_generated_with_alpha_support(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.poster_image_generated_with_alpha_support)
}

// optional uint32 playableState = 12;
inline bool MovieArchive::_internal_has_playablestate() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool MovieArchive::has_playablestate() const {
  return _internal_has_playablestate();
}
inline void MovieArchive::clear_playablestate() {
  playablestate_ = 0u;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MovieArchive::_internal_playablestate() const {
  return playablestate_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MovieArchive::playablestate() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.playableState)
  return _internal_playablestate();
}
inline void MovieArchive::_internal_set_playablestate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00100000u;
  playablestate_ = value;
}
inline void MovieArchive::set_playablestate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_playablestate(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.playableState)
}

// optional uint32 flags = 13;
inline bool MovieArchive::_internal_has_flags() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool MovieArchive::has_flags() const {
  return _internal_has_flags();
}
inline void MovieArchive::clear_flags() {
  flags_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MovieArchive::_internal_flags() const {
  return flags_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MovieArchive::flags() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.flags)
  return _internal_flags();
}
inline void MovieArchive::_internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00200000u;
  flags_ = value;
}
inline void MovieArchive::set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.flags)
}

// optional .TSP.Reference database_movieData = 2;
inline bool MovieArchive::_internal_has_database_moviedata() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || database_moviedata_ != nullptr);
  return value;
}
inline bool MovieArchive::has_database_moviedata() const {
  return _internal_has_database_moviedata();
}
inline const ::TSP::Reference& MovieArchive::_internal_database_moviedata() const {
  const ::TSP::Reference* p = database_moviedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MovieArchive::database_moviedata() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.database_movieData)
  return _internal_database_moviedata();
}
inline void MovieArchive::unsafe_arena_set_allocated_database_moviedata(
    ::TSP::Reference* database_moviedata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_moviedata_);
  }
  database_moviedata_ = database_moviedata;
  if (database_moviedata) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.database_movieData)
}
inline ::TSP::Reference* MovieArchive::release_database_moviedata() {
  _has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = database_moviedata_;
  database_moviedata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* MovieArchive::unsafe_arena_release_database_moviedata() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.database_movieData)
  _has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = database_moviedata_;
  database_moviedata_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MovieArchive::_internal_mutable_database_moviedata() {
  _has_bits_[0] |= 0x00000008u;
  if (database_moviedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    database_moviedata_ = p;
  }
  return database_moviedata_;
}
inline ::TSP::Reference* MovieArchive::mutable_database_moviedata() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.database_movieData)
  return _internal_mutable_database_moviedata();
}
inline void MovieArchive::set_allocated_database_moviedata(::TSP::Reference* database_moviedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_moviedata_);
  }
  if (database_moviedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_moviedata)->GetArena();
    if (message_arena != submessage_arena) {
      database_moviedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_moviedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  database_moviedata_ = database_moviedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.database_movieData)
}

// optional .TSP.Reference database_posterImageData = 10;
inline bool MovieArchive::_internal_has_database_posterimagedata() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || database_posterimagedata_ != nullptr);
  return value;
}
inline bool MovieArchive::has_database_posterimagedata() const {
  return _internal_has_database_posterimagedata();
}
inline const ::TSP::Reference& MovieArchive::_internal_database_posterimagedata() const {
  const ::TSP::Reference* p = database_posterimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MovieArchive::database_posterimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.database_posterImageData)
  return _internal_database_posterimagedata();
}
inline void MovieArchive::unsafe_arena_set_allocated_database_posterimagedata(
    ::TSP::Reference* database_posterimagedata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_posterimagedata_);
  }
  database_posterimagedata_ = database_posterimagedata;
  if (database_posterimagedata) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.database_posterImageData)
}
inline ::TSP::Reference* MovieArchive::release_database_posterimagedata() {
  _has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = database_posterimagedata_;
  database_posterimagedata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* MovieArchive::unsafe_arena_release_database_posterimagedata() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.database_posterImageData)
  _has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = database_posterimagedata_;
  database_posterimagedata_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MovieArchive::_internal_mutable_database_posterimagedata() {
  _has_bits_[0] |= 0x00000010u;
  if (database_posterimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    database_posterimagedata_ = p;
  }
  return database_posterimagedata_;
}
inline ::TSP::Reference* MovieArchive::mutable_database_posterimagedata() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.database_posterImageData)
  return _internal_mutable_database_posterimagedata();
}
inline void MovieArchive::set_allocated_database_posterimagedata(::TSP::Reference* database_posterimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_posterimagedata_);
  }
  if (database_posterimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_posterimagedata)->GetArena();
    if (message_arena != submessage_arena) {
      database_posterimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_posterimagedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  database_posterimagedata_ = database_posterimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.database_posterImageData)
}

// optional .TSP.Reference database_audioOnlyImageData = 11;
inline bool MovieArchive::_internal_has_database_audioonlyimagedata() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || database_audioonlyimagedata_ != nullptr);
  return value;
}
inline bool MovieArchive::has_database_audioonlyimagedata() const {
  return _internal_has_database_audioonlyimagedata();
}
inline const ::TSP::Reference& MovieArchive::_internal_database_audioonlyimagedata() const {
  const ::TSP::Reference* p = database_audioonlyimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MovieArchive::database_audioonlyimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.database_audioOnlyImageData)
  return _internal_database_audioonlyimagedata();
}
inline void MovieArchive::unsafe_arena_set_allocated_database_audioonlyimagedata(
    ::TSP::Reference* database_audioonlyimagedata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_audioonlyimagedata_);
  }
  database_audioonlyimagedata_ = database_audioonlyimagedata;
  if (database_audioonlyimagedata) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.database_audioOnlyImageData)
}
inline ::TSP::Reference* MovieArchive::release_database_audioonlyimagedata() {
  _has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = database_audioonlyimagedata_;
  database_audioonlyimagedata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* MovieArchive::unsafe_arena_release_database_audioonlyimagedata() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.database_audioOnlyImageData)
  _has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = database_audioonlyimagedata_;
  database_audioonlyimagedata_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MovieArchive::_internal_mutable_database_audioonlyimagedata() {
  _has_bits_[0] |= 0x00000020u;
  if (database_audioonlyimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    database_audioonlyimagedata_ = p;
  }
  return database_audioonlyimagedata_;
}
inline ::TSP::Reference* MovieArchive::mutable_database_audioonlyimagedata() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.database_audioOnlyImageData)
  return _internal_mutable_database_audioonlyimagedata();
}
inline void MovieArchive::set_allocated_database_audioonlyimagedata(::TSP::Reference* database_audioonlyimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_audioonlyimagedata_);
  }
  if (database_audioonlyimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_audioonlyimagedata)->GetArena();
    if (message_arena != submessage_arena) {
      database_audioonlyimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_audioonlyimagedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  database_audioonlyimagedata_ = database_audioonlyimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.database_audioOnlyImageData)
}

// optional .TSP.Reference style = 19;
inline bool MovieArchive::_internal_has_style() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || style_ != nullptr);
  return value;
}
inline bool MovieArchive::has_style() const {
  return _internal_has_style();
}
inline const ::TSP::Reference& MovieArchive::_internal_style() const {
  const ::TSP::Reference* p = style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MovieArchive::style() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.style)
  return _internal_style();
}
inline void MovieArchive::unsafe_arena_set_allocated_style(
    ::TSP::Reference* style) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(style_);
  }
  style_ = style;
  if (style) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.style)
}
inline ::TSP::Reference* MovieArchive::release_style() {
  _has_bits_[0] &= ~0x00000200u;
  ::TSP::Reference* temp = style_;
  style_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* MovieArchive::unsafe_arena_release_style() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.style)
  _has_bits_[0] &= ~0x00000200u;
  ::TSP::Reference* temp = style_;
  style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MovieArchive::_internal_mutable_style() {
  _has_bits_[0] |= 0x00000200u;
  if (style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    style_ = p;
  }
  return style_;
}
inline ::TSP::Reference* MovieArchive::mutable_style() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.style)
  return _internal_mutable_style();
}
inline void MovieArchive::set_allocated_style(::TSP::Reference* style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(style_);
  }
  if (style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(style)->GetArena();
    if (message_arena != submessage_arena) {
      style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, style, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  style_ = style;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.style)
}

// optional .TSP.Size originalSize = 20;
inline bool MovieArchive::_internal_has_originalsize() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || originalsize_ != nullptr);
  return value;
}
inline bool MovieArchive::has_originalsize() const {
  return _internal_has_originalsize();
}
inline const ::TSP::Size& MovieArchive::_internal_originalsize() const {
  const ::TSP::Size* p = originalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& MovieArchive::originalsize() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.originalSize)
  return _internal_originalsize();
}
inline void MovieArchive::unsafe_arena_set_allocated_originalsize(
    ::TSP::Size* originalsize) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(originalsize_);
  }
  originalsize_ = originalsize;
  if (originalsize) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.originalSize)
}
inline ::TSP::Size* MovieArchive::release_originalsize() {
  _has_bits_[0] &= ~0x00000400u;
  ::TSP::Size* temp = originalsize_;
  originalsize_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* MovieArchive::unsafe_arena_release_originalsize() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.originalSize)
  _has_bits_[0] &= ~0x00000400u;
  ::TSP::Size* temp = originalsize_;
  originalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* MovieArchive::_internal_mutable_originalsize() {
  _has_bits_[0] |= 0x00000400u;
  if (originalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    originalsize_ = p;
  }
  return originalsize_;
}
inline ::TSP::Size* MovieArchive::mutable_originalsize() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.originalSize)
  return _internal_mutable_originalsize();
}
inline void MovieArchive::set_allocated_originalsize(::TSP::Size* originalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(originalsize_);
  }
  if (originalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(originalsize)->GetArena();
    if (message_arena != submessage_arena) {
      originalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, originalsize, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  originalsize_ = originalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.originalSize)
}

// optional .TSP.Size naturalSize = 21;
inline bool MovieArchive::_internal_has_naturalsize() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || naturalsize_ != nullptr);
  return value;
}
inline bool MovieArchive::has_naturalsize() const {
  return _internal_has_naturalsize();
}
inline const ::TSP::Size& MovieArchive::_internal_naturalsize() const {
  const ::TSP::Size* p = naturalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& MovieArchive::naturalsize() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.naturalSize)
  return _internal_naturalsize();
}
inline void MovieArchive::unsafe_arena_set_allocated_naturalsize(
    ::TSP::Size* naturalsize) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize_);
  }
  naturalsize_ = naturalsize;
  if (naturalsize) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.naturalSize)
}
inline ::TSP::Size* MovieArchive::release_naturalsize() {
  _has_bits_[0] &= ~0x00000800u;
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* MovieArchive::unsafe_arena_release_naturalsize() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.naturalSize)
  _has_bits_[0] &= ~0x00000800u;
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* MovieArchive::_internal_mutable_naturalsize() {
  _has_bits_[0] |= 0x00000800u;
  if (naturalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    naturalsize_ = p;
  }
  return naturalsize_;
}
inline ::TSP::Size* MovieArchive::mutable_naturalsize() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.naturalSize)
  return _internal_mutable_naturalsize();
}
inline void MovieArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize_);
  }
  if (naturalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize)->GetArena();
    if (message_arena != submessage_arena) {
      naturalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, naturalsize, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  naturalsize_ = naturalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.naturalSize)
}

// optional .TSD.Attribution attribution = 26;
inline bool MovieArchive::_internal_has_attribution() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || attribution_ != nullptr);
  return value;
}
inline bool MovieArchive::has_attribution() const {
  return _internal_has_attribution();
}
inline void MovieArchive::clear_attribution() {
  if (attribution_ != nullptr) attribution_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::TSD::Attribution& MovieArchive::_internal_attribution() const {
  const ::TSD::Attribution* p = attribution_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::Attribution&>(
      ::TSD::_Attribution_default_instance_);
}
inline const ::TSD::Attribution& MovieArchive::attribution() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.attribution)
  return _internal_attribution();
}
inline void MovieArchive::unsafe_arena_set_allocated_attribution(
    ::TSD::Attribution* attribution) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attribution_);
  }
  attribution_ = attribution;
  if (attribution) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.attribution)
}
inline ::TSD::Attribution* MovieArchive::release_attribution() {
  _has_bits_[0] &= ~0x00002000u;
  ::TSD::Attribution* temp = attribution_;
  attribution_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::Attribution* MovieArchive::unsafe_arena_release_attribution() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.attribution)
  _has_bits_[0] &= ~0x00002000u;
  ::TSD::Attribution* temp = attribution_;
  attribution_ = nullptr;
  return temp;
}
inline ::TSD::Attribution* MovieArchive::_internal_mutable_attribution() {
  _has_bits_[0] |= 0x00002000u;
  if (attribution_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::Attribution>(GetArena());
    attribution_ = p;
  }
  return attribution_;
}
inline ::TSD::Attribution* MovieArchive::mutable_attribution() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.attribution)
  return _internal_mutable_attribution();
}
inline void MovieArchive::set_allocated_attribution(::TSD::Attribution* attribution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete attribution_;
  }
  if (attribution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(attribution);
    if (message_arena != submessage_arena) {
      attribution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attribution, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  attribution_ = attribution;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.attribution)
}

// optional .TSD.MovieFingerprint fingerprint = 29;
inline bool MovieArchive::_internal_has_fingerprint() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || fingerprint_ != nullptr);
  return value;
}
inline bool MovieArchive::has_fingerprint() const {
  return _internal_has_fingerprint();
}
inline void MovieArchive::clear_fingerprint() {
  if (fingerprint_ != nullptr) fingerprint_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::TSD::MovieFingerprint& MovieArchive::_internal_fingerprint() const {
  const ::TSD::MovieFingerprint* p = fingerprint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::MovieFingerprint&>(
      ::TSD::_MovieFingerprint_default_instance_);
}
inline const ::TSD::MovieFingerprint& MovieArchive::fingerprint() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.fingerprint)
  return _internal_fingerprint();
}
inline void MovieArchive::unsafe_arena_set_allocated_fingerprint(
    ::TSD::MovieFingerprint* fingerprint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fingerprint_);
  }
  fingerprint_ = fingerprint;
  if (fingerprint) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.fingerprint)
}
inline ::TSD::MovieFingerprint* MovieArchive::release_fingerprint() {
  _has_bits_[0] &= ~0x00004000u;
  ::TSD::MovieFingerprint* temp = fingerprint_;
  fingerprint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::MovieFingerprint* MovieArchive::unsafe_arena_release_fingerprint() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.fingerprint)
  _has_bits_[0] &= ~0x00004000u;
  ::TSD::MovieFingerprint* temp = fingerprint_;
  fingerprint_ = nullptr;
  return temp;
}
inline ::TSD::MovieFingerprint* MovieArchive::_internal_mutable_fingerprint() {
  _has_bits_[0] |= 0x00004000u;
  if (fingerprint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::MovieFingerprint>(GetArena());
    fingerprint_ = p;
  }
  return fingerprint_;
}
inline ::TSD::MovieFingerprint* MovieArchive::mutable_fingerprint() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.fingerprint)
  return _internal_mutable_fingerprint();
}
inline void MovieArchive::set_allocated_fingerprint(::TSD::MovieFingerprint* fingerprint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fingerprint_;
  }
  if (fingerprint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fingerprint);
    if (message_arena != submessage_arena) {
      fingerprint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fingerprint, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  fingerprint_ = fingerprint;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.fingerprint)
}

// -------------------------------------------------------------------

// ExteriorTextWrapArchive

// optional uint32 type = 1;
inline bool ExteriorTextWrapArchive::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExteriorTextWrapArchive::has_type() const {
  return _internal_has_type();
}
inline void ExteriorTextWrapArchive::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExteriorTextWrapArchive::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExteriorTextWrapArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.ExteriorTextWrapArchive.type)
  return _internal_type();
}
inline void ExteriorTextWrapArchive::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void ExteriorTextWrapArchive::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.ExteriorTextWrapArchive.type)
}

// optional uint32 direction = 2;
inline bool ExteriorTextWrapArchive::_internal_has_direction() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExteriorTextWrapArchive::has_direction() const {
  return _internal_has_direction();
}
inline void ExteriorTextWrapArchive::clear_direction() {
  direction_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExteriorTextWrapArchive::_internal_direction() const {
  return direction_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExteriorTextWrapArchive::direction() const {
  // @@protoc_insertion_point(field_get:TSD.ExteriorTextWrapArchive.direction)
  return _internal_direction();
}
inline void ExteriorTextWrapArchive::_internal_set_direction(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  direction_ = value;
}
inline void ExteriorTextWrapArchive::set_direction(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:TSD.ExteriorTextWrapArchive.direction)
}

// optional uint32 fit_type = 3;
inline bool ExteriorTextWrapArchive::_internal_has_fit_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExteriorTextWrapArchive::has_fit_type() const {
  return _internal_has_fit_type();
}
inline void ExteriorTextWrapArchive::clear_fit_type() {
  fit_type_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExteriorTextWrapArchive::_internal_fit_type() const {
  return fit_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExteriorTextWrapArchive::fit_type() const {
  // @@protoc_insertion_point(field_get:TSD.ExteriorTextWrapArchive.fit_type)
  return _internal_fit_type();
}
inline void ExteriorTextWrapArchive::_internal_set_fit_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  fit_type_ = value;
}
inline void ExteriorTextWrapArchive::set_fit_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_fit_type(value);
  // @@protoc_insertion_point(field_set:TSD.ExteriorTextWrapArchive.fit_type)
}

// optional float margin = 4;
inline bool ExteriorTextWrapArchive::_internal_has_margin() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExteriorTextWrapArchive::has_margin() const {
  return _internal_has_margin();
}
inline void ExteriorTextWrapArchive::clear_margin() {
  margin_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float ExteriorTextWrapArchive::_internal_margin() const {
  return margin_;
}
inline float ExteriorTextWrapArchive::margin() const {
  // @@protoc_insertion_point(field_get:TSD.ExteriorTextWrapArchive.margin)
  return _internal_margin();
}
inline void ExteriorTextWrapArchive::_internal_set_margin(float value) {
  _has_bits_[0] |= 0x00000008u;
  margin_ = value;
}
inline void ExteriorTextWrapArchive::set_margin(float value) {
  _internal_set_margin(value);
  // @@protoc_insertion_point(field_set:TSD.ExteriorTextWrapArchive.margin)
}

// optional float alpha_threshold = 5;
inline bool ExteriorTextWrapArchive::_internal_has_alpha_threshold() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExteriorTextWrapArchive::has_alpha_threshold() const {
  return _internal_has_alpha_threshold();
}
inline void ExteriorTextWrapArchive::clear_alpha_threshold() {
  alpha_threshold_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float ExteriorTextWrapArchive::_internal_alpha_threshold() const {
  return alpha_threshold_;
}
inline float ExteriorTextWrapArchive::alpha_threshold() const {
  // @@protoc_insertion_point(field_get:TSD.ExteriorTextWrapArchive.alpha_threshold)
  return _internal_alpha_threshold();
}
inline void ExteriorTextWrapArchive::_internal_set_alpha_threshold(float value) {
  _has_bits_[0] |= 0x00000010u;
  alpha_threshold_ = value;
}
inline void ExteriorTextWrapArchive::set_alpha_threshold(float value) {
  _internal_set_alpha_threshold(value);
  // @@protoc_insertion_point(field_set:TSD.ExteriorTextWrapArchive.alpha_threshold)
}

// optional bool is_html_wrap = 6;
inline bool ExteriorTextWrapArchive::_internal_has_is_html_wrap() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExteriorTextWrapArchive::has_is_html_wrap() const {
  return _internal_has_is_html_wrap();
}
inline void ExteriorTextWrapArchive::clear_is_html_wrap() {
  is_html_wrap_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ExteriorTextWrapArchive::_internal_is_html_wrap() const {
  return is_html_wrap_;
}
inline bool ExteriorTextWrapArchive::is_html_wrap() const {
  // @@protoc_insertion_point(field_get:TSD.ExteriorTextWrapArchive.is_html_wrap)
  return _internal_is_html_wrap();
}
inline void ExteriorTextWrapArchive::_internal_set_is_html_wrap(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_html_wrap_ = value;
}
inline void ExteriorTextWrapArchive::set_is_html_wrap(bool value) {
  _internal_set_is_html_wrap(value);
  // @@protoc_insertion_point(field_set:TSD.ExteriorTextWrapArchive.is_html_wrap)
}

// -------------------------------------------------------------------

// DrawableContentDescription

// optional uint32 element_kind = 1;
inline bool DrawableContentDescription::_internal_has_element_kind() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DrawableContentDescription::has_element_kind() const {
  return _internal_has_element_kind();
}
inline void DrawableContentDescription::clear_element_kind() {
  element_kind_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DrawableContentDescription::_internal_element_kind() const {
  return element_kind_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DrawableContentDescription::element_kind() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableContentDescription.element_kind)
  return _internal_element_kind();
}
inline void DrawableContentDescription::_internal_set_element_kind(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  element_kind_ = value;
}
inline void DrawableContentDescription::set_element_kind(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_element_kind(value);
  // @@protoc_insertion_point(field_set:TSD.DrawableContentDescription.element_kind)
}

// optional bool is_anchored_to_text = 2;
inline bool DrawableContentDescription::_internal_has_is_anchored_to_text() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DrawableContentDescription::has_is_anchored_to_text() const {
  return _internal_has_is_anchored_to_text();
}
inline void DrawableContentDescription::clear_is_anchored_to_text() {
  is_anchored_to_text_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool DrawableContentDescription::_internal_is_anchored_to_text() const {
  return is_anchored_to_text_;
}
inline bool DrawableContentDescription::is_anchored_to_text() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableContentDescription.is_anchored_to_text)
  return _internal_is_anchored_to_text();
}
inline void DrawableContentDescription::_internal_set_is_anchored_to_text(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_anchored_to_text_ = value;
}
inline void DrawableContentDescription::set_is_anchored_to_text(bool value) {
  _internal_set_is_anchored_to_text(value);
  // @@protoc_insertion_point(field_set:TSD.DrawableContentDescription.is_anchored_to_text)
}

// optional bool is_floating_above_text = 3;
inline bool DrawableContentDescription::_internal_has_is_floating_above_text() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DrawableContentDescription::has_is_floating_above_text() const {
  return _internal_has_is_floating_above_text();
}
inline void DrawableContentDescription::clear_is_floating_above_text() {
  is_floating_above_text_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool DrawableContentDescription::_internal_is_floating_above_text() const {
  return is_floating_above_text_;
}
inline bool DrawableContentDescription::is_floating_above_text() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableContentDescription.is_floating_above_text)
  return _internal_is_floating_above_text();
}
inline void DrawableContentDescription::_internal_set_is_floating_above_text(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_floating_above_text_ = value;
}
inline void DrawableContentDescription::set_is_floating_above_text(bool value) {
  _internal_set_is_floating_above_text(value);
  // @@protoc_insertion_point(field_set:TSD.DrawableContentDescription.is_floating_above_text)
}

// optional bool is_inline_with_text = 4;
inline bool DrawableContentDescription::_internal_has_is_inline_with_text() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DrawableContentDescription::has_is_inline_with_text() const {
  return _internal_has_is_inline_with_text();
}
inline void DrawableContentDescription::clear_is_inline_with_text() {
  is_inline_with_text_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool DrawableContentDescription::_internal_is_inline_with_text() const {
  return is_inline_with_text_;
}
inline bool DrawableContentDescription::is_inline_with_text() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableContentDescription.is_inline_with_text)
  return _internal_is_inline_with_text();
}
inline void DrawableContentDescription::_internal_set_is_inline_with_text(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_inline_with_text_ = value;
}
inline void DrawableContentDescription::set_is_inline_with_text(bool value) {
  _internal_set_is_inline_with_text(value);
  // @@protoc_insertion_point(field_set:TSD.DrawableContentDescription.is_inline_with_text)
}

// -------------------------------------------------------------------

// FreehandDrawingContentDescription

// required .TSD.DrawableContentDescription super = 1;
inline bool FreehandDrawingContentDescription::_internal_has_super() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || super_ != nullptr);
  return value;
}
inline bool FreehandDrawingContentDescription::has_super() const {
  return _internal_has_super();
}
inline void FreehandDrawingContentDescription::clear_super() {
  if (super_ != nullptr) super_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::DrawableContentDescription& FreehandDrawingContentDescription::_internal_super() const {
  const ::TSD::DrawableContentDescription* p = super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DrawableContentDescription&>(
      ::TSD::_DrawableContentDescription_default_instance_);
}
inline const ::TSD::DrawableContentDescription& FreehandDrawingContentDescription::super() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingContentDescription.super)
  return _internal_super();
}
inline void FreehandDrawingContentDescription::unsafe_arena_set_allocated_super(
    ::TSD::DrawableContentDescription* super) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  super_ = super;
  if (super) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.FreehandDrawingContentDescription.super)
}
inline ::TSD::DrawableContentDescription* FreehandDrawingContentDescription::release_super() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableContentDescription* temp = super_;
  super_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::DrawableContentDescription* FreehandDrawingContentDescription::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.FreehandDrawingContentDescription.super)
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableContentDescription* temp = super_;
  super_ = nullptr;
  return temp;
}
inline ::TSD::DrawableContentDescription* FreehandDrawingContentDescription::_internal_mutable_super() {
  _has_bits_[0] |= 0x00000001u;
  if (super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DrawableContentDescription>(GetArena());
    super_ = p;
  }
  return super_;
}
inline ::TSD::DrawableContentDescription* FreehandDrawingContentDescription::mutable_super() {
  // @@protoc_insertion_point(field_mutable:TSD.FreehandDrawingContentDescription.super)
  return _internal_mutable_super();
}
inline void FreehandDrawingContentDescription::set_allocated_super(::TSD::DrawableContentDescription* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.FreehandDrawingContentDescription.super)
}

// optional bool source_doc_wanted_spacer_shape = 2;
inline bool FreehandDrawingContentDescription::_internal_has_source_doc_wanted_spacer_shape() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FreehandDrawingContentDescription::has_source_doc_wanted_spacer_shape() const {
  return _internal_has_source_doc_wanted_spacer_shape();
}
inline void FreehandDrawingContentDescription::clear_source_doc_wanted_spacer_shape() {
  source_doc_wanted_spacer_shape_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool FreehandDrawingContentDescription::_internal_source_doc_wanted_spacer_shape() const {
  return source_doc_wanted_spacer_shape_;
}
inline bool FreehandDrawingContentDescription::source_doc_wanted_spacer_shape() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingContentDescription.source_doc_wanted_spacer_shape)
  return _internal_source_doc_wanted_spacer_shape();
}
inline void FreehandDrawingContentDescription::_internal_set_source_doc_wanted_spacer_shape(bool value) {
  _has_bits_[0] |= 0x00000002u;
  source_doc_wanted_spacer_shape_ = value;
}
inline void FreehandDrawingContentDescription::set_source_doc_wanted_spacer_shape(bool value) {
  _internal_set_source_doc_wanted_spacer_shape(value);
  // @@protoc_insertion_point(field_set:TSD.FreehandDrawingContentDescription.source_doc_wanted_spacer_shape)
}

// -------------------------------------------------------------------

// FreehandDrawingToolkitUIState

// optional .TSP.Color current_color = 1 [deprecated = true];
inline bool FreehandDrawingToolkitUIState::_internal_has_current_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || current_color_ != nullptr);
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_current_color() const {
  return _internal_has_current_color();
}
inline const ::TSP::Color& FreehandDrawingToolkitUIState::_internal_current_color() const {
  const ::TSP::Color* p = current_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& FreehandDrawingToolkitUIState::current_color() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.current_color)
  return _internal_current_color();
}
inline void FreehandDrawingToolkitUIState::unsafe_arena_set_allocated_current_color(
    ::TSP::Color* current_color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(current_color_);
  }
  current_color_ = current_color;
  if (current_color) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.FreehandDrawingToolkitUIState.current_color)
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::release_current_color() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = current_color_;
  current_color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::unsafe_arena_release_current_color() {
  // @@protoc_insertion_point(field_release:TSD.FreehandDrawingToolkitUIState.current_color)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = current_color_;
  current_color_ = nullptr;
  return temp;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::_internal_mutable_current_color() {
  _has_bits_[0] |= 0x00000001u;
  if (current_color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    current_color_ = p;
  }
  return current_color_;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::mutable_current_color() {
  // @@protoc_insertion_point(field_mutable:TSD.FreehandDrawingToolkitUIState.current_color)
  return _internal_mutable_current_color();
}
inline void FreehandDrawingToolkitUIState::set_allocated_current_color(::TSP::Color* current_color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(current_color_);
  }
  if (current_color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(current_color)->GetArena();
    if (message_arena != submessage_arena) {
      current_color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current_color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  current_color_ = current_color;
  // @@protoc_insertion_point(field_set_allocated:TSD.FreehandDrawingToolkitUIState.current_color)
}

// optional .TSD.FreehandDrawingToolkitUIState.FreehandDrawingToolType most_recent_restorable_tool_type = 2 [default = Pen];
inline bool FreehandDrawingToolkitUIState::_internal_has_most_recent_restorable_tool_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_most_recent_restorable_tool_type() const {
  return _internal_has_most_recent_restorable_tool_type();
}
inline void FreehandDrawingToolkitUIState::clear_most_recent_restorable_tool_type() {
  most_recent_restorable_tool_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType FreehandDrawingToolkitUIState::_internal_most_recent_restorable_tool_type() const {
  return static_cast< ::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType >(most_recent_restorable_tool_type_);
}
inline ::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType FreehandDrawingToolkitUIState::most_recent_restorable_tool_type() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.most_recent_restorable_tool_type)
  return _internal_most_recent_restorable_tool_type();
}
inline void FreehandDrawingToolkitUIState::_internal_set_most_recent_restorable_tool_type(::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType value) {
  assert(::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  most_recent_restorable_tool_type_ = value;
}
inline void FreehandDrawingToolkitUIState::set_most_recent_restorable_tool_type(::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType value) {
  _internal_set_most_recent_restorable_tool_type(value);
  // @@protoc_insertion_point(field_set:TSD.FreehandDrawingToolkitUIState.most_recent_restorable_tool_type)
}

// optional float pen_tool_opacity = 3;
inline bool FreehandDrawingToolkitUIState::_internal_has_pen_tool_opacity() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_pen_tool_opacity() const {
  return _internal_has_pen_tool_opacity();
}
inline void FreehandDrawingToolkitUIState::clear_pen_tool_opacity() {
  pen_tool_opacity_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float FreehandDrawingToolkitUIState::_internal_pen_tool_opacity() const {
  return pen_tool_opacity_;
}
inline float FreehandDrawingToolkitUIState::pen_tool_opacity() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.pen_tool_opacity)
  return _internal_pen_tool_opacity();
}
inline void FreehandDrawingToolkitUIState::_internal_set_pen_tool_opacity(float value) {
  _has_bits_[0] |= 0x00000040u;
  pen_tool_opacity_ = value;
}
inline void FreehandDrawingToolkitUIState::set_pen_tool_opacity(float value) {
  _internal_set_pen_tool_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.FreehandDrawingToolkitUIState.pen_tool_opacity)
}

// optional float pen_tool_unscaled_width = 4;
inline bool FreehandDrawingToolkitUIState::_internal_has_pen_tool_unscaled_width() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_pen_tool_unscaled_width() const {
  return _internal_has_pen_tool_unscaled_width();
}
inline void FreehandDrawingToolkitUIState::clear_pen_tool_unscaled_width() {
  pen_tool_unscaled_width_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float FreehandDrawingToolkitUIState::_internal_pen_tool_unscaled_width() const {
  return pen_tool_unscaled_width_;
}
inline float FreehandDrawingToolkitUIState::pen_tool_unscaled_width() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.pen_tool_unscaled_width)
  return _internal_pen_tool_unscaled_width();
}
inline void FreehandDrawingToolkitUIState::_internal_set_pen_tool_unscaled_width(float value) {
  _has_bits_[0] |= 0x00000080u;
  pen_tool_unscaled_width_ = value;
}
inline void FreehandDrawingToolkitUIState::set_pen_tool_unscaled_width(float value) {
  _internal_set_pen_tool_unscaled_width(value);
  // @@protoc_insertion_point(field_set:TSD.FreehandDrawingToolkitUIState.pen_tool_unscaled_width)
}

// optional float pencil_tool_opacity = 5;
inline bool FreehandDrawingToolkitUIState::_internal_has_pencil_tool_opacity() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_pencil_tool_opacity() const {
  return _internal_has_pencil_tool_opacity();
}
inline void FreehandDrawingToolkitUIState::clear_pencil_tool_opacity() {
  pencil_tool_opacity_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float FreehandDrawingToolkitUIState::_internal_pencil_tool_opacity() const {
  return pencil_tool_opacity_;
}
inline float FreehandDrawingToolkitUIState::pencil_tool_opacity() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.pencil_tool_opacity)
  return _internal_pencil_tool_opacity();
}
inline void FreehandDrawingToolkitUIState::_internal_set_pencil_tool_opacity(float value) {
  _has_bits_[0] |= 0x00000100u;
  pencil_tool_opacity_ = value;
}
inline void FreehandDrawingToolkitUIState::set_pencil_tool_opacity(float value) {
  _internal_set_pencil_tool_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.FreehandDrawingToolkitUIState.pencil_tool_opacity)
}

// optional float pencil_tool_unscaled_width = 6;
inline bool FreehandDrawingToolkitUIState::_internal_has_pencil_tool_unscaled_width() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_pencil_tool_unscaled_width() const {
  return _internal_has_pencil_tool_unscaled_width();
}
inline void FreehandDrawingToolkitUIState::clear_pencil_tool_unscaled_width() {
  pencil_tool_unscaled_width_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float FreehandDrawingToolkitUIState::_internal_pencil_tool_unscaled_width() const {
  return pencil_tool_unscaled_width_;
}
inline float FreehandDrawingToolkitUIState::pencil_tool_unscaled_width() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.pencil_tool_unscaled_width)
  return _internal_pencil_tool_unscaled_width();
}
inline void FreehandDrawingToolkitUIState::_internal_set_pencil_tool_unscaled_width(float value) {
  _has_bits_[0] |= 0x00000200u;
  pencil_tool_unscaled_width_ = value;
}
inline void FreehandDrawingToolkitUIState::set_pencil_tool_unscaled_width(float value) {
  _internal_set_pencil_tool_unscaled_width(value);
  // @@protoc_insertion_point(field_set:TSD.FreehandDrawingToolkitUIState.pencil_tool_unscaled_width)
}

// optional float crayon_tool_opacity = 7;
inline bool FreehandDrawingToolkitUIState::_internal_has_crayon_tool_opacity() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_crayon_tool_opacity() const {
  return _internal_has_crayon_tool_opacity();
}
inline void FreehandDrawingToolkitUIState::clear_crayon_tool_opacity() {
  crayon_tool_opacity_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float FreehandDrawingToolkitUIState::_internal_crayon_tool_opacity() const {
  return crayon_tool_opacity_;
}
inline float FreehandDrawingToolkitUIState::crayon_tool_opacity() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.crayon_tool_opacity)
  return _internal_crayon_tool_opacity();
}
inline void FreehandDrawingToolkitUIState::_internal_set_crayon_tool_opacity(float value) {
  _has_bits_[0] |= 0x00000400u;
  crayon_tool_opacity_ = value;
}
inline void FreehandDrawingToolkitUIState::set_crayon_tool_opacity(float value) {
  _internal_set_crayon_tool_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.FreehandDrawingToolkitUIState.crayon_tool_opacity)
}

// optional float crayon_tool_unscaled_width = 8;
inline bool FreehandDrawingToolkitUIState::_internal_has_crayon_tool_unscaled_width() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_crayon_tool_unscaled_width() const {
  return _internal_has_crayon_tool_unscaled_width();
}
inline void FreehandDrawingToolkitUIState::clear_crayon_tool_unscaled_width() {
  crayon_tool_unscaled_width_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline float FreehandDrawingToolkitUIState::_internal_crayon_tool_unscaled_width() const {
  return crayon_tool_unscaled_width_;
}
inline float FreehandDrawingToolkitUIState::crayon_tool_unscaled_width() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.crayon_tool_unscaled_width)
  return _internal_crayon_tool_unscaled_width();
}
inline void FreehandDrawingToolkitUIState::_internal_set_crayon_tool_unscaled_width(float value) {
  _has_bits_[0] |= 0x00000800u;
  crayon_tool_unscaled_width_ = value;
}
inline void FreehandDrawingToolkitUIState::set_crayon_tool_unscaled_width(float value) {
  _internal_set_crayon_tool_unscaled_width(value);
  // @@protoc_insertion_point(field_set:TSD.FreehandDrawingToolkitUIState.crayon_tool_unscaled_width)
}

// optional float fill_tool_opacity = 9;
inline bool FreehandDrawingToolkitUIState::_internal_has_fill_tool_opacity() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_fill_tool_opacity() const {
  return _internal_has_fill_tool_opacity();
}
inline void FreehandDrawingToolkitUIState::clear_fill_tool_opacity() {
  fill_tool_opacity_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline float FreehandDrawingToolkitUIState::_internal_fill_tool_opacity() const {
  return fill_tool_opacity_;
}
inline float FreehandDrawingToolkitUIState::fill_tool_opacity() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.fill_tool_opacity)
  return _internal_fill_tool_opacity();
}
inline void FreehandDrawingToolkitUIState::_internal_set_fill_tool_opacity(float value) {
  _has_bits_[0] |= 0x00001000u;
  fill_tool_opacity_ = value;
}
inline void FreehandDrawingToolkitUIState::set_fill_tool_opacity(float value) {
  _internal_set_fill_tool_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.FreehandDrawingToolkitUIState.fill_tool_opacity)
}

// optional float eraser_tool_scaled_width = 10;
inline bool FreehandDrawingToolkitUIState::_internal_has_eraser_tool_scaled_width() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_eraser_tool_scaled_width() const {
  return _internal_has_eraser_tool_scaled_width();
}
inline void FreehandDrawingToolkitUIState::clear_eraser_tool_scaled_width() {
  eraser_tool_scaled_width_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline float FreehandDrawingToolkitUIState::_internal_eraser_tool_scaled_width() const {
  return eraser_tool_scaled_width_;
}
inline float FreehandDrawingToolkitUIState::eraser_tool_scaled_width() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.eraser_tool_scaled_width)
  return _internal_eraser_tool_scaled_width();
}
inline void FreehandDrawingToolkitUIState::_internal_set_eraser_tool_scaled_width(float value) {
  _has_bits_[0] |= 0x00002000u;
  eraser_tool_scaled_width_ = value;
}
inline void FreehandDrawingToolkitUIState::set_eraser_tool_scaled_width(float value) {
  _internal_set_eraser_tool_scaled_width(value);
  // @@protoc_insertion_point(field_set:TSD.FreehandDrawingToolkitUIState.eraser_tool_scaled_width)
}

// optional bool eraser_tool_erases_whole_objects = 11;
inline bool FreehandDrawingToolkitUIState::_internal_has_eraser_tool_erases_whole_objects() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_eraser_tool_erases_whole_objects() const {
  return _internal_has_eraser_tool_erases_whole_objects();
}
inline void FreehandDrawingToolkitUIState::clear_eraser_tool_erases_whole_objects() {
  eraser_tool_erases_whole_objects_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool FreehandDrawingToolkitUIState::_internal_eraser_tool_erases_whole_objects() const {
  return eraser_tool_erases_whole_objects_;
}
inline bool FreehandDrawingToolkitUIState::eraser_tool_erases_whole_objects() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.eraser_tool_erases_whole_objects)
  return _internal_eraser_tool_erases_whole_objects();
}
inline void FreehandDrawingToolkitUIState::_internal_set_eraser_tool_erases_whole_objects(bool value) {
  _has_bits_[0] |= 0x00004000u;
  eraser_tool_erases_whole_objects_ = value;
}
inline void FreehandDrawingToolkitUIState::set_eraser_tool_erases_whole_objects(bool value) {
  _internal_set_eraser_tool_erases_whole_objects(value);
  // @@protoc_insertion_point(field_set:TSD.FreehandDrawingToolkitUIState.eraser_tool_erases_whole_objects)
}

// optional .TSP.Color pen_tool_color = 12;
inline bool FreehandDrawingToolkitUIState::_internal_has_pen_tool_color() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || pen_tool_color_ != nullptr);
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_pen_tool_color() const {
  return _internal_has_pen_tool_color();
}
inline const ::TSP::Color& FreehandDrawingToolkitUIState::_internal_pen_tool_color() const {
  const ::TSP::Color* p = pen_tool_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& FreehandDrawingToolkitUIState::pen_tool_color() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.pen_tool_color)
  return _internal_pen_tool_color();
}
inline void FreehandDrawingToolkitUIState::unsafe_arena_set_allocated_pen_tool_color(
    ::TSP::Color* pen_tool_color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pen_tool_color_);
  }
  pen_tool_color_ = pen_tool_color;
  if (pen_tool_color) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.FreehandDrawingToolkitUIState.pen_tool_color)
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::release_pen_tool_color() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Color* temp = pen_tool_color_;
  pen_tool_color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::unsafe_arena_release_pen_tool_color() {
  // @@protoc_insertion_point(field_release:TSD.FreehandDrawingToolkitUIState.pen_tool_color)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Color* temp = pen_tool_color_;
  pen_tool_color_ = nullptr;
  return temp;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::_internal_mutable_pen_tool_color() {
  _has_bits_[0] |= 0x00000002u;
  if (pen_tool_color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    pen_tool_color_ = p;
  }
  return pen_tool_color_;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::mutable_pen_tool_color() {
  // @@protoc_insertion_point(field_mutable:TSD.FreehandDrawingToolkitUIState.pen_tool_color)
  return _internal_mutable_pen_tool_color();
}
inline void FreehandDrawingToolkitUIState::set_allocated_pen_tool_color(::TSP::Color* pen_tool_color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pen_tool_color_);
  }
  if (pen_tool_color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pen_tool_color)->GetArena();
    if (message_arena != submessage_arena) {
      pen_tool_color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pen_tool_color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pen_tool_color_ = pen_tool_color;
  // @@protoc_insertion_point(field_set_allocated:TSD.FreehandDrawingToolkitUIState.pen_tool_color)
}

// optional .TSP.Color pencil_tool_color = 13;
inline bool FreehandDrawingToolkitUIState::_internal_has_pencil_tool_color() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || pencil_tool_color_ != nullptr);
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_pencil_tool_color() const {
  return _internal_has_pencil_tool_color();
}
inline const ::TSP::Color& FreehandDrawingToolkitUIState::_internal_pencil_tool_color() const {
  const ::TSP::Color* p = pencil_tool_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& FreehandDrawingToolkitUIState::pencil_tool_color() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.pencil_tool_color)
  return _internal_pencil_tool_color();
}
inline void FreehandDrawingToolkitUIState::unsafe_arena_set_allocated_pencil_tool_color(
    ::TSP::Color* pencil_tool_color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pencil_tool_color_);
  }
  pencil_tool_color_ = pencil_tool_color;
  if (pencil_tool_color) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.FreehandDrawingToolkitUIState.pencil_tool_color)
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::release_pencil_tool_color() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Color* temp = pencil_tool_color_;
  pencil_tool_color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::unsafe_arena_release_pencil_tool_color() {
  // @@protoc_insertion_point(field_release:TSD.FreehandDrawingToolkitUIState.pencil_tool_color)
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Color* temp = pencil_tool_color_;
  pencil_tool_color_ = nullptr;
  return temp;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::_internal_mutable_pencil_tool_color() {
  _has_bits_[0] |= 0x00000004u;
  if (pencil_tool_color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    pencil_tool_color_ = p;
  }
  return pencil_tool_color_;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::mutable_pencil_tool_color() {
  // @@protoc_insertion_point(field_mutable:TSD.FreehandDrawingToolkitUIState.pencil_tool_color)
  return _internal_mutable_pencil_tool_color();
}
inline void FreehandDrawingToolkitUIState::set_allocated_pencil_tool_color(::TSP::Color* pencil_tool_color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pencil_tool_color_);
  }
  if (pencil_tool_color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pencil_tool_color)->GetArena();
    if (message_arena != submessage_arena) {
      pencil_tool_color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pencil_tool_color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  pencil_tool_color_ = pencil_tool_color;
  // @@protoc_insertion_point(field_set_allocated:TSD.FreehandDrawingToolkitUIState.pencil_tool_color)
}

// optional .TSP.Color crayon_tool_color = 14;
inline bool FreehandDrawingToolkitUIState::_internal_has_crayon_tool_color() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || crayon_tool_color_ != nullptr);
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_crayon_tool_color() const {
  return _internal_has_crayon_tool_color();
}
inline const ::TSP::Color& FreehandDrawingToolkitUIState::_internal_crayon_tool_color() const {
  const ::TSP::Color* p = crayon_tool_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& FreehandDrawingToolkitUIState::crayon_tool_color() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.crayon_tool_color)
  return _internal_crayon_tool_color();
}
inline void FreehandDrawingToolkitUIState::unsafe_arena_set_allocated_crayon_tool_color(
    ::TSP::Color* crayon_tool_color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(crayon_tool_color_);
  }
  crayon_tool_color_ = crayon_tool_color;
  if (crayon_tool_color) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.FreehandDrawingToolkitUIState.crayon_tool_color)
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::release_crayon_tool_color() {
  _has_bits_[0] &= ~0x00000008u;
  ::TSP::Color* temp = crayon_tool_color_;
  crayon_tool_color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::unsafe_arena_release_crayon_tool_color() {
  // @@protoc_insertion_point(field_release:TSD.FreehandDrawingToolkitUIState.crayon_tool_color)
  _has_bits_[0] &= ~0x00000008u;
  ::TSP::Color* temp = crayon_tool_color_;
  crayon_tool_color_ = nullptr;
  return temp;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::_internal_mutable_crayon_tool_color() {
  _has_bits_[0] |= 0x00000008u;
  if (crayon_tool_color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    crayon_tool_color_ = p;
  }
  return crayon_tool_color_;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::mutable_crayon_tool_color() {
  // @@protoc_insertion_point(field_mutable:TSD.FreehandDrawingToolkitUIState.crayon_tool_color)
  return _internal_mutable_crayon_tool_color();
}
inline void FreehandDrawingToolkitUIState::set_allocated_crayon_tool_color(::TSP::Color* crayon_tool_color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(crayon_tool_color_);
  }
  if (crayon_tool_color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(crayon_tool_color)->GetArena();
    if (message_arena != submessage_arena) {
      crayon_tool_color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, crayon_tool_color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  crayon_tool_color_ = crayon_tool_color;
  // @@protoc_insertion_point(field_set_allocated:TSD.FreehandDrawingToolkitUIState.crayon_tool_color)
}

// optional .TSP.Color fill_tool_color = 15;
inline bool FreehandDrawingToolkitUIState::_internal_has_fill_tool_color() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || fill_tool_color_ != nullptr);
  return value;
}
inline bool FreehandDrawingToolkitUIState::has_fill_tool_color() const {
  return _internal_has_fill_tool_color();
}
inline const ::TSP::Color& FreehandDrawingToolkitUIState::_internal_fill_tool_color() const {
  const ::TSP::Color* p = fill_tool_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& FreehandDrawingToolkitUIState::fill_tool_color() const {
  // @@protoc_insertion_point(field_get:TSD.FreehandDrawingToolkitUIState.fill_tool_color)
  return _internal_fill_tool_color();
}
inline void FreehandDrawingToolkitUIState::unsafe_arena_set_allocated_fill_tool_color(
    ::TSP::Color* fill_tool_color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fill_tool_color_);
  }
  fill_tool_color_ = fill_tool_color;
  if (fill_tool_color) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.FreehandDrawingToolkitUIState.fill_tool_color)
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::release_fill_tool_color() {
  _has_bits_[0] &= ~0x00000010u;
  ::TSP::Color* temp = fill_tool_color_;
  fill_tool_color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::unsafe_arena_release_fill_tool_color() {
  // @@protoc_insertion_point(field_release:TSD.FreehandDrawingToolkitUIState.fill_tool_color)
  _has_bits_[0] &= ~0x00000010u;
  ::TSP::Color* temp = fill_tool_color_;
  fill_tool_color_ = nullptr;
  return temp;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::_internal_mutable_fill_tool_color() {
  _has_bits_[0] |= 0x00000010u;
  if (fill_tool_color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    fill_tool_color_ = p;
  }
  return fill_tool_color_;
}
inline ::TSP::Color* FreehandDrawingToolkitUIState::mutable_fill_tool_color() {
  // @@protoc_insertion_point(field_mutable:TSD.FreehandDrawingToolkitUIState.fill_tool_color)
  return _internal_mutable_fill_tool_color();
}
inline void FreehandDrawingToolkitUIState::set_allocated_fill_tool_color(::TSP::Color* fill_tool_color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fill_tool_color_);
  }
  if (fill_tool_color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fill_tool_color)->GetArena();
    if (message_arena != submessage_arena) {
      fill_tool_color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fill_tool_color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  fill_tool_color_ = fill_tool_color;
  // @@protoc_insertion_point(field_set_allocated:TSD.FreehandDrawingToolkitUIState.fill_tool_color)
}

// -------------------------------------------------------------------

// StandinCaptionArchive

// -------------------------------------------------------------------

// GuideArchive

// optional .TSD.GuideArchive.GuideType type = 1;
inline bool GuideArchive::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GuideArchive::has_type() const {
  return _internal_has_type();
}
inline void GuideArchive::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::TSD::GuideArchive_GuideType GuideArchive::_internal_type() const {
  return static_cast< ::TSD::GuideArchive_GuideType >(type_);
}
inline ::TSD::GuideArchive_GuideType GuideArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.GuideArchive.type)
  return _internal_type();
}
inline void GuideArchive::_internal_set_type(::TSD::GuideArchive_GuideType value) {
  assert(::TSD::GuideArchive_GuideType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void GuideArchive::set_type(::TSD::GuideArchive_GuideType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.GuideArchive.type)
}

// optional float offset = 2;
inline bool GuideArchive::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GuideArchive::has_offset() const {
  return _internal_has_offset();
}
inline void GuideArchive::clear_offset() {
  offset_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float GuideArchive::_internal_offset() const {
  return offset_;
}
inline float GuideArchive::offset() const {
  // @@protoc_insertion_point(field_get:TSD.GuideArchive.offset)
  return _internal_offset();
}
inline void GuideArchive::_internal_set_offset(float value) {
  _has_bits_[0] |= 0x00000002u;
  offset_ = value;
}
inline void GuideArchive::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:TSD.GuideArchive.offset)
}

// optional float start = 3;
inline bool GuideArchive::_internal_has_start() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GuideArchive::has_start() const {
  return _internal_has_start();
}
inline void GuideArchive::clear_start() {
  start_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float GuideArchive::_internal_start() const {
  return start_;
}
inline float GuideArchive::start() const {
  // @@protoc_insertion_point(field_get:TSD.GuideArchive.start)
  return _internal_start();
}
inline void GuideArchive::_internal_set_start(float value) {
  _has_bits_[0] |= 0x00000004u;
  start_ = value;
}
inline void GuideArchive::set_start(float value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:TSD.GuideArchive.start)
}

// optional float end = 4;
inline bool GuideArchive::_internal_has_end() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GuideArchive::has_end() const {
  return _internal_has_end();
}
inline void GuideArchive::clear_end() {
  end_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float GuideArchive::_internal_end() const {
  return end_;
}
inline float GuideArchive::end() const {
  // @@protoc_insertion_point(field_get:TSD.GuideArchive.end)
  return _internal_end();
}
inline void GuideArchive::_internal_set_end(float value) {
  _has_bits_[0] |= 0x00000008u;
  end_ = value;
}
inline void GuideArchive::set_end(float value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:TSD.GuideArchive.end)
}

// optional bool dynamic = 5;
inline bool GuideArchive::_internal_has_dynamic() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GuideArchive::has_dynamic() const {
  return _internal_has_dynamic();
}
inline void GuideArchive::clear_dynamic() {
  dynamic_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool GuideArchive::_internal_dynamic() const {
  return dynamic_;
}
inline bool GuideArchive::dynamic() const {
  // @@protoc_insertion_point(field_get:TSD.GuideArchive.dynamic)
  return _internal_dynamic();
}
inline void GuideArchive::_internal_set_dynamic(bool value) {
  _has_bits_[0] |= 0x00000010u;
  dynamic_ = value;
}
inline void GuideArchive::set_dynamic(bool value) {
  _internal_set_dynamic(value);
  // @@protoc_insertion_point(field_set:TSD.GuideArchive.dynamic)
}

// optional bool infinite = 6;
inline bool GuideArchive::_internal_has_infinite() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GuideArchive::has_infinite() const {
  return _internal_has_infinite();
}
inline void GuideArchive::clear_infinite() {
  infinite_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool GuideArchive::_internal_infinite() const {
  return infinite_;
}
inline bool GuideArchive::infinite() const {
  // @@protoc_insertion_point(field_get:TSD.GuideArchive.infinite)
  return _internal_infinite();
}
inline void GuideArchive::_internal_set_infinite(bool value) {
  _has_bits_[0] |= 0x00000020u;
  infinite_ = value;
}
inline void GuideArchive::set_infinite(bool value) {
  _internal_set_infinite(value);
  // @@protoc_insertion_point(field_set:TSD.GuideArchive.infinite)
}

// -------------------------------------------------------------------

// UserDefinedGuideArchive

// optional .TSD.UserDefinedGuideArchive.GuideType type = 1;
inline bool UserDefinedGuideArchive::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserDefinedGuideArchive::has_type() const {
  return _internal_has_type();
}
inline void UserDefinedGuideArchive::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::TSD::UserDefinedGuideArchive_GuideType UserDefinedGuideArchive::_internal_type() const {
  return static_cast< ::TSD::UserDefinedGuideArchive_GuideType >(type_);
}
inline ::TSD::UserDefinedGuideArchive_GuideType UserDefinedGuideArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.UserDefinedGuideArchive.type)
  return _internal_type();
}
inline void UserDefinedGuideArchive::_internal_set_type(::TSD::UserDefinedGuideArchive_GuideType value) {
  assert(::TSD::UserDefinedGuideArchive_GuideType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void UserDefinedGuideArchive::set_type(::TSD::UserDefinedGuideArchive_GuideType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.UserDefinedGuideArchive.type)
}

// optional float position = 2;
inline bool UserDefinedGuideArchive::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserDefinedGuideArchive::has_position() const {
  return _internal_has_position();
}
inline void UserDefinedGuideArchive::clear_position() {
  position_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float UserDefinedGuideArchive::_internal_position() const {
  return position_;
}
inline float UserDefinedGuideArchive::position() const {
  // @@protoc_insertion_point(field_get:TSD.UserDefinedGuideArchive.position)
  return _internal_position();
}
inline void UserDefinedGuideArchive::_internal_set_position(float value) {
  _has_bits_[0] |= 0x00000002u;
  position_ = value;
}
inline void UserDefinedGuideArchive::set_position(float value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:TSD.UserDefinedGuideArchive.position)
}

// -------------------------------------------------------------------

// GuideStorageArchive

// repeated .TSD.UserDefinedGuideArchive userDefinedGuides = 1;
inline int GuideStorageArchive::_internal_userdefinedguides_size() const {
  return userdefinedguides_.size();
}
inline int GuideStorageArchive::userdefinedguides_size() const {
  return _internal_userdefinedguides_size();
}
inline void GuideStorageArchive::clear_userdefinedguides() {
  userdefinedguides_.Clear();
}
inline ::TSD::UserDefinedGuideArchive* GuideStorageArchive::mutable_userdefinedguides(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.GuideStorageArchive.userDefinedGuides)
  return userdefinedguides_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::UserDefinedGuideArchive >*
GuideStorageArchive::mutable_userdefinedguides() {
  // @@protoc_insertion_point(field_mutable_list:TSD.GuideStorageArchive.userDefinedGuides)
  return &userdefinedguides_;
}
inline const ::TSD::UserDefinedGuideArchive& GuideStorageArchive::_internal_userdefinedguides(int index) const {
  return userdefinedguides_.Get(index);
}
inline const ::TSD::UserDefinedGuideArchive& GuideStorageArchive::userdefinedguides(int index) const {
  // @@protoc_insertion_point(field_get:TSD.GuideStorageArchive.userDefinedGuides)
  return _internal_userdefinedguides(index);
}
inline ::TSD::UserDefinedGuideArchive* GuideStorageArchive::_internal_add_userdefinedguides() {
  return userdefinedguides_.Add();
}
inline ::TSD::UserDefinedGuideArchive* GuideStorageArchive::add_userdefinedguides() {
  // @@protoc_insertion_point(field_add:TSD.GuideStorageArchive.userDefinedGuides)
  return _internal_add_userdefinedguides();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::UserDefinedGuideArchive >&
GuideStorageArchive::userdefinedguides() const {
  // @@protoc_insertion_point(field_list:TSD.GuideStorageArchive.userDefinedGuides)
  return userdefinedguides_;
}

// -------------------------------------------------------------------

// CanvasSelectionArchive

// repeated .TSP.Reference infos = 1;
inline int CanvasSelectionArchive::_internal_infos_size() const {
  return infos_.size();
}
inline int CanvasSelectionArchive::infos_size() const {
  return _internal_infos_size();
}
inline ::TSP::Reference* CanvasSelectionArchive::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.CanvasSelectionArchive.infos)
  return infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
CanvasSelectionArchive::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:TSD.CanvasSelectionArchive.infos)
  return &infos_;
}
inline const ::TSP::Reference& CanvasSelectionArchive::_internal_infos(int index) const {
  return infos_.Get(index);
}
inline const ::TSP::Reference& CanvasSelectionArchive::infos(int index) const {
  // @@protoc_insertion_point(field_get:TSD.CanvasSelectionArchive.infos)
  return _internal_infos(index);
}
inline ::TSP::Reference* CanvasSelectionArchive::_internal_add_infos() {
  return infos_.Add();
}
inline ::TSP::Reference* CanvasSelectionArchive::add_infos() {
  // @@protoc_insertion_point(field_add:TSD.CanvasSelectionArchive.infos)
  return _internal_add_infos();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
CanvasSelectionArchive::infos() const {
  // @@protoc_insertion_point(field_list:TSD.CanvasSelectionArchive.infos)
  return infos_;
}

// repeated .TSP.Reference non_interactive_infos = 3;
inline int CanvasSelectionArchive::_internal_non_interactive_infos_size() const {
  return non_interactive_infos_.size();
}
inline int CanvasSelectionArchive::non_interactive_infos_size() const {
  return _internal_non_interactive_infos_size();
}
inline ::TSP::Reference* CanvasSelectionArchive::mutable_non_interactive_infos(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.CanvasSelectionArchive.non_interactive_infos)
  return non_interactive_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
CanvasSelectionArchive::mutable_non_interactive_infos() {
  // @@protoc_insertion_point(field_mutable_list:TSD.CanvasSelectionArchive.non_interactive_infos)
  return &non_interactive_infos_;
}
inline const ::TSP::Reference& CanvasSelectionArchive::_internal_non_interactive_infos(int index) const {
  return non_interactive_infos_.Get(index);
}
inline const ::TSP::Reference& CanvasSelectionArchive::non_interactive_infos(int index) const {
  // @@protoc_insertion_point(field_get:TSD.CanvasSelectionArchive.non_interactive_infos)
  return _internal_non_interactive_infos(index);
}
inline ::TSP::Reference* CanvasSelectionArchive::_internal_add_non_interactive_infos() {
  return non_interactive_infos_.Add();
}
inline ::TSP::Reference* CanvasSelectionArchive::add_non_interactive_infos() {
  // @@protoc_insertion_point(field_add:TSD.CanvasSelectionArchive.non_interactive_infos)
  return _internal_add_non_interactive_infos();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
CanvasSelectionArchive::non_interactive_infos() const {
  // @@protoc_insertion_point(field_list:TSD.CanvasSelectionArchive.non_interactive_infos)
  return non_interactive_infos_;
}

// optional .TSP.Reference container = 2 [deprecated = true];
inline bool CanvasSelectionArchive::_internal_has_container() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || container_ != nullptr);
  return value;
}
inline bool CanvasSelectionArchive::has_container() const {
  return _internal_has_container();
}
inline const ::TSP::Reference& CanvasSelectionArchive::_internal_container() const {
  const ::TSP::Reference* p = container_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& CanvasSelectionArchive::container() const {
  // @@protoc_insertion_point(field_get:TSD.CanvasSelectionArchive.container)
  return _internal_container();
}
inline void CanvasSelectionArchive::unsafe_arena_set_allocated_container(
    ::TSP::Reference* container) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(container_);
  }
  container_ = container;
  if (container) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.CanvasSelectionArchive.container)
}
inline ::TSP::Reference* CanvasSelectionArchive::release_container() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = container_;
  container_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* CanvasSelectionArchive::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_release:TSD.CanvasSelectionArchive.container)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = container_;
  container_ = nullptr;
  return temp;
}
inline ::TSP::Reference* CanvasSelectionArchive::_internal_mutable_container() {
  _has_bits_[0] |= 0x00000001u;
  if (container_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    container_ = p;
  }
  return container_;
}
inline ::TSP::Reference* CanvasSelectionArchive::mutable_container() {
  // @@protoc_insertion_point(field_mutable:TSD.CanvasSelectionArchive.container)
  return _internal_mutable_container();
}
inline void CanvasSelectionArchive::set_allocated_container(::TSP::Reference* container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(container_);
  }
  if (container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(container)->GetArena();
    if (message_arena != submessage_arena) {
      container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:TSD.CanvasSelectionArchive.container)
}

// -------------------------------------------------------------------

// DrawableSelectionArchive

// repeated .TSP.Reference infos = 2;
inline int DrawableSelectionArchive::_internal_infos_size() const {
  return infos_.size();
}
inline int DrawableSelectionArchive::infos_size() const {
  return _internal_infos_size();
}
inline ::TSP::Reference* DrawableSelectionArchive::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.DrawableSelectionArchive.infos)
  return infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
DrawableSelectionArchive::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:TSD.DrawableSelectionArchive.infos)
  return &infos_;
}
inline const ::TSP::Reference& DrawableSelectionArchive::_internal_infos(int index) const {
  return infos_.Get(index);
}
inline const ::TSP::Reference& DrawableSelectionArchive::infos(int index) const {
  // @@protoc_insertion_point(field_get:TSD.DrawableSelectionArchive.infos)
  return _internal_infos(index);
}
inline ::TSP::Reference* DrawableSelectionArchive::_internal_add_infos() {
  return infos_.Add();
}
inline ::TSP::Reference* DrawableSelectionArchive::add_infos() {
  // @@protoc_insertion_point(field_add:TSD.DrawableSelectionArchive.infos)
  return _internal_add_infos();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
DrawableSelectionArchive::infos() const {
  // @@protoc_insertion_point(field_list:TSD.DrawableSelectionArchive.infos)
  return infos_;
}

// repeated .TSP.Reference non_interactive_infos = 3;
inline int DrawableSelectionArchive::_internal_non_interactive_infos_size() const {
  return non_interactive_infos_.size();
}
inline int DrawableSelectionArchive::non_interactive_infos_size() const {
  return _internal_non_interactive_infos_size();
}
inline ::TSP::Reference* DrawableSelectionArchive::mutable_non_interactive_infos(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.DrawableSelectionArchive.non_interactive_infos)
  return non_interactive_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
DrawableSelectionArchive::mutable_non_interactive_infos() {
  // @@protoc_insertion_point(field_mutable_list:TSD.DrawableSelectionArchive.non_interactive_infos)
  return &non_interactive_infos_;
}
inline const ::TSP::Reference& DrawableSelectionArchive::_internal_non_interactive_infos(int index) const {
  return non_interactive_infos_.Get(index);
}
inline const ::TSP::Reference& DrawableSelectionArchive::non_interactive_infos(int index) const {
  // @@protoc_insertion_point(field_get:TSD.DrawableSelectionArchive.non_interactive_infos)
  return _internal_non_interactive_infos(index);
}
inline ::TSP::Reference* DrawableSelectionArchive::_internal_add_non_interactive_infos() {
  return non_interactive_infos_.Add();
}
inline ::TSP::Reference* DrawableSelectionArchive::add_non_interactive_infos() {
  // @@protoc_insertion_point(field_add:TSD.DrawableSelectionArchive.non_interactive_infos)
  return _internal_add_non_interactive_infos();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
DrawableSelectionArchive::non_interactive_infos() const {
  // @@protoc_insertion_point(field_list:TSD.DrawableSelectionArchive.non_interactive_infos)
  return non_interactive_infos_;
}

// -------------------------------------------------------------------

// GroupSelectionArchive

// required .TSD.DrawableSelectionArchive super = 1;
inline bool GroupSelectionArchive::_internal_has_super() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || super_ != nullptr);
  return value;
}
inline bool GroupSelectionArchive::has_super() const {
  return _internal_has_super();
}
inline void GroupSelectionArchive::clear_super() {
  if (super_ != nullptr) super_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::DrawableSelectionArchive& GroupSelectionArchive::_internal_super() const {
  const ::TSD::DrawableSelectionArchive* p = super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DrawableSelectionArchive&>(
      ::TSD::_DrawableSelectionArchive_default_instance_);
}
inline const ::TSD::DrawableSelectionArchive& GroupSelectionArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.GroupSelectionArchive.super)
  return _internal_super();
}
inline void GroupSelectionArchive::unsafe_arena_set_allocated_super(
    ::TSD::DrawableSelectionArchive* super) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  super_ = super;
  if (super) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.GroupSelectionArchive.super)
}
inline ::TSD::DrawableSelectionArchive* GroupSelectionArchive::release_super() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableSelectionArchive* temp = super_;
  super_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::DrawableSelectionArchive* GroupSelectionArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.GroupSelectionArchive.super)
  _has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableSelectionArchive* temp = super_;
  super_ = nullptr;
  return temp;
}
inline ::TSD::DrawableSelectionArchive* GroupSelectionArchive::_internal_mutable_super() {
  _has_bits_[0] |= 0x00000001u;
  if (super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DrawableSelectionArchive>(GetArena());
    super_ = p;
  }
  return super_;
}
inline ::TSD::DrawableSelectionArchive* GroupSelectionArchive::mutable_super() {
  // @@protoc_insertion_point(field_mutable:TSD.GroupSelectionArchive.super)
  return _internal_mutable_super();
}
inline void GroupSelectionArchive::set_allocated_super(::TSD::DrawableSelectionArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.GroupSelectionArchive.super)
}

// optional bool has_selected_infos_in_non_group_container = 2;
inline bool GroupSelectionArchive::_internal_has_has_selected_infos_in_non_group_container() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupSelectionArchive::has_has_selected_infos_in_non_group_container() const {
  return _internal_has_has_selected_infos_in_non_group_container();
}
inline void GroupSelectionArchive::clear_has_selected_infos_in_non_group_container() {
  has_selected_infos_in_non_group_container_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool GroupSelectionArchive::_internal_has_selected_infos_in_non_group_container() const {
  return has_selected_infos_in_non_group_container_;
}
inline bool GroupSelectionArchive::has_selected_infos_in_non_group_container() const {
  // @@protoc_insertion_point(field_get:TSD.GroupSelectionArchive.has_selected_infos_in_non_group_container)
  return _internal_has_selected_infos_in_non_group_container();
}
inline void GroupSelectionArchive::_internal_set_has_selected_infos_in_non_group_container(bool value) {
  _has_bits_[0] |= 0x00000002u;
  has_selected_infos_in_non_group_container_ = value;
}
inline void GroupSelectionArchive::set_has_selected_infos_in_non_group_container(bool value) {
  _internal_set_has_selected_infos_in_non_group_container(value);
  // @@protoc_insertion_point(field_set:TSD.GroupSelectionArchive.has_selected_infos_in_non_group_container)
}

// -------------------------------------------------------------------

// PathSelectionArchive

// -------------------------------------------------------------------

// InfoHyperlinkSelectionArchive

// -------------------------------------------------------------------

// CommentStorageArchive

// optional string text = 1;
inline bool CommentStorageArchive::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommentStorageArchive::has_text() const {
  return _internal_has_text();
}
inline void CommentStorageArchive::clear_text() {
  text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommentStorageArchive::text() const {
  // @@protoc_insertion_point(field_get:TSD.CommentStorageArchive.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void CommentStorageArchive::set_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.CommentStorageArchive.text)
}
inline std::string* CommentStorageArchive::mutable_text() {
  // @@protoc_insertion_point(field_mutable:TSD.CommentStorageArchive.text)
  return _internal_mutable_text();
}
inline const std::string& CommentStorageArchive::_internal_text() const {
  return text_.Get();
}
inline void CommentStorageArchive::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* CommentStorageArchive::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CommentStorageArchive::release_text() {
  // @@protoc_insertion_point(field_release:TSD.CommentStorageArchive.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommentStorageArchive::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.CommentStorageArchive.text)
}

// optional .TSP.Date creation_date = 2;
inline bool CommentStorageArchive::_internal_has_creation_date() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || creation_date_ != nullptr);
  return value;
}
inline bool CommentStorageArchive::has_creation_date() const {
  return _internal_has_creation_date();
}
inline const ::TSP::Date& CommentStorageArchive::_internal_creation_date() const {
  const ::TSP::Date* p = creation_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Date&>(
      ::TSP::_Date_default_instance_);
}
inline const ::TSP::Date& CommentStorageArchive::creation_date() const {
  // @@protoc_insertion_point(field_get:TSD.CommentStorageArchive.creation_date)
  return _internal_creation_date();
}
inline void CommentStorageArchive::unsafe_arena_set_allocated_creation_date(
    ::TSP::Date* creation_date) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(creation_date_);
  }
  creation_date_ = creation_date;
  if (creation_date) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.CommentStorageArchive.creation_date)
}
inline ::TSP::Date* CommentStorageArchive::release_creation_date() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Date* temp = creation_date_;
  creation_date_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Date* CommentStorageArchive::unsafe_arena_release_creation_date() {
  // @@protoc_insertion_point(field_release:TSD.CommentStorageArchive.creation_date)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Date* temp = creation_date_;
  creation_date_ = nullptr;
  return temp;
}
inline ::TSP::Date* CommentStorageArchive::_internal_mutable_creation_date() {
  _has_bits_[0] |= 0x00000002u;
  if (creation_date_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Date>(GetArena());
    creation_date_ = p;
  }
  return creation_date_;
}
inline ::TSP::Date* CommentStorageArchive::mutable_creation_date() {
  // @@protoc_insertion_point(field_mutable:TSD.CommentStorageArchive.creation_date)
  return _internal_mutable_creation_date();
}
inline void CommentStorageArchive::set_allocated_creation_date(::TSP::Date* creation_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(creation_date_);
  }
  if (creation_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(creation_date)->GetArena();
    if (message_arena != submessage_arena) {
      creation_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creation_date, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  creation_date_ = creation_date;
  // @@protoc_insertion_point(field_set_allocated:TSD.CommentStorageArchive.creation_date)
}

// optional .TSP.Reference author = 3;
inline bool CommentStorageArchive::_internal_has_author() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || author_ != nullptr);
  return value;
}
inline bool CommentStorageArchive::has_author() const {
  return _internal_has_author();
}
inline const ::TSP::Reference& CommentStorageArchive::_internal_author() const {
  const ::TSP::Reference* p = author_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& CommentStorageArchive::author() const {
  // @@protoc_insertion_point(field_get:TSD.CommentStorageArchive.author)
  return _internal_author();
}
inline void CommentStorageArchive::unsafe_arena_set_allocated_author(
    ::TSP::Reference* author) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(author_);
  }
  author_ = author;
  if (author) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.CommentStorageArchive.author)
}
inline ::TSP::Reference* CommentStorageArchive::release_author() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = author_;
  author_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* CommentStorageArchive::unsafe_arena_release_author() {
  // @@protoc_insertion_point(field_release:TSD.CommentStorageArchive.author)
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = author_;
  author_ = nullptr;
  return temp;
}
inline ::TSP::Reference* CommentStorageArchive::_internal_mutable_author() {
  _has_bits_[0] |= 0x00000004u;
  if (author_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    author_ = p;
  }
  return author_;
}
inline ::TSP::Reference* CommentStorageArchive::mutable_author() {
  // @@protoc_insertion_point(field_mutable:TSD.CommentStorageArchive.author)
  return _internal_mutable_author();
}
inline void CommentStorageArchive::set_allocated_author(::TSP::Reference* author) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(author_);
  }
  if (author) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(author)->GetArena();
    if (message_arena != submessage_arena) {
      author = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, author, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  author_ = author;
  // @@protoc_insertion_point(field_set_allocated:TSD.CommentStorageArchive.author)
}

// repeated .TSP.Reference replies = 4;
inline int CommentStorageArchive::_internal_replies_size() const {
  return replies_.size();
}
inline int CommentStorageArchive::replies_size() const {
  return _internal_replies_size();
}
inline ::TSP::Reference* CommentStorageArchive::mutable_replies(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.CommentStorageArchive.replies)
  return replies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
CommentStorageArchive::mutable_replies() {
  // @@protoc_insertion_point(field_mutable_list:TSD.CommentStorageArchive.replies)
  return &replies_;
}
inline const ::TSP::Reference& CommentStorageArchive::_internal_replies(int index) const {
  return replies_.Get(index);
}
inline const ::TSP::Reference& CommentStorageArchive::replies(int index) const {
  // @@protoc_insertion_point(field_get:TSD.CommentStorageArchive.replies)
  return _internal_replies(index);
}
inline ::TSP::Reference* CommentStorageArchive::_internal_add_replies() {
  return replies_.Add();
}
inline ::TSP::Reference* CommentStorageArchive::add_replies() {
  // @@protoc_insertion_point(field_add:TSD.CommentStorageArchive.replies)
  return _internal_add_replies();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
CommentStorageArchive::replies() const {
  // @@protoc_insertion_point(field_list:TSD.CommentStorageArchive.replies)
  return replies_;
}

// -------------------------------------------------------------------

// ReplaceAnnotationAuthorCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ReplaceAnnotationAuthorCommandArchive::_internal_has_super() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || super_ != nullptr);
  return value;
}
inline bool ReplaceAnnotationAuthorCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ReplaceAnnotationAuthorCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ReplaceAnnotationAuthorCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.ReplaceAnnotationAuthorCommandArchive.super)
  return _internal_super();
}
inline void ReplaceAnnotationAuthorCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  super_ = super;
  if (super) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ReplaceAnnotationAuthorCommandArchive.super)
}
inline ::TSK::CommandArchive* ReplaceAnnotationAuthorCommandArchive::release_super() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = super_;
  super_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSK::CommandArchive* ReplaceAnnotationAuthorCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.ReplaceAnnotationAuthorCommandArchive.super)
  _has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = super_;
  super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ReplaceAnnotationAuthorCommandArchive::_internal_mutable_super() {
  _has_bits_[0] |= 0x00000001u;
  if (super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArena());
    super_ = p;
  }
  return super_;
}
inline ::TSK::CommandArchive* ReplaceAnnotationAuthorCommandArchive::mutable_super() {
  // @@protoc_insertion_point(field_mutable:TSD.ReplaceAnnotationAuthorCommandArchive.super)
  return _internal_mutable_super();
}
inline void ReplaceAnnotationAuthorCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super)->GetArena();
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.ReplaceAnnotationAuthorCommandArchive.super)
}

// optional .TSP.Reference old_annotation_author = 2;
inline bool ReplaceAnnotationAuthorCommandArchive::_internal_has_old_annotation_author() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || old_annotation_author_ != nullptr);
  return value;
}
inline bool ReplaceAnnotationAuthorCommandArchive::has_old_annotation_author() const {
  return _internal_has_old_annotation_author();
}
inline const ::TSP::Reference& ReplaceAnnotationAuthorCommandArchive::_internal_old_annotation_author() const {
  const ::TSP::Reference* p = old_annotation_author_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ReplaceAnnotationAuthorCommandArchive::old_annotation_author() const {
  // @@protoc_insertion_point(field_get:TSD.ReplaceAnnotationAuthorCommandArchive.old_annotation_author)
  return _internal_old_annotation_author();
}
inline void ReplaceAnnotationAuthorCommandArchive::unsafe_arena_set_allocated_old_annotation_author(
    ::TSP::Reference* old_annotation_author) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_annotation_author_);
  }
  old_annotation_author_ = old_annotation_author;
  if (old_annotation_author) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ReplaceAnnotationAuthorCommandArchive.old_annotation_author)
}
inline ::TSP::Reference* ReplaceAnnotationAuthorCommandArchive::release_old_annotation_author() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = old_annotation_author_;
  old_annotation_author_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* ReplaceAnnotationAuthorCommandArchive::unsafe_arena_release_old_annotation_author() {
  // @@protoc_insertion_point(field_release:TSD.ReplaceAnnotationAuthorCommandArchive.old_annotation_author)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = old_annotation_author_;
  old_annotation_author_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ReplaceAnnotationAuthorCommandArchive::_internal_mutable_old_annotation_author() {
  _has_bits_[0] |= 0x00000002u;
  if (old_annotation_author_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    old_annotation_author_ = p;
  }
  return old_annotation_author_;
}
inline ::TSP::Reference* ReplaceAnnotationAuthorCommandArchive::mutable_old_annotation_author() {
  // @@protoc_insertion_point(field_mutable:TSD.ReplaceAnnotationAuthorCommandArchive.old_annotation_author)
  return _internal_mutable_old_annotation_author();
}
inline void ReplaceAnnotationAuthorCommandArchive::set_allocated_old_annotation_author(::TSP::Reference* old_annotation_author) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_annotation_author_);
  }
  if (old_annotation_author) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_annotation_author)->GetArena();
    if (message_arena != submessage_arena) {
      old_annotation_author = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_annotation_author, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  old_annotation_author_ = old_annotation_author;
  // @@protoc_insertion_point(field_set_allocated:TSD.ReplaceAnnotationAuthorCommandArchive.old_annotation_author)
}

// optional .TSP.Reference new_annotation_author = 3;
inline bool ReplaceAnnotationAuthorCommandArchive::_internal_has_new_annotation_author() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || new_annotation_author_ != nullptr);
  return value;
}
inline bool ReplaceAnnotationAuthorCommandArchive::has_new_annotation_author() const {
  return _internal_has_new_annotation_author();
}
inline const ::TSP::Reference& ReplaceAnnotationAuthorCommandArchive::_internal_new_annotation_author() const {
  const ::TSP::Reference* p = new_annotation_author_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ReplaceAnnotationAuthorCommandArchive::new_annotation_author() const {
  // @@protoc_insertion_point(field_get:TSD.ReplaceAnnotationAuthorCommandArchive.new_annotation_author)
  return _internal_new_annotation_author();
}
inline void ReplaceAnnotationAuthorCommandArchive::unsafe_arena_set_allocated_new_annotation_author(
    ::TSP::Reference* new_annotation_author) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_annotation_author_);
  }
  new_annotation_author_ = new_annotation_author;
  if (new_annotation_author) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ReplaceAnnotationAuthorCommandArchive.new_annotation_author)
}
inline ::TSP::Reference* ReplaceAnnotationAuthorCommandArchive::release_new_annotation_author() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = new_annotation_author_;
  new_annotation_author_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* ReplaceAnnotationAuthorCommandArchive::unsafe_arena_release_new_annotation_author() {
  // @@protoc_insertion_point(field_release:TSD.ReplaceAnnotationAuthorCommandArchive.new_annotation_author)
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = new_annotation_author_;
  new_annotation_author_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ReplaceAnnotationAuthorCommandArchive::_internal_mutable_new_annotation_author() {
  _has_bits_[0] |= 0x00000004u;
  if (new_annotation_author_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    new_annotation_author_ = p;
  }
  return new_annotation_author_;
}
inline ::TSP::Reference* ReplaceAnnotationAuthorCommandArchive::mutable_new_annotation_author() {
  // @@protoc_insertion_point(field_mutable:TSD.ReplaceAnnotationAuthorCommandArchive.new_annotation_author)
  return _internal_mutable_new_annotation_author();
}
inline void ReplaceAnnotationAuthorCommandArchive::set_allocated_new_annotation_author(::TSP::Reference* new_annotation_author) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_annotation_author_);
  }
  if (new_annotation_author) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_annotation_author)->GetArena();
    if (message_arena != submessage_arena) {
      new_annotation_author = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_annotation_author, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  new_annotation_author_ = new_annotation_author;
  // @@protoc_insertion_point(field_set_allocated:TSD.ReplaceAnnotationAuthorCommandArchive.new_annotation_author)
}

// -------------------------------------------------------------------

// PencilAnnotationArchive

// optional .TSP.Reference pencil_annotation_storage = 1;
inline bool PencilAnnotationArchive::_internal_has_pencil_annotation_storage() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || pencil_annotation_storage_ != nullptr);
  return value;
}
inline bool PencilAnnotationArchive::has_pencil_annotation_storage() const {
  return _internal_has_pencil_annotation_storage();
}
inline const ::TSP::Reference& PencilAnnotationArchive::_internal_pencil_annotation_storage() const {
  const ::TSP::Reference* p = pencil_annotation_storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& PencilAnnotationArchive::pencil_annotation_storage() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationArchive.pencil_annotation_storage)
  return _internal_pencil_annotation_storage();
}
inline void PencilAnnotationArchive::unsafe_arena_set_allocated_pencil_annotation_storage(
    ::TSP::Reference* pencil_annotation_storage) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pencil_annotation_storage_);
  }
  pencil_annotation_storage_ = pencil_annotation_storage;
  if (pencil_annotation_storage) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationArchive.pencil_annotation_storage)
}
inline ::TSP::Reference* PencilAnnotationArchive::release_pencil_annotation_storage() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = pencil_annotation_storage_;
  pencil_annotation_storage_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* PencilAnnotationArchive::unsafe_arena_release_pencil_annotation_storage() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationArchive.pencil_annotation_storage)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = pencil_annotation_storage_;
  pencil_annotation_storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* PencilAnnotationArchive::_internal_mutable_pencil_annotation_storage() {
  _has_bits_[0] |= 0x00000001u;
  if (pencil_annotation_storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    pencil_annotation_storage_ = p;
  }
  return pencil_annotation_storage_;
}
inline ::TSP::Reference* PencilAnnotationArchive::mutable_pencil_annotation_storage() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationArchive.pencil_annotation_storage)
  return _internal_mutable_pencil_annotation_storage();
}
inline void PencilAnnotationArchive::set_allocated_pencil_annotation_storage(::TSP::Reference* pencil_annotation_storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pencil_annotation_storage_);
  }
  if (pencil_annotation_storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pencil_annotation_storage)->GetArena();
    if (message_arena != submessage_arena) {
      pencil_annotation_storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pencil_annotation_storage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pencil_annotation_storage_ = pencil_annotation_storage;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationArchive.pencil_annotation_storage)
}

// -------------------------------------------------------------------

// PencilAnnotationSelectionArchive

// optional .TSP.Reference pencil_annotation = 1;
inline bool PencilAnnotationSelectionArchive::_internal_has_pencil_annotation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || pencil_annotation_ != nullptr);
  return value;
}
inline bool PencilAnnotationSelectionArchive::has_pencil_annotation() const {
  return _internal_has_pencil_annotation();
}
inline const ::TSP::Reference& PencilAnnotationSelectionArchive::_internal_pencil_annotation() const {
  const ::TSP::Reference* p = pencil_annotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& PencilAnnotationSelectionArchive::pencil_annotation() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationSelectionArchive.pencil_annotation)
  return _internal_pencil_annotation();
}
inline void PencilAnnotationSelectionArchive::unsafe_arena_set_allocated_pencil_annotation(
    ::TSP::Reference* pencil_annotation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pencil_annotation_);
  }
  pencil_annotation_ = pencil_annotation;
  if (pencil_annotation) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationSelectionArchive.pencil_annotation)
}
inline ::TSP::Reference* PencilAnnotationSelectionArchive::release_pencil_annotation() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = pencil_annotation_;
  pencil_annotation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Reference* PencilAnnotationSelectionArchive::unsafe_arena_release_pencil_annotation() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationSelectionArchive.pencil_annotation)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = pencil_annotation_;
  pencil_annotation_ = nullptr;
  return temp;
}
inline ::TSP::Reference* PencilAnnotationSelectionArchive::_internal_mutable_pencil_annotation() {
  _has_bits_[0] |= 0x00000001u;
  if (pencil_annotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArena());
    pencil_annotation_ = p;
  }
  return pencil_annotation_;
}
inline ::TSP::Reference* PencilAnnotationSelectionArchive::mutable_pencil_annotation() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationSelectionArchive.pencil_annotation)
  return _internal_mutable_pencil_annotation();
}
inline void PencilAnnotationSelectionArchive::set_allocated_pencil_annotation(::TSP::Reference* pencil_annotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pencil_annotation_);
  }
  if (pencil_annotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pencil_annotation)->GetArena();
    if (message_arena != submessage_arena) {
      pencil_annotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pencil_annotation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pencil_annotation_ = pencil_annotation;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationSelectionArchive.pencil_annotation)
}

// -------------------------------------------------------------------

// PencilAnnotationStorageArchive

// optional int32 attached_location = 1;
inline bool PencilAnnotationStorageArchive::_internal_has_attached_location() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool PencilAnnotationStorageArchive::has_attached_location() const {
  return _internal_has_attached_location();
}
inline void PencilAnnotationStorageArchive::clear_attached_location() {
  attached_location_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PencilAnnotationStorageArchive::_internal_attached_location() const {
  return attached_location_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PencilAnnotationStorageArchive::attached_location() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.attached_location)
  return _internal_attached_location();
}
inline void PencilAnnotationStorageArchive::_internal_set_attached_location(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00004000u;
  attached_location_ = value;
}
inline void PencilAnnotationStorageArchive::set_attached_location(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attached_location(value);
  // @@protoc_insertion_point(field_set:TSD.PencilAnnotationStorageArchive.attached_location)
}

// optional .TSP.Point markup_offset = 2;
inline bool PencilAnnotationStorageArchive::_internal_has_markup_offset() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || markup_offset_ != nullptr);
  return value;
}
inline bool PencilAnnotationStorageArchive::has_markup_offset() const {
  return _internal_has_markup_offset();
}
inline const ::TSP::Point& PencilAnnotationStorageArchive::_internal_markup_offset() const {
  const ::TSP::Point* p = markup_offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& PencilAnnotationStorageArchive::markup_offset() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.markup_offset)
  return _internal_markup_offset();
}
inline void PencilAnnotationStorageArchive::unsafe_arena_set_allocated_markup_offset(
    ::TSP::Point* markup_offset) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(markup_offset_);
  }
  markup_offset_ = markup_offset;
  if (markup_offset) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationStorageArchive.markup_offset)
}
inline ::TSP::Point* PencilAnnotationStorageArchive::release_markup_offset() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = markup_offset_;
  markup_offset_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Point* PencilAnnotationStorageArchive::unsafe_arena_release_markup_offset() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationStorageArchive.markup_offset)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = markup_offset_;
  markup_offset_ = nullptr;
  return temp;
}
inline ::TSP::Point* PencilAnnotationStorageArchive::_internal_mutable_markup_offset() {
  _has_bits_[0] |= 0x00000001u;
  if (markup_offset_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArena());
    markup_offset_ = p;
  }
  return markup_offset_;
}
inline ::TSP::Point* PencilAnnotationStorageArchive::mutable_markup_offset() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.markup_offset)
  return _internal_mutable_markup_offset();
}
inline void PencilAnnotationStorageArchive::set_allocated_markup_offset(::TSP::Point* markup_offset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(markup_offset_);
  }
  if (markup_offset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(markup_offset)->GetArena();
    if (message_arena != submessage_arena) {
      markup_offset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, markup_offset, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  markup_offset_ = markup_offset;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationStorageArchive.markup_offset)
}

// optional .TSP.DataReference rasterized_image = 3;
inline bool PencilAnnotationStorageArchive::_internal_has_rasterized_image() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || rasterized_image_ != nullptr);
  return value;
}
inline bool PencilAnnotationStorageArchive::has_rasterized_image() const {
  return _internal_has_rasterized_image();
}
inline const ::TSP::DataReference& PencilAnnotationStorageArchive::_internal_rasterized_image() const {
  const ::TSP::DataReference* p = rasterized_image_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& PencilAnnotationStorageArchive::rasterized_image() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.rasterized_image)
  return _internal_rasterized_image();
}
inline void PencilAnnotationStorageArchive::unsafe_arena_set_allocated_rasterized_image(
    ::TSP::DataReference* rasterized_image) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rasterized_image_);
  }
  rasterized_image_ = rasterized_image;
  if (rasterized_image) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationStorageArchive.rasterized_image)
}
inline ::TSP::DataReference* PencilAnnotationStorageArchive::release_rasterized_image() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::DataReference* temp = rasterized_image_;
  rasterized_image_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* PencilAnnotationStorageArchive::unsafe_arena_release_rasterized_image() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationStorageArchive.rasterized_image)
  _has_bits_[0] &= ~0x00000002u;
  ::TSP::DataReference* temp = rasterized_image_;
  rasterized_image_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* PencilAnnotationStorageArchive::_internal_mutable_rasterized_image() {
  _has_bits_[0] |= 0x00000002u;
  if (rasterized_image_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    rasterized_image_ = p;
  }
  return rasterized_image_;
}
inline ::TSP::DataReference* PencilAnnotationStorageArchive::mutable_rasterized_image() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.rasterized_image)
  return _internal_mutable_rasterized_image();
}
inline void PencilAnnotationStorageArchive::set_allocated_rasterized_image(::TSP::DataReference* rasterized_image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(rasterized_image_);
  }
  if (rasterized_image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rasterized_image)->GetArena();
    if (message_arena != submessage_arena) {
      rasterized_image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rasterized_image, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  rasterized_image_ = rasterized_image;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationStorageArchive.rasterized_image)
}

// optional .TSP.DataReference legacy_encoded_drawing = 4;
inline bool PencilAnnotationStorageArchive::_internal_has_legacy_encoded_drawing() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || legacy_encoded_drawing_ != nullptr);
  return value;
}
inline bool PencilAnnotationStorageArchive::has_legacy_encoded_drawing() const {
  return _internal_has_legacy_encoded_drawing();
}
inline const ::TSP::DataReference& PencilAnnotationStorageArchive::_internal_legacy_encoded_drawing() const {
  const ::TSP::DataReference* p = legacy_encoded_drawing_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& PencilAnnotationStorageArchive::legacy_encoded_drawing() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.legacy_encoded_drawing)
  return _internal_legacy_encoded_drawing();
}
inline void PencilAnnotationStorageArchive::unsafe_arena_set_allocated_legacy_encoded_drawing(
    ::TSP::DataReference* legacy_encoded_drawing) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(legacy_encoded_drawing_);
  }
  legacy_encoded_drawing_ = legacy_encoded_drawing;
  if (legacy_encoded_drawing) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationStorageArchive.legacy_encoded_drawing)
}
inline ::TSP::DataReference* PencilAnnotationStorageArchive::release_legacy_encoded_drawing() {
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::DataReference* temp = legacy_encoded_drawing_;
  legacy_encoded_drawing_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* PencilAnnotationStorageArchive::unsafe_arena_release_legacy_encoded_drawing() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationStorageArchive.legacy_encoded_drawing)
  _has_bits_[0] &= ~0x00000004u;
  ::TSP::DataReference* temp = legacy_encoded_drawing_;
  legacy_encoded_drawing_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* PencilAnnotationStorageArchive::_internal_mutable_legacy_encoded_drawing() {
  _has_bits_[0] |= 0x00000004u;
  if (legacy_encoded_drawing_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    legacy_encoded_drawing_ = p;
  }
  return legacy_encoded_drawing_;
}
inline ::TSP::DataReference* PencilAnnotationStorageArchive::mutable_legacy_encoded_drawing() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.legacy_encoded_drawing)
  return _internal_mutable_legacy_encoded_drawing();
}
inline void PencilAnnotationStorageArchive::set_allocated_legacy_encoded_drawing(::TSP::DataReference* legacy_encoded_drawing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(legacy_encoded_drawing_);
  }
  if (legacy_encoded_drawing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(legacy_encoded_drawing)->GetArena();
    if (message_arena != submessage_arena) {
      legacy_encoded_drawing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, legacy_encoded_drawing, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  legacy_encoded_drawing_ = legacy_encoded_drawing;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationStorageArchive.legacy_encoded_drawing)
}

// optional .TSP.Path drawing_path = 5;
inline bool PencilAnnotationStorageArchive::_internal_has_drawing_path() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || drawing_path_ != nullptr);
  return value;
}
inline bool PencilAnnotationStorageArchive::has_drawing_path() const {
  return _internal_has_drawing_path();
}
inline const ::TSP::Path& PencilAnnotationStorageArchive::_internal_drawing_path() const {
  const ::TSP::Path* p = drawing_path_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Path&>(
      ::TSP::_Path_default_instance_);
}
inline const ::TSP::Path& PencilAnnotationStorageArchive::drawing_path() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.drawing_path)
  return _internal_drawing_path();
}
inline void PencilAnnotationStorageArchive::unsafe_arena_set_allocated_drawing_path(
    ::TSP::Path* drawing_path) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(drawing_path_);
  }
  drawing_path_ = drawing_path;
  if (drawing_path) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationStorageArchive.drawing_path)
}
inline ::TSP::Path* PencilAnnotationStorageArchive::release_drawing_path() {
  _has_bits_[0] &= ~0x00000008u;
  ::TSP::Path* temp = drawing_path_;
  drawing_path_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Path* PencilAnnotationStorageArchive::unsafe_arena_release_drawing_path() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationStorageArchive.drawing_path)
  _has_bits_[0] &= ~0x00000008u;
  ::TSP::Path* temp = drawing_path_;
  drawing_path_ = nullptr;
  return temp;
}
inline ::TSP::Path* PencilAnnotationStorageArchive::_internal_mutable_drawing_path() {
  _has_bits_[0] |= 0x00000008u;
  if (drawing_path_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Path>(GetArena());
    drawing_path_ = p;
  }
  return drawing_path_;
}
inline ::TSP::Path* PencilAnnotationStorageArchive::mutable_drawing_path() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.drawing_path)
  return _internal_mutable_drawing_path();
}
inline void PencilAnnotationStorageArchive::set_allocated_drawing_path(::TSP::Path* drawing_path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(drawing_path_);
  }
  if (drawing_path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(drawing_path)->GetArena();
    if (message_arena != submessage_arena) {
      drawing_path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drawing_path, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  drawing_path_ = drawing_path;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationStorageArchive.drawing_path)
}

// optional .TSP.Point strokes_bounding_box_origin = 6;
inline bool PencilAnnotationStorageArchive::_internal_has_strokes_bounding_box_origin() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || strokes_bounding_box_origin_ != nullptr);
  return value;
}
inline bool PencilAnnotationStorageArchive::has_strokes_bounding_box_origin() const {
  return _internal_has_strokes_bounding_box_origin();
}
inline const ::TSP::Point& PencilAnnotationStorageArchive::_internal_strokes_bounding_box_origin() const {
  const ::TSP::Point* p = strokes_bounding_box_origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& PencilAnnotationStorageArchive::strokes_bounding_box_origin() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.strokes_bounding_box_origin)
  return _internal_strokes_bounding_box_origin();
}
inline void PencilAnnotationStorageArchive::unsafe_arena_set_allocated_strokes_bounding_box_origin(
    ::TSP::Point* strokes_bounding_box_origin) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(strokes_bounding_box_origin_);
  }
  strokes_bounding_box_origin_ = strokes_bounding_box_origin;
  if (strokes_bounding_box_origin) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationStorageArchive.strokes_bounding_box_origin)
}
inline ::TSP::Point* PencilAnnotationStorageArchive::release_strokes_bounding_box_origin() {
  _has_bits_[0] &= ~0x00000010u;
  ::TSP::Point* temp = strokes_bounding_box_origin_;
  strokes_bounding_box_origin_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Point* PencilAnnotationStorageArchive::unsafe_arena_release_strokes_bounding_box_origin() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationStorageArchive.strokes_bounding_box_origin)
  _has_bits_[0] &= ~0x00000010u;
  ::TSP::Point* temp = strokes_bounding_box_origin_;
  strokes_bounding_box_origin_ = nullptr;
  return temp;
}
inline ::TSP::Point* PencilAnnotationStorageArchive::_internal_mutable_strokes_bounding_box_origin() {
  _has_bits_[0] |= 0x00000010u;
  if (strokes_bounding_box_origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArena());
    strokes_bounding_box_origin_ = p;
  }
  return strokes_bounding_box_origin_;
}
inline ::TSP::Point* PencilAnnotationStorageArchive::mutable_strokes_bounding_box_origin() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.strokes_bounding_box_origin)
  return _internal_mutable_strokes_bounding_box_origin();
}
inline void PencilAnnotationStorageArchive::set_allocated_strokes_bounding_box_origin(::TSP::Point* strokes_bounding_box_origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(strokes_bounding_box_origin_);
  }
  if (strokes_bounding_box_origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(strokes_bounding_box_origin)->GetArena();
    if (message_arena != submessage_arena) {
      strokes_bounding_box_origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strokes_bounding_box_origin, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  strokes_bounding_box_origin_ = strokes_bounding_box_origin;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationStorageArchive.strokes_bounding_box_origin)
}

// optional .TSP.Size strokes_bounding_box_size = 7;
inline bool PencilAnnotationStorageArchive::_internal_has_strokes_bounding_box_size() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || strokes_bounding_box_size_ != nullptr);
  return value;
}
inline bool PencilAnnotationStorageArchive::has_strokes_bounding_box_size() const {
  return _internal_has_strokes_bounding_box_size();
}
inline const ::TSP::Size& PencilAnnotationStorageArchive::_internal_strokes_bounding_box_size() const {
  const ::TSP::Size* p = strokes_bounding_box_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& PencilAnnotationStorageArchive::strokes_bounding_box_size() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.strokes_bounding_box_size)
  return _internal_strokes_bounding_box_size();
}
inline void PencilAnnotationStorageArchive::unsafe_arena_set_allocated_strokes_bounding_box_size(
    ::TSP::Size* strokes_bounding_box_size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(strokes_bounding_box_size_);
  }
  strokes_bounding_box_size_ = strokes_bounding_box_size;
  if (strokes_bounding_box_size) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationStorageArchive.strokes_bounding_box_size)
}
inline ::TSP::Size* PencilAnnotationStorageArchive::release_strokes_bounding_box_size() {
  _has_bits_[0] &= ~0x00000020u;
  ::TSP::Size* temp = strokes_bounding_box_size_;
  strokes_bounding_box_size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* PencilAnnotationStorageArchive::unsafe_arena_release_strokes_bounding_box_size() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationStorageArchive.strokes_bounding_box_size)
  _has_bits_[0] &= ~0x00000020u;
  ::TSP::Size* temp = strokes_bounding_box_size_;
  strokes_bounding_box_size_ = nullptr;
  return temp;
}
inline ::TSP::Size* PencilAnnotationStorageArchive::_internal_mutable_strokes_bounding_box_size() {
  _has_bits_[0] |= 0x00000020u;
  if (strokes_bounding_box_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    strokes_bounding_box_size_ = p;
  }
  return strokes_bounding_box_size_;
}
inline ::TSP::Size* PencilAnnotationStorageArchive::mutable_strokes_bounding_box_size() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.strokes_bounding_box_size)
  return _internal_mutable_strokes_bounding_box_size();
}
inline void PencilAnnotationStorageArchive::set_allocated_strokes_bounding_box_size(::TSP::Size* strokes_bounding_box_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(strokes_bounding_box_size_);
  }
  if (strokes_bounding_box_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(strokes_bounding_box_size)->GetArena();
    if (message_arena != submessage_arena) {
      strokes_bounding_box_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strokes_bounding_box_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  strokes_bounding_box_size_ = strokes_bounding_box_size;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationStorageArchive.strokes_bounding_box_size)
}

// optional int32 attached_type = 8;
inline bool PencilAnnotationStorageArchive::_internal_has_attached_type() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool PencilAnnotationStorageArchive::has_attached_type() const {
  return _internal_has_attached_type();
}
inline void PencilAnnotationStorageArchive::clear_attached_type() {
  attached_type_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PencilAnnotationStorageArchive::_internal_attached_type() const {
  return attached_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PencilAnnotationStorageArchive::attached_type() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.attached_type)
  return _internal_attached_type();
}
inline void PencilAnnotationStorageArchive::_internal_set_attached_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00008000u;
  attached_type_ = value;
}
inline void PencilAnnotationStorageArchive::set_attached_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attached_type(value);
  // @@protoc_insertion_point(field_set:TSD.PencilAnnotationStorageArchive.attached_type)
}

// optional .TSP.Size original_attached_size = 9;
inline bool PencilAnnotationStorageArchive::_internal_has_original_attached_size() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || original_attached_size_ != nullptr);
  return value;
}
inline bool PencilAnnotationStorageArchive::has_original_attached_size() const {
  return _internal_has_original_attached_size();
}
inline const ::TSP::Size& PencilAnnotationStorageArchive::_internal_original_attached_size() const {
  const ::TSP::Size* p = original_attached_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& PencilAnnotationStorageArchive::original_attached_size() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.original_attached_size)
  return _internal_original_attached_size();
}
inline void PencilAnnotationStorageArchive::unsafe_arena_set_allocated_original_attached_size(
    ::TSP::Size* original_attached_size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(original_attached_size_);
  }
  original_attached_size_ = original_attached_size;
  if (original_attached_size) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationStorageArchive.original_attached_size)
}
inline ::TSP::Size* PencilAnnotationStorageArchive::release_original_attached_size() {
  _has_bits_[0] &= ~0x00000040u;
  ::TSP::Size* temp = original_attached_size_;
  original_attached_size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* PencilAnnotationStorageArchive::unsafe_arena_release_original_attached_size() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationStorageArchive.original_attached_size)
  _has_bits_[0] &= ~0x00000040u;
  ::TSP::Size* temp = original_attached_size_;
  original_attached_size_ = nullptr;
  return temp;
}
inline ::TSP::Size* PencilAnnotationStorageArchive::_internal_mutable_original_attached_size() {
  _has_bits_[0] |= 0x00000040u;
  if (original_attached_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    original_attached_size_ = p;
  }
  return original_attached_size_;
}
inline ::TSP::Size* PencilAnnotationStorageArchive::mutable_original_attached_size() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.original_attached_size)
  return _internal_mutable_original_attached_size();
}
inline void PencilAnnotationStorageArchive::set_allocated_original_attached_size(::TSP::Size* original_attached_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(original_attached_size_);
  }
  if (original_attached_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(original_attached_size)->GetArena();
    if (message_arena != submessage_arena) {
      original_attached_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, original_attached_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  original_attached_size_ = original_attached_size;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationStorageArchive.original_attached_size)
}

// optional double percent_of_pa_contained_in_parent_rep = 10;
inline bool PencilAnnotationStorageArchive::_internal_has_percent_of_pa_contained_in_parent_rep() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool PencilAnnotationStorageArchive::has_percent_of_pa_contained_in_parent_rep() const {
  return _internal_has_percent_of_pa_contained_in_parent_rep();
}
inline void PencilAnnotationStorageArchive::clear_percent_of_pa_contained_in_parent_rep() {
  percent_of_pa_contained_in_parent_rep_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline double PencilAnnotationStorageArchive::_internal_percent_of_pa_contained_in_parent_rep() const {
  return percent_of_pa_contained_in_parent_rep_;
}
inline double PencilAnnotationStorageArchive::percent_of_pa_contained_in_parent_rep() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.percent_of_pa_contained_in_parent_rep)
  return _internal_percent_of_pa_contained_in_parent_rep();
}
inline void PencilAnnotationStorageArchive::_internal_set_percent_of_pa_contained_in_parent_rep(double value) {
  _has_bits_[0] |= 0x00010000u;
  percent_of_pa_contained_in_parent_rep_ = value;
}
inline void PencilAnnotationStorageArchive::set_percent_of_pa_contained_in_parent_rep(double value) {
  _internal_set_percent_of_pa_contained_in_parent_rep(value);
  // @@protoc_insertion_point(field_set:TSD.PencilAnnotationStorageArchive.percent_of_pa_contained_in_parent_rep)
}

// optional uint64 text_baselines_touched_count = 11;
inline bool PencilAnnotationStorageArchive::_internal_has_text_baselines_touched_count() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool PencilAnnotationStorageArchive::has_text_baselines_touched_count() const {
  return _internal_has_text_baselines_touched_count();
}
inline void PencilAnnotationStorageArchive::clear_text_baselines_touched_count() {
  text_baselines_touched_count_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PencilAnnotationStorageArchive::_internal_text_baselines_touched_count() const {
  return text_baselines_touched_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PencilAnnotationStorageArchive::text_baselines_touched_count() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.text_baselines_touched_count)
  return _internal_text_baselines_touched_count();
}
inline void PencilAnnotationStorageArchive::_internal_set_text_baselines_touched_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00020000u;
  text_baselines_touched_count_ = value;
}
inline void PencilAnnotationStorageArchive::set_text_baselines_touched_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_text_baselines_touched_count(value);
  // @@protoc_insertion_point(field_set:TSD.PencilAnnotationStorageArchive.text_baselines_touched_count)
}

// optional uint64 visible_strokes_count = 12;
inline bool PencilAnnotationStorageArchive::_internal_has_visible_strokes_count() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool PencilAnnotationStorageArchive::has_visible_strokes_count() const {
  return _internal_has_visible_strokes_count();
}
inline void PencilAnnotationStorageArchive::clear_visible_strokes_count() {
  visible_strokes_count_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PencilAnnotationStorageArchive::_internal_visible_strokes_count() const {
  return visible_strokes_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PencilAnnotationStorageArchive::visible_strokes_count() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.visible_strokes_count)
  return _internal_visible_strokes_count();
}
inline void PencilAnnotationStorageArchive::_internal_set_visible_strokes_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00040000u;
  visible_strokes_count_ = value;
}
inline void PencilAnnotationStorageArchive::set_visible_strokes_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_visible_strokes_count(value);
  // @@protoc_insertion_point(field_set:TSD.PencilAnnotationStorageArchive.visible_strokes_count)
}

// optional .TSP.Color pen_color = 13;
inline bool PencilAnnotationStorageArchive::_internal_has_pen_color() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || pen_color_ != nullptr);
  return value;
}
inline bool PencilAnnotationStorageArchive::has_pen_color() const {
  return _internal_has_pen_color();
}
inline const ::TSP::Color& PencilAnnotationStorageArchive::_internal_pen_color() const {
  const ::TSP::Color* p = pen_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& PencilAnnotationStorageArchive::pen_color() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.pen_color)
  return _internal_pen_color();
}
inline void PencilAnnotationStorageArchive::unsafe_arena_set_allocated_pen_color(
    ::TSP::Color* pen_color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pen_color_);
  }
  pen_color_ = pen_color;
  if (pen_color) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationStorageArchive.pen_color)
}
inline ::TSP::Color* PencilAnnotationStorageArchive::release_pen_color() {
  _has_bits_[0] &= ~0x00000080u;
  ::TSP::Color* temp = pen_color_;
  pen_color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* PencilAnnotationStorageArchive::unsafe_arena_release_pen_color() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationStorageArchive.pen_color)
  _has_bits_[0] &= ~0x00000080u;
  ::TSP::Color* temp = pen_color_;
  pen_color_ = nullptr;
  return temp;
}
inline ::TSP::Color* PencilAnnotationStorageArchive::_internal_mutable_pen_color() {
  _has_bits_[0] |= 0x00000080u;
  if (pen_color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    pen_color_ = p;
  }
  return pen_color_;
}
inline ::TSP::Color* PencilAnnotationStorageArchive::mutable_pen_color() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.pen_color)
  return _internal_mutable_pen_color();
}
inline void PencilAnnotationStorageArchive::set_allocated_pen_color(::TSP::Color* pen_color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pen_color_);
  }
  if (pen_color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pen_color)->GetArena();
    if (message_arena != submessage_arena) {
      pen_color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pen_color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  pen_color_ = pen_color;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationStorageArchive.pen_color)
}

// optional int32 tool_type = 14;
inline bool PencilAnnotationStorageArchive::_internal_has_tool_type() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool PencilAnnotationStorageArchive::has_tool_type() const {
  return _internal_has_tool_type();
}
inline void PencilAnnotationStorageArchive::clear_tool_type() {
  tool_type_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PencilAnnotationStorageArchive::_internal_tool_type() const {
  return tool_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PencilAnnotationStorageArchive::tool_type() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.tool_type)
  return _internal_tool_type();
}
inline void PencilAnnotationStorageArchive::_internal_set_tool_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00080000u;
  tool_type_ = value;
}
inline void PencilAnnotationStorageArchive::set_tool_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tool_type(value);
  // @@protoc_insertion_point(field_set:TSD.PencilAnnotationStorageArchive.tool_type)
}

// repeated .TSP.Reference callout_sub_storages = 15;
inline int PencilAnnotationStorageArchive::_internal_callout_sub_storages_size() const {
  return callout_sub_storages_.size();
}
inline int PencilAnnotationStorageArchive::callout_sub_storages_size() const {
  return _internal_callout_sub_storages_size();
}
inline ::TSP::Reference* PencilAnnotationStorageArchive::mutable_callout_sub_storages(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.callout_sub_storages)
  return callout_sub_storages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
PencilAnnotationStorageArchive::mutable_callout_sub_storages() {
  // @@protoc_insertion_point(field_mutable_list:TSD.PencilAnnotationStorageArchive.callout_sub_storages)
  return &callout_sub_storages_;
}
inline const ::TSP::Reference& PencilAnnotationStorageArchive::_internal_callout_sub_storages(int index) const {
  return callout_sub_storages_.Get(index);
}
inline const ::TSP::Reference& PencilAnnotationStorageArchive::callout_sub_storages(int index) const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.callout_sub_storages)
  return _internal_callout_sub_storages(index);
}
inline ::TSP::Reference* PencilAnnotationStorageArchive::_internal_add_callout_sub_storages() {
  return callout_sub_storages_.Add();
}
inline ::TSP::Reference* PencilAnnotationStorageArchive::add_callout_sub_storages() {
  // @@protoc_insertion_point(field_add:TSD.PencilAnnotationStorageArchive.callout_sub_storages)
  return _internal_add_callout_sub_storages();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
PencilAnnotationStorageArchive::callout_sub_storages() const {
  // @@protoc_insertion_point(field_list:TSD.PencilAnnotationStorageArchive.callout_sub_storages)
  return callout_sub_storages_;
}

// optional .TSP.Date creation_date = 16;
inline bool PencilAnnotationStorageArchive::_internal_has_creation_date() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || creation_date_ != nullptr);
  return value;
}
inline bool PencilAnnotationStorageArchive::has_creation_date() const {
  return _internal_has_creation_date();
}
inline const ::TSP::Date& PencilAnnotationStorageArchive::_internal_creation_date() const {
  const ::TSP::Date* p = creation_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Date&>(
      ::TSP::_Date_default_instance_);
}
inline const ::TSP::Date& PencilAnnotationStorageArchive::creation_date() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.creation_date)
  return _internal_creation_date();
}
inline void PencilAnnotationStorageArchive::unsafe_arena_set_allocated_creation_date(
    ::TSP::Date* creation_date) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(creation_date_);
  }
  creation_date_ = creation_date;
  if (creation_date) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationStorageArchive.creation_date)
}
inline ::TSP::Date* PencilAnnotationStorageArchive::release_creation_date() {
  _has_bits_[0] &= ~0x00000100u;
  ::TSP::Date* temp = creation_date_;
  creation_date_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Date* PencilAnnotationStorageArchive::unsafe_arena_release_creation_date() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationStorageArchive.creation_date)
  _has_bits_[0] &= ~0x00000100u;
  ::TSP::Date* temp = creation_date_;
  creation_date_ = nullptr;
  return temp;
}
inline ::TSP::Date* PencilAnnotationStorageArchive::_internal_mutable_creation_date() {
  _has_bits_[0] |= 0x00000100u;
  if (creation_date_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Date>(GetArena());
    creation_date_ = p;
  }
  return creation_date_;
}
inline ::TSP::Date* PencilAnnotationStorageArchive::mutable_creation_date() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.creation_date)
  return _internal_mutable_creation_date();
}
inline void PencilAnnotationStorageArchive::set_allocated_creation_date(::TSP::Date* creation_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(creation_date_);
  }
  if (creation_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(creation_date)->GetArena();
    if (message_arena != submessage_arena) {
      creation_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creation_date, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  creation_date_ = creation_date;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationStorageArchive.creation_date)
}

// optional double pencil_annotation_drawing_scale = 17;
inline bool PencilAnnotationStorageArchive::_internal_has_pencil_annotation_drawing_scale() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool PencilAnnotationStorageArchive::has_pencil_annotation_drawing_scale() const {
  return _internal_has_pencil_annotation_drawing_scale();
}
inline void PencilAnnotationStorageArchive::clear_pencil_annotation_drawing_scale() {
  pencil_annotation_drawing_scale_ = 0;
  _has_bits_[0] &= ~0x00200000u;
}
inline double PencilAnnotationStorageArchive::_internal_pencil_annotation_drawing_scale() const {
  return pencil_annotation_drawing_scale_;
}
inline double PencilAnnotationStorageArchive::pencil_annotation_drawing_scale() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.pencil_annotation_drawing_scale)
  return _internal_pencil_annotation_drawing_scale();
}
inline void PencilAnnotationStorageArchive::_internal_set_pencil_annotation_drawing_scale(double value) {
  _has_bits_[0] |= 0x00200000u;
  pencil_annotation_drawing_scale_ = value;
}
inline void PencilAnnotationStorageArchive::set_pencil_annotation_drawing_scale(double value) {
  _internal_set_pencil_annotation_drawing_scale(value);
  // @@protoc_insertion_point(field_set:TSD.PencilAnnotationStorageArchive.pencil_annotation_drawing_scale)
}

// optional int32 compound_annotation_type = 18;
inline bool PencilAnnotationStorageArchive::_internal_has_compound_annotation_type() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool PencilAnnotationStorageArchive::has_compound_annotation_type() const {
  return _internal_has_compound_annotation_type();
}
inline void PencilAnnotationStorageArchive::clear_compound_annotation_type() {
  compound_annotation_type_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PencilAnnotationStorageArchive::_internal_compound_annotation_type() const {
  return compound_annotation_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PencilAnnotationStorageArchive::compound_annotation_type() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.compound_annotation_type)
  return _internal_compound_annotation_type();
}
inline void PencilAnnotationStorageArchive::_internal_set_compound_annotation_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00100000u;
  compound_annotation_type_ = value;
}
inline void PencilAnnotationStorageArchive::set_compound_annotation_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_compound_annotation_type(value);
  // @@protoc_insertion_point(field_set:TSD.PencilAnnotationStorageArchive.compound_annotation_type)
}

// repeated .TSP.Reference sub_storages = 19;
inline int PencilAnnotationStorageArchive::_internal_sub_storages_size() const {
  return sub_storages_.size();
}
inline int PencilAnnotationStorageArchive::sub_storages_size() const {
  return _internal_sub_storages_size();
}
inline ::TSP::Reference* PencilAnnotationStorageArchive::mutable_sub_storages(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.sub_storages)
  return sub_storages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
PencilAnnotationStorageArchive::mutable_sub_storages() {
  // @@protoc_insertion_point(field_mutable_list:TSD.PencilAnnotationStorageArchive.sub_storages)
  return &sub_storages_;
}
inline const ::TSP::Reference& PencilAnnotationStorageArchive::_internal_sub_storages(int index) const {
  return sub_storages_.Get(index);
}
inline const ::TSP::Reference& PencilAnnotationStorageArchive::sub_storages(int index) const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.sub_storages)
  return _internal_sub_storages(index);
}
inline ::TSP::Reference* PencilAnnotationStorageArchive::_internal_add_sub_storages() {
  return sub_storages_.Add();
}
inline ::TSP::Reference* PencilAnnotationStorageArchive::add_sub_storages() {
  // @@protoc_insertion_point(field_add:TSD.PencilAnnotationStorageArchive.sub_storages)
  return _internal_add_sub_storages();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
PencilAnnotationStorageArchive::sub_storages() const {
  // @@protoc_insertion_point(field_list:TSD.PencilAnnotationStorageArchive.sub_storages)
  return sub_storages_;
}

// optional .TSP.DataReference encoded_drawing = 20;
inline bool PencilAnnotationStorageArchive::_internal_has_encoded_drawing() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || encoded_drawing_ != nullptr);
  return value;
}
inline bool PencilAnnotationStorageArchive::has_encoded_drawing() const {
  return _internal_has_encoded_drawing();
}
inline const ::TSP::DataReference& PencilAnnotationStorageArchive::_internal_encoded_drawing() const {
  const ::TSP::DataReference* p = encoded_drawing_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& PencilAnnotationStorageArchive::encoded_drawing() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.encoded_drawing)
  return _internal_encoded_drawing();
}
inline void PencilAnnotationStorageArchive::unsafe_arena_set_allocated_encoded_drawing(
    ::TSP::DataReference* encoded_drawing) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encoded_drawing_);
  }
  encoded_drawing_ = encoded_drawing;
  if (encoded_drawing) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationStorageArchive.encoded_drawing)
}
inline ::TSP::DataReference* PencilAnnotationStorageArchive::release_encoded_drawing() {
  _has_bits_[0] &= ~0x00000200u;
  ::TSP::DataReference* temp = encoded_drawing_;
  encoded_drawing_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::DataReference* PencilAnnotationStorageArchive::unsafe_arena_release_encoded_drawing() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationStorageArchive.encoded_drawing)
  _has_bits_[0] &= ~0x00000200u;
  ::TSP::DataReference* temp = encoded_drawing_;
  encoded_drawing_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* PencilAnnotationStorageArchive::_internal_mutable_encoded_drawing() {
  _has_bits_[0] |= 0x00000200u;
  if (encoded_drawing_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArena());
    encoded_drawing_ = p;
  }
  return encoded_drawing_;
}
inline ::TSP::DataReference* PencilAnnotationStorageArchive::mutable_encoded_drawing() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.encoded_drawing)
  return _internal_mutable_encoded_drawing();
}
inline void PencilAnnotationStorageArchive::set_allocated_encoded_drawing(::TSP::DataReference* encoded_drawing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(encoded_drawing_);
  }
  if (encoded_drawing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encoded_drawing)->GetArena();
    if (message_arena != submessage_arena) {
      encoded_drawing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encoded_drawing, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  encoded_drawing_ = encoded_drawing;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationStorageArchive.encoded_drawing)
}

// optional .TSP.Point stroke_points_frame_origin = 21;
inline bool PencilAnnotationStorageArchive::_internal_has_stroke_points_frame_origin() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || stroke_points_frame_origin_ != nullptr);
  return value;
}
inline bool PencilAnnotationStorageArchive::has_stroke_points_frame_origin() const {
  return _internal_has_stroke_points_frame_origin();
}
inline const ::TSP::Point& PencilAnnotationStorageArchive::_internal_stroke_points_frame_origin() const {
  const ::TSP::Point* p = stroke_points_frame_origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& PencilAnnotationStorageArchive::stroke_points_frame_origin() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.stroke_points_frame_origin)
  return _internal_stroke_points_frame_origin();
}
inline void PencilAnnotationStorageArchive::unsafe_arena_set_allocated_stroke_points_frame_origin(
    ::TSP::Point* stroke_points_frame_origin) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_points_frame_origin_);
  }
  stroke_points_frame_origin_ = stroke_points_frame_origin;
  if (stroke_points_frame_origin) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationStorageArchive.stroke_points_frame_origin)
}
inline ::TSP::Point* PencilAnnotationStorageArchive::release_stroke_points_frame_origin() {
  _has_bits_[0] &= ~0x00000400u;
  ::TSP::Point* temp = stroke_points_frame_origin_;
  stroke_points_frame_origin_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Point* PencilAnnotationStorageArchive::unsafe_arena_release_stroke_points_frame_origin() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationStorageArchive.stroke_points_frame_origin)
  _has_bits_[0] &= ~0x00000400u;
  ::TSP::Point* temp = stroke_points_frame_origin_;
  stroke_points_frame_origin_ = nullptr;
  return temp;
}
inline ::TSP::Point* PencilAnnotationStorageArchive::_internal_mutable_stroke_points_frame_origin() {
  _has_bits_[0] |= 0x00000400u;
  if (stroke_points_frame_origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArena());
    stroke_points_frame_origin_ = p;
  }
  return stroke_points_frame_origin_;
}
inline ::TSP::Point* PencilAnnotationStorageArchive::mutable_stroke_points_frame_origin() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.stroke_points_frame_origin)
  return _internal_mutable_stroke_points_frame_origin();
}
inline void PencilAnnotationStorageArchive::set_allocated_stroke_points_frame_origin(::TSP::Point* stroke_points_frame_origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_points_frame_origin_);
  }
  if (stroke_points_frame_origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_points_frame_origin)->GetArena();
    if (message_arena != submessage_arena) {
      stroke_points_frame_origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stroke_points_frame_origin, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  stroke_points_frame_origin_ = stroke_points_frame_origin;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationStorageArchive.stroke_points_frame_origin)
}

// optional .TSP.Size stroke_points_frame_size = 22;
inline bool PencilAnnotationStorageArchive::_internal_has_stroke_points_frame_size() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || stroke_points_frame_size_ != nullptr);
  return value;
}
inline bool PencilAnnotationStorageArchive::has_stroke_points_frame_size() const {
  return _internal_has_stroke_points_frame_size();
}
inline const ::TSP::Size& PencilAnnotationStorageArchive::_internal_stroke_points_frame_size() const {
  const ::TSP::Size* p = stroke_points_frame_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& PencilAnnotationStorageArchive::stroke_points_frame_size() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.stroke_points_frame_size)
  return _internal_stroke_points_frame_size();
}
inline void PencilAnnotationStorageArchive::unsafe_arena_set_allocated_stroke_points_frame_size(
    ::TSP::Size* stroke_points_frame_size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_points_frame_size_);
  }
  stroke_points_frame_size_ = stroke_points_frame_size;
  if (stroke_points_frame_size) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationStorageArchive.stroke_points_frame_size)
}
inline ::TSP::Size* PencilAnnotationStorageArchive::release_stroke_points_frame_size() {
  _has_bits_[0] &= ~0x00000800u;
  ::TSP::Size* temp = stroke_points_frame_size_;
  stroke_points_frame_size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* PencilAnnotationStorageArchive::unsafe_arena_release_stroke_points_frame_size() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationStorageArchive.stroke_points_frame_size)
  _has_bits_[0] &= ~0x00000800u;
  ::TSP::Size* temp = stroke_points_frame_size_;
  stroke_points_frame_size_ = nullptr;
  return temp;
}
inline ::TSP::Size* PencilAnnotationStorageArchive::_internal_mutable_stroke_points_frame_size() {
  _has_bits_[0] |= 0x00000800u;
  if (stroke_points_frame_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    stroke_points_frame_size_ = p;
  }
  return stroke_points_frame_size_;
}
inline ::TSP::Size* PencilAnnotationStorageArchive::mutable_stroke_points_frame_size() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.stroke_points_frame_size)
  return _internal_mutable_stroke_points_frame_size();
}
inline void PencilAnnotationStorageArchive::set_allocated_stroke_points_frame_size(::TSP::Size* stroke_points_frame_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_points_frame_size_);
  }
  if (stroke_points_frame_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_points_frame_size)->GetArena();
    if (message_arena != submessage_arena) {
      stroke_points_frame_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stroke_points_frame_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  stroke_points_frame_size_ = stroke_points_frame_size;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationStorageArchive.stroke_points_frame_size)
}

// optional .TSP.Point rendered_frame_origin = 23;
inline bool PencilAnnotationStorageArchive::_internal_has_rendered_frame_origin() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || rendered_frame_origin_ != nullptr);
  return value;
}
inline bool PencilAnnotationStorageArchive::has_rendered_frame_origin() const {
  return _internal_has_rendered_frame_origin();
}
inline const ::TSP::Point& PencilAnnotationStorageArchive::_internal_rendered_frame_origin() const {
  const ::TSP::Point* p = rendered_frame_origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& PencilAnnotationStorageArchive::rendered_frame_origin() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.rendered_frame_origin)
  return _internal_rendered_frame_origin();
}
inline void PencilAnnotationStorageArchive::unsafe_arena_set_allocated_rendered_frame_origin(
    ::TSP::Point* rendered_frame_origin) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rendered_frame_origin_);
  }
  rendered_frame_origin_ = rendered_frame_origin;
  if (rendered_frame_origin) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationStorageArchive.rendered_frame_origin)
}
inline ::TSP::Point* PencilAnnotationStorageArchive::release_rendered_frame_origin() {
  _has_bits_[0] &= ~0x00001000u;
  ::TSP::Point* temp = rendered_frame_origin_;
  rendered_frame_origin_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Point* PencilAnnotationStorageArchive::unsafe_arena_release_rendered_frame_origin() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationStorageArchive.rendered_frame_origin)
  _has_bits_[0] &= ~0x00001000u;
  ::TSP::Point* temp = rendered_frame_origin_;
  rendered_frame_origin_ = nullptr;
  return temp;
}
inline ::TSP::Point* PencilAnnotationStorageArchive::_internal_mutable_rendered_frame_origin() {
  _has_bits_[0] |= 0x00001000u;
  if (rendered_frame_origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArena());
    rendered_frame_origin_ = p;
  }
  return rendered_frame_origin_;
}
inline ::TSP::Point* PencilAnnotationStorageArchive::mutable_rendered_frame_origin() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.rendered_frame_origin)
  return _internal_mutable_rendered_frame_origin();
}
inline void PencilAnnotationStorageArchive::set_allocated_rendered_frame_origin(::TSP::Point* rendered_frame_origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(rendered_frame_origin_);
  }
  if (rendered_frame_origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rendered_frame_origin)->GetArena();
    if (message_arena != submessage_arena) {
      rendered_frame_origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rendered_frame_origin, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  rendered_frame_origin_ = rendered_frame_origin;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationStorageArchive.rendered_frame_origin)
}

// optional .TSP.Size rendered_frame_size = 24;
inline bool PencilAnnotationStorageArchive::_internal_has_rendered_frame_size() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || rendered_frame_size_ != nullptr);
  return value;
}
inline bool PencilAnnotationStorageArchive::has_rendered_frame_size() const {
  return _internal_has_rendered_frame_size();
}
inline const ::TSP::Size& PencilAnnotationStorageArchive::_internal_rendered_frame_size() const {
  const ::TSP::Size* p = rendered_frame_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& PencilAnnotationStorageArchive::rendered_frame_size() const {
  // @@protoc_insertion_point(field_get:TSD.PencilAnnotationStorageArchive.rendered_frame_size)
  return _internal_rendered_frame_size();
}
inline void PencilAnnotationStorageArchive::unsafe_arena_set_allocated_rendered_frame_size(
    ::TSP::Size* rendered_frame_size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rendered_frame_size_);
  }
  rendered_frame_size_ = rendered_frame_size;
  if (rendered_frame_size) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PencilAnnotationStorageArchive.rendered_frame_size)
}
inline ::TSP::Size* PencilAnnotationStorageArchive::release_rendered_frame_size() {
  _has_bits_[0] &= ~0x00002000u;
  ::TSP::Size* temp = rendered_frame_size_;
  rendered_frame_size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* PencilAnnotationStorageArchive::unsafe_arena_release_rendered_frame_size() {
  // @@protoc_insertion_point(field_release:TSD.PencilAnnotationStorageArchive.rendered_frame_size)
  _has_bits_[0] &= ~0x00002000u;
  ::TSP::Size* temp = rendered_frame_size_;
  rendered_frame_size_ = nullptr;
  return temp;
}
inline ::TSP::Size* PencilAnnotationStorageArchive::_internal_mutable_rendered_frame_size() {
  _has_bits_[0] |= 0x00002000u;
  if (rendered_frame_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    rendered_frame_size_ = p;
  }
  return rendered_frame_size_;
}
inline ::TSP::Size* PencilAnnotationStorageArchive::mutable_rendered_frame_size() {
  // @@protoc_insertion_point(field_mutable:TSD.PencilAnnotationStorageArchive.rendered_frame_size)
  return _internal_mutable_rendered_frame_size();
}
inline void PencilAnnotationStorageArchive::set_allocated_rendered_frame_size(::TSP::Size* rendered_frame_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(rendered_frame_size_);
  }
  if (rendered_frame_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rendered_frame_size)->GetArena();
    if (message_arena != submessage_arena) {
      rendered_frame_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rendered_frame_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  rendered_frame_size_ = rendered_frame_size;
  // @@protoc_insertion_point(field_set_allocated:TSD.PencilAnnotationStorageArchive.rendered_frame_size)
}

// -------------------------------------------------------------------

// SpecColorFillSetColorArchive

// required .TSP.Color color = 1;
inline bool SpecColorFillSetColorArchive::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || color_ != nullptr);
  return value;
}
inline bool SpecColorFillSetColorArchive::has_color() const {
  return _internal_has_color();
}
inline const ::TSP::Color& SpecColorFillSetColorArchive::_internal_color() const {
  const ::TSP::Color* p = color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& SpecColorFillSetColorArchive::color() const {
  // @@protoc_insertion_point(field_get:TSD.SpecColorFillSetColorArchive.color)
  return _internal_color();
}
inline void SpecColorFillSetColorArchive::unsafe_arena_set_allocated_color(
    ::TSP::Color* color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  color_ = color;
  if (color) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.SpecColorFillSetColorArchive.color)
}
inline ::TSP::Color* SpecColorFillSetColorArchive::release_color() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* SpecColorFillSetColorArchive::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:TSD.SpecColorFillSetColorArchive.color)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::TSP::Color* SpecColorFillSetColorArchive::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000001u;
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    color_ = p;
  }
  return color_;
}
inline ::TSP::Color* SpecColorFillSetColorArchive::mutable_color() {
  // @@protoc_insertion_point(field_mutable:TSD.SpecColorFillSetColorArchive.color)
  return _internal_mutable_color();
}
inline void SpecColorFillSetColorArchive::set_allocated_color(::TSP::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color)->GetArena();
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:TSD.SpecColorFillSetColorArchive.color)
}

// -------------------------------------------------------------------

// SpecFrameSetAssetScaleArchive

// required double asset_scale = 1;
inline bool SpecFrameSetAssetScaleArchive::_internal_has_asset_scale() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpecFrameSetAssetScaleArchive::has_asset_scale() const {
  return _internal_has_asset_scale();
}
inline void SpecFrameSetAssetScaleArchive::clear_asset_scale() {
  asset_scale_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double SpecFrameSetAssetScaleArchive::_internal_asset_scale() const {
  return asset_scale_;
}
inline double SpecFrameSetAssetScaleArchive::asset_scale() const {
  // @@protoc_insertion_point(field_get:TSD.SpecFrameSetAssetScaleArchive.asset_scale)
  return _internal_asset_scale();
}
inline void SpecFrameSetAssetScaleArchive::_internal_set_asset_scale(double value) {
  _has_bits_[0] |= 0x00000001u;
  asset_scale_ = value;
}
inline void SpecFrameSetAssetScaleArchive::set_asset_scale(double value) {
  _internal_set_asset_scale(value);
  // @@protoc_insertion_point(field_set:TSD.SpecFrameSetAssetScaleArchive.asset_scale)
}

// -------------------------------------------------------------------

// SpecGradientFillSetAngleArchive

// required double angle = 1;
inline bool SpecGradientFillSetAngleArchive::_internal_has_angle() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpecGradientFillSetAngleArchive::has_angle() const {
  return _internal_has_angle();
}
inline void SpecGradientFillSetAngleArchive::clear_angle() {
  angle_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double SpecGradientFillSetAngleArchive::_internal_angle() const {
  return angle_;
}
inline double SpecGradientFillSetAngleArchive::angle() const {
  // @@protoc_insertion_point(field_get:TSD.SpecGradientFillSetAngleArchive.angle)
  return _internal_angle();
}
inline void SpecGradientFillSetAngleArchive::_internal_set_angle(double value) {
  _has_bits_[0] |= 0x00000001u;
  angle_ = value;
}
inline void SpecGradientFillSetAngleArchive::set_angle(double value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:TSD.SpecGradientFillSetAngleArchive.angle)
}

// -------------------------------------------------------------------

// SpecImageFillSetTechniqueArchive

// required int32 technique = 1;
inline bool SpecImageFillSetTechniqueArchive::_internal_has_technique() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpecImageFillSetTechniqueArchive::has_technique() const {
  return _internal_has_technique();
}
inline void SpecImageFillSetTechniqueArchive::clear_technique() {
  technique_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpecImageFillSetTechniqueArchive::_internal_technique() const {
  return technique_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpecImageFillSetTechniqueArchive::technique() const {
  // @@protoc_insertion_point(field_get:TSD.SpecImageFillSetTechniqueArchive.technique)
  return _internal_technique();
}
inline void SpecImageFillSetTechniqueArchive::_internal_set_technique(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  technique_ = value;
}
inline void SpecImageFillSetTechniqueArchive::set_technique(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_technique(value);
  // @@protoc_insertion_point(field_set:TSD.SpecImageFillSetTechniqueArchive.technique)
}

// -------------------------------------------------------------------

// SpecReflectionSetOpacityArchive

// required double opacity = 1;
inline bool SpecReflectionSetOpacityArchive::_internal_has_opacity() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpecReflectionSetOpacityArchive::has_opacity() const {
  return _internal_has_opacity();
}
inline void SpecReflectionSetOpacityArchive::clear_opacity() {
  opacity_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double SpecReflectionSetOpacityArchive::_internal_opacity() const {
  return opacity_;
}
inline double SpecReflectionSetOpacityArchive::opacity() const {
  // @@protoc_insertion_point(field_get:TSD.SpecReflectionSetOpacityArchive.opacity)
  return _internal_opacity();
}
inline void SpecReflectionSetOpacityArchive::_internal_set_opacity(double value) {
  _has_bits_[0] |= 0x00000001u;
  opacity_ = value;
}
inline void SpecReflectionSetOpacityArchive::set_opacity(double value) {
  _internal_set_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.SpecReflectionSetOpacityArchive.opacity)
}

// -------------------------------------------------------------------

// SpecShadowSetAngleArchive

// required double angle = 1;
inline bool SpecShadowSetAngleArchive::_internal_has_angle() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpecShadowSetAngleArchive::has_angle() const {
  return _internal_has_angle();
}
inline void SpecShadowSetAngleArchive::clear_angle() {
  angle_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double SpecShadowSetAngleArchive::_internal_angle() const {
  return angle_;
}
inline double SpecShadowSetAngleArchive::angle() const {
  // @@protoc_insertion_point(field_get:TSD.SpecShadowSetAngleArchive.angle)
  return _internal_angle();
}
inline void SpecShadowSetAngleArchive::_internal_set_angle(double value) {
  _has_bits_[0] |= 0x00000001u;
  angle_ = value;
}
inline void SpecShadowSetAngleArchive::set_angle(double value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:TSD.SpecShadowSetAngleArchive.angle)
}

// -------------------------------------------------------------------

// SpecShadowSetColorArchive

// required .TSP.Color color = 1;
inline bool SpecShadowSetColorArchive::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || color_ != nullptr);
  return value;
}
inline bool SpecShadowSetColorArchive::has_color() const {
  return _internal_has_color();
}
inline const ::TSP::Color& SpecShadowSetColorArchive::_internal_color() const {
  const ::TSP::Color* p = color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& SpecShadowSetColorArchive::color() const {
  // @@protoc_insertion_point(field_get:TSD.SpecShadowSetColorArchive.color)
  return _internal_color();
}
inline void SpecShadowSetColorArchive::unsafe_arena_set_allocated_color(
    ::TSP::Color* color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  color_ = color;
  if (color) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.SpecShadowSetColorArchive.color)
}
inline ::TSP::Color* SpecShadowSetColorArchive::release_color() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* SpecShadowSetColorArchive::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:TSD.SpecShadowSetColorArchive.color)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::TSP::Color* SpecShadowSetColorArchive::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000001u;
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    color_ = p;
  }
  return color_;
}
inline ::TSP::Color* SpecShadowSetColorArchive::mutable_color() {
  // @@protoc_insertion_point(field_mutable:TSD.SpecShadowSetColorArchive.color)
  return _internal_mutable_color();
}
inline void SpecShadowSetColorArchive::set_allocated_color(::TSP::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color)->GetArena();
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:TSD.SpecShadowSetColorArchive.color)
}

// -------------------------------------------------------------------

// SpecShadowSetOffsetArchive

// required double offset = 1;
inline bool SpecShadowSetOffsetArchive::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpecShadowSetOffsetArchive::has_offset() const {
  return _internal_has_offset();
}
inline void SpecShadowSetOffsetArchive::clear_offset() {
  offset_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double SpecShadowSetOffsetArchive::_internal_offset() const {
  return offset_;
}
inline double SpecShadowSetOffsetArchive::offset() const {
  // @@protoc_insertion_point(field_get:TSD.SpecShadowSetOffsetArchive.offset)
  return _internal_offset();
}
inline void SpecShadowSetOffsetArchive::_internal_set_offset(double value) {
  _has_bits_[0] |= 0x00000001u;
  offset_ = value;
}
inline void SpecShadowSetOffsetArchive::set_offset(double value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:TSD.SpecShadowSetOffsetArchive.offset)
}

// -------------------------------------------------------------------

// SpecShadowSetOpacityArchive

// required double opacity = 1;
inline bool SpecShadowSetOpacityArchive::_internal_has_opacity() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpecShadowSetOpacityArchive::has_opacity() const {
  return _internal_has_opacity();
}
inline void SpecShadowSetOpacityArchive::clear_opacity() {
  opacity_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double SpecShadowSetOpacityArchive::_internal_opacity() const {
  return opacity_;
}
inline double SpecShadowSetOpacityArchive::opacity() const {
  // @@protoc_insertion_point(field_get:TSD.SpecShadowSetOpacityArchive.opacity)
  return _internal_opacity();
}
inline void SpecShadowSetOpacityArchive::_internal_set_opacity(double value) {
  _has_bits_[0] |= 0x00000001u;
  opacity_ = value;
}
inline void SpecShadowSetOpacityArchive::set_opacity(double value) {
  _internal_set_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.SpecShadowSetOpacityArchive.opacity)
}

// -------------------------------------------------------------------

// SpecShadowSetRadiusArchive

// required int32 radius = 1;
inline bool SpecShadowSetRadiusArchive::_internal_has_radius() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpecShadowSetRadiusArchive::has_radius() const {
  return _internal_has_radius();
}
inline void SpecShadowSetRadiusArchive::clear_radius() {
  radius_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpecShadowSetRadiusArchive::_internal_radius() const {
  return radius_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpecShadowSetRadiusArchive::radius() const {
  // @@protoc_insertion_point(field_get:TSD.SpecShadowSetRadiusArchive.radius)
  return _internal_radius();
}
inline void SpecShadowSetRadiusArchive::_internal_set_radius(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  radius_ = value;
}
inline void SpecShadowSetRadiusArchive::set_radius(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:TSD.SpecShadowSetRadiusArchive.radius)
}

// -------------------------------------------------------------------

// SpecStrokeSetColorArchive

// required .TSP.Color color = 1;
inline bool SpecStrokeSetColorArchive::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || color_ != nullptr);
  return value;
}
inline bool SpecStrokeSetColorArchive::has_color() const {
  return _internal_has_color();
}
inline const ::TSP::Color& SpecStrokeSetColorArchive::_internal_color() const {
  const ::TSP::Color* p = color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& SpecStrokeSetColorArchive::color() const {
  // @@protoc_insertion_point(field_get:TSD.SpecStrokeSetColorArchive.color)
  return _internal_color();
}
inline void SpecStrokeSetColorArchive::unsafe_arena_set_allocated_color(
    ::TSP::Color* color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  color_ = color;
  if (color) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.SpecStrokeSetColorArchive.color)
}
inline ::TSP::Color* SpecStrokeSetColorArchive::release_color() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* SpecStrokeSetColorArchive::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:TSD.SpecStrokeSetColorArchive.color)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::TSP::Color* SpecStrokeSetColorArchive::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000001u;
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    color_ = p;
  }
  return color_;
}
inline ::TSP::Color* SpecStrokeSetColorArchive::mutable_color() {
  // @@protoc_insertion_point(field_mutable:TSD.SpecStrokeSetColorArchive.color)
  return _internal_mutable_color();
}
inline void SpecStrokeSetColorArchive::set_allocated_color(::TSP::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color)->GetArena();
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:TSD.SpecStrokeSetColorArchive.color)
}

// -------------------------------------------------------------------

// SpecStrokeSetPatternArchive

// optional int32 line_cap = 1;
inline bool SpecStrokeSetPatternArchive::_internal_has_line_cap() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SpecStrokeSetPatternArchive::has_line_cap() const {
  return _internal_has_line_cap();
}
inline void SpecStrokeSetPatternArchive::clear_line_cap() {
  line_cap_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpecStrokeSetPatternArchive::_internal_line_cap() const {
  return line_cap_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpecStrokeSetPatternArchive::line_cap() const {
  // @@protoc_insertion_point(field_get:TSD.SpecStrokeSetPatternArchive.line_cap)
  return _internal_line_cap();
}
inline void SpecStrokeSetPatternArchive::_internal_set_line_cap(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  line_cap_ = value;
}
inline void SpecStrokeSetPatternArchive::set_line_cap(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_line_cap(value);
  // @@protoc_insertion_point(field_set:TSD.SpecStrokeSetPatternArchive.line_cap)
}

// optional int32 line_join = 2;
inline bool SpecStrokeSetPatternArchive::_internal_has_line_join() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SpecStrokeSetPatternArchive::has_line_join() const {
  return _internal_has_line_join();
}
inline void SpecStrokeSetPatternArchive::clear_line_join() {
  line_join_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpecStrokeSetPatternArchive::_internal_line_join() const {
  return line_join_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpecStrokeSetPatternArchive::line_join() const {
  // @@protoc_insertion_point(field_get:TSD.SpecStrokeSetPatternArchive.line_join)
  return _internal_line_join();
}
inline void SpecStrokeSetPatternArchive::_internal_set_line_join(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  line_join_ = value;
}
inline void SpecStrokeSetPatternArchive::set_line_join(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_line_join(value);
  // @@protoc_insertion_point(field_set:TSD.SpecStrokeSetPatternArchive.line_join)
}

// optional double miter_limit = 3;
inline bool SpecStrokeSetPatternArchive::_internal_has_miter_limit() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SpecStrokeSetPatternArchive::has_miter_limit() const {
  return _internal_has_miter_limit();
}
inline void SpecStrokeSetPatternArchive::clear_miter_limit() {
  miter_limit_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double SpecStrokeSetPatternArchive::_internal_miter_limit() const {
  return miter_limit_;
}
inline double SpecStrokeSetPatternArchive::miter_limit() const {
  // @@protoc_insertion_point(field_get:TSD.SpecStrokeSetPatternArchive.miter_limit)
  return _internal_miter_limit();
}
inline void SpecStrokeSetPatternArchive::_internal_set_miter_limit(double value) {
  _has_bits_[0] |= 0x00000010u;
  miter_limit_ = value;
}
inline void SpecStrokeSetPatternArchive::set_miter_limit(double value) {
  _internal_set_miter_limit(value);
  // @@protoc_insertion_point(field_set:TSD.SpecStrokeSetPatternArchive.miter_limit)
}

// optional double width = 4;
inline bool SpecStrokeSetPatternArchive::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SpecStrokeSetPatternArchive::has_width() const {
  return _internal_has_width();
}
inline void SpecStrokeSetPatternArchive::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double SpecStrokeSetPatternArchive::_internal_width() const {
  return width_;
}
inline double SpecStrokeSetPatternArchive::width() const {
  // @@protoc_insertion_point(field_get:TSD.SpecStrokeSetPatternArchive.width)
  return _internal_width();
}
inline void SpecStrokeSetPatternArchive::_internal_set_width(double value) {
  _has_bits_[0] |= 0x00000020u;
  width_ = value;
}
inline void SpecStrokeSetPatternArchive::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:TSD.SpecStrokeSetPatternArchive.width)
}

// optional .TSP.Color color = 5;
inline bool SpecStrokeSetPatternArchive::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || color_ != nullptr);
  return value;
}
inline bool SpecStrokeSetPatternArchive::has_color() const {
  return _internal_has_color();
}
inline const ::TSP::Color& SpecStrokeSetPatternArchive::_internal_color() const {
  const ::TSP::Color* p = color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& SpecStrokeSetPatternArchive::color() const {
  // @@protoc_insertion_point(field_get:TSD.SpecStrokeSetPatternArchive.color)
  return _internal_color();
}
inline void SpecStrokeSetPatternArchive::unsafe_arena_set_allocated_color(
    ::TSP::Color* color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  color_ = color;
  if (color) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.SpecStrokeSetPatternArchive.color)
}
inline ::TSP::Color* SpecStrokeSetPatternArchive::release_color() {
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Color* SpecStrokeSetPatternArchive::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:TSD.SpecStrokeSetPatternArchive.color)
  _has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::TSP::Color* SpecStrokeSetPatternArchive::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000001u;
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArena());
    color_ = p;
  }
  return color_;
}
inline ::TSP::Color* SpecStrokeSetPatternArchive::mutable_color() {
  // @@protoc_insertion_point(field_mutable:TSD.SpecStrokeSetPatternArchive.color)
  return _internal_mutable_color();
}
inline void SpecStrokeSetPatternArchive::set_allocated_color(::TSP::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color)->GetArena();
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:TSD.SpecStrokeSetPatternArchive.color)
}

// required .TSD.StrokePatternArchive pattern = 6;
inline bool SpecStrokeSetPatternArchive::_internal_has_pattern() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || pattern_ != nullptr);
  return value;
}
inline bool SpecStrokeSetPatternArchive::has_pattern() const {
  return _internal_has_pattern();
}
inline void SpecStrokeSetPatternArchive::clear_pattern() {
  if (pattern_ != nullptr) pattern_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::StrokePatternArchive& SpecStrokeSetPatternArchive::_internal_pattern() const {
  const ::TSD::StrokePatternArchive* p = pattern_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::StrokePatternArchive&>(
      ::TSD::_StrokePatternArchive_default_instance_);
}
inline const ::TSD::StrokePatternArchive& SpecStrokeSetPatternArchive::pattern() const {
  // @@protoc_insertion_point(field_get:TSD.SpecStrokeSetPatternArchive.pattern)
  return _internal_pattern();
}
inline void SpecStrokeSetPatternArchive::unsafe_arena_set_allocated_pattern(
    ::TSD::StrokePatternArchive* pattern) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pattern_);
  }
  pattern_ = pattern;
  if (pattern) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.SpecStrokeSetPatternArchive.pattern)
}
inline ::TSD::StrokePatternArchive* SpecStrokeSetPatternArchive::release_pattern() {
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::StrokePatternArchive* temp = pattern_;
  pattern_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSD::StrokePatternArchive* SpecStrokeSetPatternArchive::unsafe_arena_release_pattern() {
  // @@protoc_insertion_point(field_release:TSD.SpecStrokeSetPatternArchive.pattern)
  _has_bits_[0] &= ~0x00000002u;
  ::TSD::StrokePatternArchive* temp = pattern_;
  pattern_ = nullptr;
  return temp;
}
inline ::TSD::StrokePatternArchive* SpecStrokeSetPatternArchive::_internal_mutable_pattern() {
  _has_bits_[0] |= 0x00000002u;
  if (pattern_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::StrokePatternArchive>(GetArena());
    pattern_ = p;
  }
  return pattern_;
}
inline ::TSD::StrokePatternArchive* SpecStrokeSetPatternArchive::mutable_pattern() {
  // @@protoc_insertion_point(field_mutable:TSD.SpecStrokeSetPatternArchive.pattern)
  return _internal_mutable_pattern();
}
inline void SpecStrokeSetPatternArchive::set_allocated_pattern(::TSD::StrokePatternArchive* pattern) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pattern_;
  }
  if (pattern) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pattern);
    if (message_arena != submessage_arena) {
      pattern = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pattern, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pattern_ = pattern;
  // @@protoc_insertion_point(field_set_allocated:TSD.SpecStrokeSetPatternArchive.pattern)
}

// -------------------------------------------------------------------

// SpecStrokeSetWidthArchive

// required double width = 1;
inline bool SpecStrokeSetWidthArchive::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpecStrokeSetWidthArchive::has_width() const {
  return _internal_has_width();
}
inline void SpecStrokeSetWidthArchive::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double SpecStrokeSetWidthArchive::_internal_width() const {
  return width_;
}
inline double SpecStrokeSetWidthArchive::width() const {
  // @@protoc_insertion_point(field_get:TSD.SpecStrokeSetWidthArchive.width)
  return _internal_width();
}
inline void SpecStrokeSetWidthArchive::_internal_set_width(double value) {
  _has_bits_[0] |= 0x00000001u;
  width_ = value;
}
inline void SpecStrokeSetWidthArchive::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:TSD.SpecStrokeSetWidthArchive.width)
}

// -------------------------------------------------------------------

// Attribution

// optional string title = 1;
inline bool Attribution::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Attribution::has_title() const {
  return _internal_has_title();
}
inline void Attribution::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Attribution::title() const {
  // @@protoc_insertion_point(field_get:TSD.Attribution.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Attribution::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.Attribution.title)
}
inline std::string* Attribution::mutable_title() {
  // @@protoc_insertion_point(field_mutable:TSD.Attribution.title)
  return _internal_mutable_title();
}
inline const std::string& Attribution::_internal_title() const {
  return title_.Get();
}
inline void Attribution::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Attribution::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Attribution::release_title() {
  // @@protoc_insertion_point(field_release:TSD.Attribution.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return title_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Attribution::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.Attribution.title)
}

// optional string description_text = 2;
inline bool Attribution::_internal_has_description_text() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Attribution::has_description_text() const {
  return _internal_has_description_text();
}
inline void Attribution::clear_description_text() {
  description_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Attribution::description_text() const {
  // @@protoc_insertion_point(field_get:TSD.Attribution.description_text)
  return _internal_description_text();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Attribution::set_description_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 description_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.Attribution.description_text)
}
inline std::string* Attribution::mutable_description_text() {
  // @@protoc_insertion_point(field_mutable:TSD.Attribution.description_text)
  return _internal_mutable_description_text();
}
inline const std::string& Attribution::_internal_description_text() const {
  return description_text_.Get();
}
inline void Attribution::_internal_set_description_text(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  description_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Attribution::_internal_mutable_description_text() {
  _has_bits_[0] |= 0x00000002u;
  return description_text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Attribution::release_description_text() {
  // @@protoc_insertion_point(field_release:TSD.Attribution.description_text)
  if (!_internal_has_description_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return description_text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Attribution::set_allocated_description_text(std::string* description_text) {
  if (description_text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  description_text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description_text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.Attribution.description_text)
}

// optional string external_url = 3;
inline bool Attribution::_internal_has_external_url() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Attribution::has_external_url() const {
  return _internal_has_external_url();
}
inline void Attribution::clear_external_url() {
  external_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Attribution::external_url() const {
  // @@protoc_insertion_point(field_get:TSD.Attribution.external_url)
  return _internal_external_url();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Attribution::set_external_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 external_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.Attribution.external_url)
}
inline std::string* Attribution::mutable_external_url() {
  // @@protoc_insertion_point(field_mutable:TSD.Attribution.external_url)
  return _internal_mutable_external_url();
}
inline const std::string& Attribution::_internal_external_url() const {
  return external_url_.Get();
}
inline void Attribution::_internal_set_external_url(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  external_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Attribution::_internal_mutable_external_url() {
  _has_bits_[0] |= 0x00000004u;
  return external_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Attribution::release_external_url() {
  // @@protoc_insertion_point(field_release:TSD.Attribution.external_url)
  if (!_internal_has_external_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return external_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Attribution::set_allocated_external_url(std::string* external_url) {
  if (external_url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  external_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), external_url,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.Attribution.external_url)
}

// optional string author_name = 4;
inline bool Attribution::_internal_has_author_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Attribution::has_author_name() const {
  return _internal_has_author_name();
}
inline void Attribution::clear_author_name() {
  author_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Attribution::author_name() const {
  // @@protoc_insertion_point(field_get:TSD.Attribution.author_name)
  return _internal_author_name();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Attribution::set_author_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 author_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.Attribution.author_name)
}
inline std::string* Attribution::mutable_author_name() {
  // @@protoc_insertion_point(field_mutable:TSD.Attribution.author_name)
  return _internal_mutable_author_name();
}
inline const std::string& Attribution::_internal_author_name() const {
  return author_name_.Get();
}
inline void Attribution::_internal_set_author_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  author_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Attribution::_internal_mutable_author_name() {
  _has_bits_[0] |= 0x00000008u;
  return author_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Attribution::release_author_name() {
  // @@protoc_insertion_point(field_release:TSD.Attribution.author_name)
  if (!_internal_has_author_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return author_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Attribution::set_allocated_author_name(std::string* author_name) {
  if (author_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  author_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), author_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.Attribution.author_name)
}

// optional string author_url = 5;
inline bool Attribution::_internal_has_author_url() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Attribution::has_author_url() const {
  return _internal_has_author_url();
}
inline void Attribution::clear_author_url() {
  author_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Attribution::author_url() const {
  // @@protoc_insertion_point(field_get:TSD.Attribution.author_url)
  return _internal_author_url();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Attribution::set_author_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 author_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.Attribution.author_url)
}
inline std::string* Attribution::mutable_author_url() {
  // @@protoc_insertion_point(field_mutable:TSD.Attribution.author_url)
  return _internal_mutable_author_url();
}
inline const std::string& Attribution::_internal_author_url() const {
  return author_url_.Get();
}
inline void Attribution::_internal_set_author_url(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  author_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Attribution::_internal_mutable_author_url() {
  _has_bits_[0] |= 0x00000010u;
  return author_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Attribution::release_author_url() {
  // @@protoc_insertion_point(field_release:TSD.Attribution.author_url)
  if (!_internal_has_author_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return author_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Attribution::set_allocated_author_url(std::string* author_url) {
  if (author_url != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  author_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), author_url,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.Attribution.author_url)
}

// -------------------------------------------------------------------

// MovieFingerprint

// repeated .TSD.MovieFingerprintTrack tracks = 1;
inline int MovieFingerprint::_internal_tracks_size() const {
  return tracks_.size();
}
inline int MovieFingerprint::tracks_size() const {
  return _internal_tracks_size();
}
inline void MovieFingerprint::clear_tracks() {
  tracks_.Clear();
}
inline ::TSD::MovieFingerprintTrack* MovieFingerprint::mutable_tracks(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.MovieFingerprint.tracks)
  return tracks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::MovieFingerprintTrack >*
MovieFingerprint::mutable_tracks() {
  // @@protoc_insertion_point(field_mutable_list:TSD.MovieFingerprint.tracks)
  return &tracks_;
}
inline const ::TSD::MovieFingerprintTrack& MovieFingerprint::_internal_tracks(int index) const {
  return tracks_.Get(index);
}
inline const ::TSD::MovieFingerprintTrack& MovieFingerprint::tracks(int index) const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprint.tracks)
  return _internal_tracks(index);
}
inline ::TSD::MovieFingerprintTrack* MovieFingerprint::_internal_add_tracks() {
  return tracks_.Add();
}
inline ::TSD::MovieFingerprintTrack* MovieFingerprint::add_tracks() {
  // @@protoc_insertion_point(field_add:TSD.MovieFingerprint.tracks)
  return _internal_add_tracks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::MovieFingerprintTrack >&
MovieFingerprint::tracks() const {
  // @@protoc_insertion_point(field_list:TSD.MovieFingerprint.tracks)
  return tracks_;
}

// repeated uint32 version = 2 [packed = true];
inline int MovieFingerprint::_internal_version_size() const {
  return version_.size();
}
inline int MovieFingerprint::version_size() const {
  return _internal_version_size();
}
inline void MovieFingerprint::clear_version() {
  version_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MovieFingerprint::_internal_version(int index) const {
  return version_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MovieFingerprint::version(int index) const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprint.version)
  return _internal_version(index);
}
inline void MovieFingerprint::set_version(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  version_.Set(index, value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprint.version)
}
inline void MovieFingerprint::_internal_add_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  version_.Add(value);
}
inline void MovieFingerprint::add_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_version(value);
  // @@protoc_insertion_point(field_add:TSD.MovieFingerprint.version)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
MovieFingerprint::_internal_version() const {
  return version_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
MovieFingerprint::version() const {
  // @@protoc_insertion_point(field_list:TSD.MovieFingerprint.version)
  return _internal_version();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
MovieFingerprint::_internal_mutable_version() {
  return &version_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
MovieFingerprint::mutable_version() {
  // @@protoc_insertion_point(field_mutable_list:TSD.MovieFingerprint.version)
  return _internal_mutable_version();
}

// -------------------------------------------------------------------

// MovieFingerprintTrack

// optional string media_type = 1;
inline bool MovieFingerprintTrack::_internal_has_media_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_media_type() const {
  return _internal_has_media_type();
}
inline void MovieFingerprintTrack::clear_media_type() {
  media_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MovieFingerprintTrack::media_type() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.media_type)
  return _internal_media_type();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void MovieFingerprintTrack::set_media_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 media_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.media_type)
}
inline std::string* MovieFingerprintTrack::mutable_media_type() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieFingerprintTrack.media_type)
  return _internal_mutable_media_type();
}
inline const std::string& MovieFingerprintTrack::_internal_media_type() const {
  return media_type_.Get();
}
inline void MovieFingerprintTrack::_internal_set_media_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  media_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* MovieFingerprintTrack::_internal_mutable_media_type() {
  _has_bits_[0] |= 0x00000001u;
  return media_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MovieFingerprintTrack::release_media_type() {
  // @@protoc_insertion_point(field_release:TSD.MovieFingerprintTrack.media_type)
  if (!_internal_has_media_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return media_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MovieFingerprintTrack::set_allocated_media_type(std::string* media_type) {
  if (media_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  media_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), media_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieFingerprintTrack.media_type)
}

// optional bool enabled = 2;
inline bool MovieFingerprintTrack::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_enabled() const {
  return _internal_has_enabled();
}
inline void MovieFingerprintTrack::clear_enabled() {
  enabled_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool MovieFingerprintTrack::_internal_enabled() const {
  return enabled_;
}
inline bool MovieFingerprintTrack::enabled() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.enabled)
  return _internal_enabled();
}
inline void MovieFingerprintTrack::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000100u;
  enabled_ = value;
}
inline void MovieFingerprintTrack::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.enabled)
}

// optional int64 total_sample_data_length = 3;
inline bool MovieFingerprintTrack::_internal_has_total_sample_data_length() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_total_sample_data_length() const {
  return _internal_has_total_sample_data_length();
}
inline void MovieFingerprintTrack::clear_total_sample_data_length() {
  total_sample_data_length_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MovieFingerprintTrack::_internal_total_sample_data_length() const {
  return total_sample_data_length_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MovieFingerprintTrack::total_sample_data_length() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.total_sample_data_length)
  return _internal_total_sample_data_length();
}
inline void MovieFingerprintTrack::_internal_set_total_sample_data_length(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  total_sample_data_length_ = value;
}
inline void MovieFingerprintTrack::set_total_sample_data_length(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_total_sample_data_length(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.total_sample_data_length)
}

// optional string sample_data_digest_string = 4;
inline bool MovieFingerprintTrack::_internal_has_sample_data_digest_string() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_sample_data_digest_string() const {
  return _internal_has_sample_data_digest_string();
}
inline void MovieFingerprintTrack::clear_sample_data_digest_string() {
  sample_data_digest_string_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MovieFingerprintTrack::sample_data_digest_string() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.sample_data_digest_string)
  return _internal_sample_data_digest_string();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void MovieFingerprintTrack::set_sample_data_digest_string(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 sample_data_digest_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.sample_data_digest_string)
}
inline std::string* MovieFingerprintTrack::mutable_sample_data_digest_string() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieFingerprintTrack.sample_data_digest_string)
  return _internal_mutable_sample_data_digest_string();
}
inline const std::string& MovieFingerprintTrack::_internal_sample_data_digest_string() const {
  return sample_data_digest_string_.Get();
}
inline void MovieFingerprintTrack::_internal_set_sample_data_digest_string(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sample_data_digest_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* MovieFingerprintTrack::_internal_mutable_sample_data_digest_string() {
  _has_bits_[0] |= 0x00000002u;
  return sample_data_digest_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MovieFingerprintTrack::release_sample_data_digest_string() {
  // @@protoc_insertion_point(field_release:TSD.MovieFingerprintTrack.sample_data_digest_string)
  if (!_internal_has_sample_data_digest_string()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return sample_data_digest_string_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MovieFingerprintTrack::set_allocated_sample_data_digest_string(std::string* sample_data_digest_string) {
  if (sample_data_digest_string != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sample_data_digest_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sample_data_digest_string,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieFingerprintTrack.sample_data_digest_string)
}

// optional int64 time_range_start_value = 5;
inline bool MovieFingerprintTrack::_internal_has_time_range_start_value() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_time_range_start_value() const {
  return _internal_has_time_range_start_value();
}
inline void MovieFingerprintTrack::clear_time_range_start_value() {
  time_range_start_value_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MovieFingerprintTrack::_internal_time_range_start_value() const {
  return time_range_start_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MovieFingerprintTrack::time_range_start_value() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.time_range_start_value)
  return _internal_time_range_start_value();
}
inline void MovieFingerprintTrack::_internal_set_time_range_start_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  time_range_start_value_ = value;
}
inline void MovieFingerprintTrack::set_time_range_start_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time_range_start_value(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.time_range_start_value)
}

// optional int32 time_range_start_timescale = 6;
inline bool MovieFingerprintTrack::_internal_has_time_range_start_timescale() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_time_range_start_timescale() const {
  return _internal_has_time_range_start_timescale();
}
inline void MovieFingerprintTrack::clear_time_range_start_timescale() {
  time_range_start_timescale_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MovieFingerprintTrack::_internal_time_range_start_timescale() const {
  return time_range_start_timescale_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MovieFingerprintTrack::time_range_start_timescale() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.time_range_start_timescale)
  return _internal_time_range_start_timescale();
}
inline void MovieFingerprintTrack::_internal_set_time_range_start_timescale(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  time_range_start_timescale_ = value;
}
inline void MovieFingerprintTrack::set_time_range_start_timescale(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_time_range_start_timescale(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.time_range_start_timescale)
}

// optional bool time_range_start_is_valid = 7;
inline bool MovieFingerprintTrack::_internal_has_time_range_start_is_valid() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_time_range_start_is_valid() const {
  return _internal_has_time_range_start_is_valid();
}
inline void MovieFingerprintTrack::clear_time_range_start_is_valid() {
  time_range_start_is_valid_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool MovieFingerprintTrack::_internal_time_range_start_is_valid() const {
  return time_range_start_is_valid_;
}
inline bool MovieFingerprintTrack::time_range_start_is_valid() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.time_range_start_is_valid)
  return _internal_time_range_start_is_valid();
}
inline void MovieFingerprintTrack::_internal_set_time_range_start_is_valid(bool value) {
  _has_bits_[0] |= 0x00000200u;
  time_range_start_is_valid_ = value;
}
inline void MovieFingerprintTrack::set_time_range_start_is_valid(bool value) {
  _internal_set_time_range_start_is_valid(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.time_range_start_is_valid)
}

// optional int64 time_range_duration_value = 8;
inline bool MovieFingerprintTrack::_internal_has_time_range_duration_value() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_time_range_duration_value() const {
  return _internal_has_time_range_duration_value();
}
inline void MovieFingerprintTrack::clear_time_range_duration_value() {
  time_range_duration_value_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MovieFingerprintTrack::_internal_time_range_duration_value() const {
  return time_range_duration_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MovieFingerprintTrack::time_range_duration_value() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.time_range_duration_value)
  return _internal_time_range_duration_value();
}
inline void MovieFingerprintTrack::_internal_set_time_range_duration_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  time_range_duration_value_ = value;
}
inline void MovieFingerprintTrack::set_time_range_duration_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time_range_duration_value(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.time_range_duration_value)
}

// optional int32 time_range_duration_timescale = 9;
inline bool MovieFingerprintTrack::_internal_has_time_range_duration_timescale() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_time_range_duration_timescale() const {
  return _internal_has_time_range_duration_timescale();
}
inline void MovieFingerprintTrack::clear_time_range_duration_timescale() {
  time_range_duration_timescale_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MovieFingerprintTrack::_internal_time_range_duration_timescale() const {
  return time_range_duration_timescale_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MovieFingerprintTrack::time_range_duration_timescale() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.time_range_duration_timescale)
  return _internal_time_range_duration_timescale();
}
inline void MovieFingerprintTrack::_internal_set_time_range_duration_timescale(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00080000u;
  time_range_duration_timescale_ = value;
}
inline void MovieFingerprintTrack::set_time_range_duration_timescale(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_time_range_duration_timescale(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.time_range_duration_timescale)
}

// optional bool time_range_duration_is_valid = 10;
inline bool MovieFingerprintTrack::_internal_has_time_range_duration_is_valid() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_time_range_duration_is_valid() const {
  return _internal_has_time_range_duration_is_valid();
}
inline void MovieFingerprintTrack::clear_time_range_duration_is_valid() {
  time_range_duration_is_valid_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool MovieFingerprintTrack::_internal_time_range_duration_is_valid() const {
  return time_range_duration_is_valid_;
}
inline bool MovieFingerprintTrack::time_range_duration_is_valid() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.time_range_duration_is_valid)
  return _internal_time_range_duration_is_valid();
}
inline void MovieFingerprintTrack::_internal_set_time_range_duration_is_valid(bool value) {
  _has_bits_[0] |= 0x00000400u;
  time_range_duration_is_valid_ = value;
}
inline void MovieFingerprintTrack::set_time_range_duration_is_valid(bool value) {
  _internal_set_time_range_duration_is_valid(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.time_range_duration_is_valid)
}

// optional .TSP.Size natural_size = 11;
inline bool MovieFingerprintTrack::_internal_has_natural_size() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || natural_size_ != nullptr);
  return value;
}
inline bool MovieFingerprintTrack::has_natural_size() const {
  return _internal_has_natural_size();
}
inline const ::TSP::Size& MovieFingerprintTrack::_internal_natural_size() const {
  const ::TSP::Size* p = natural_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& MovieFingerprintTrack::natural_size() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.natural_size)
  return _internal_natural_size();
}
inline void MovieFingerprintTrack::unsafe_arena_set_allocated_natural_size(
    ::TSP::Size* natural_size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(natural_size_);
  }
  natural_size_ = natural_size;
  if (natural_size) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieFingerprintTrack.natural_size)
}
inline ::TSP::Size* MovieFingerprintTrack::release_natural_size() {
  _has_bits_[0] &= ~0x00000010u;
  ::TSP::Size* temp = natural_size_;
  natural_size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TSP::Size* MovieFingerprintTrack::unsafe_arena_release_natural_size() {
  // @@protoc_insertion_point(field_release:TSD.MovieFingerprintTrack.natural_size)
  _has_bits_[0] &= ~0x00000010u;
  ::TSP::Size* temp = natural_size_;
  natural_size_ = nullptr;
  return temp;
}
inline ::TSP::Size* MovieFingerprintTrack::_internal_mutable_natural_size() {
  _has_bits_[0] |= 0x00000010u;
  if (natural_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArena());
    natural_size_ = p;
  }
  return natural_size_;
}
inline ::TSP::Size* MovieFingerprintTrack::mutable_natural_size() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieFingerprintTrack.natural_size)
  return _internal_mutable_natural_size();
}
inline void MovieFingerprintTrack::set_allocated_natural_size(::TSP::Size* natural_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(natural_size_);
  }
  if (natural_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(natural_size)->GetArena();
    if (message_arena != submessage_arena) {
      natural_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, natural_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  natural_size_ = natural_size;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieFingerprintTrack.natural_size)
}

// optional double preferred_transform_a = 12;
inline bool MovieFingerprintTrack::_internal_has_preferred_transform_a() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_preferred_transform_a() const {
  return _internal_has_preferred_transform_a();
}
inline void MovieFingerprintTrack::clear_preferred_transform_a() {
  preferred_transform_a_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline double MovieFingerprintTrack::_internal_preferred_transform_a() const {
  return preferred_transform_a_;
}
inline double MovieFingerprintTrack::preferred_transform_a() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.preferred_transform_a)
  return _internal_preferred_transform_a();
}
inline void MovieFingerprintTrack::_internal_set_preferred_transform_a(double value) {
  _has_bits_[0] |= 0x00001000u;
  preferred_transform_a_ = value;
}
inline void MovieFingerprintTrack::set_preferred_transform_a(double value) {
  _internal_set_preferred_transform_a(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.preferred_transform_a)
}

// optional double preferred_transform_b = 13;
inline bool MovieFingerprintTrack::_internal_has_preferred_transform_b() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_preferred_transform_b() const {
  return _internal_has_preferred_transform_b();
}
inline void MovieFingerprintTrack::clear_preferred_transform_b() {
  preferred_transform_b_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline double MovieFingerprintTrack::_internal_preferred_transform_b() const {
  return preferred_transform_b_;
}
inline double MovieFingerprintTrack::preferred_transform_b() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.preferred_transform_b)
  return _internal_preferred_transform_b();
}
inline void MovieFingerprintTrack::_internal_set_preferred_transform_b(double value) {
  _has_bits_[0] |= 0x00002000u;
  preferred_transform_b_ = value;
}
inline void MovieFingerprintTrack::set_preferred_transform_b(double value) {
  _internal_set_preferred_transform_b(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.preferred_transform_b)
}

// optional double preferred_transform_c = 14;
inline bool MovieFingerprintTrack::_internal_has_preferred_transform_c() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_preferred_transform_c() const {
  return _internal_has_preferred_transform_c();
}
inline void MovieFingerprintTrack::clear_preferred_transform_c() {
  preferred_transform_c_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline double MovieFingerprintTrack::_internal_preferred_transform_c() const {
  return preferred_transform_c_;
}
inline double MovieFingerprintTrack::preferred_transform_c() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.preferred_transform_c)
  return _internal_preferred_transform_c();
}
inline void MovieFingerprintTrack::_internal_set_preferred_transform_c(double value) {
  _has_bits_[0] |= 0x00004000u;
  preferred_transform_c_ = value;
}
inline void MovieFingerprintTrack::set_preferred_transform_c(double value) {
  _internal_set_preferred_transform_c(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.preferred_transform_c)
}

// optional double preferred_transform_d = 15;
inline bool MovieFingerprintTrack::_internal_has_preferred_transform_d() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_preferred_transform_d() const {
  return _internal_has_preferred_transform_d();
}
inline void MovieFingerprintTrack::clear_preferred_transform_d() {
  preferred_transform_d_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline double MovieFingerprintTrack::_internal_preferred_transform_d() const {
  return preferred_transform_d_;
}
inline double MovieFingerprintTrack::preferred_transform_d() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.preferred_transform_d)
  return _internal_preferred_transform_d();
}
inline void MovieFingerprintTrack::_internal_set_preferred_transform_d(double value) {
  _has_bits_[0] |= 0x00008000u;
  preferred_transform_d_ = value;
}
inline void MovieFingerprintTrack::set_preferred_transform_d(double value) {
  _internal_set_preferred_transform_d(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.preferred_transform_d)
}

// optional double preferred_transform_tx = 16;
inline bool MovieFingerprintTrack::_internal_has_preferred_transform_tx() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_preferred_transform_tx() const {
  return _internal_has_preferred_transform_tx();
}
inline void MovieFingerprintTrack::clear_preferred_transform_tx() {
  preferred_transform_tx_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline double MovieFingerprintTrack::_internal_preferred_transform_tx() const {
  return preferred_transform_tx_;
}
inline double MovieFingerprintTrack::preferred_transform_tx() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.preferred_transform_tx)
  return _internal_preferred_transform_tx();
}
inline void MovieFingerprintTrack::_internal_set_preferred_transform_tx(double value) {
  _has_bits_[0] |= 0x00010000u;
  preferred_transform_tx_ = value;
}
inline void MovieFingerprintTrack::set_preferred_transform_tx(double value) {
  _internal_set_preferred_transform_tx(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.preferred_transform_tx)
}

// optional double preferred_transform_ty = 17;
inline bool MovieFingerprintTrack::_internal_has_preferred_transform_ty() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_preferred_transform_ty() const {
  return _internal_has_preferred_transform_ty();
}
inline void MovieFingerprintTrack::clear_preferred_transform_ty() {
  preferred_transform_ty_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline double MovieFingerprintTrack::_internal_preferred_transform_ty() const {
  return preferred_transform_ty_;
}
inline double MovieFingerprintTrack::preferred_transform_ty() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.preferred_transform_ty)
  return _internal_preferred_transform_ty();
}
inline void MovieFingerprintTrack::_internal_set_preferred_transform_ty(double value) {
  _has_bits_[0] |= 0x00020000u;
  preferred_transform_ty_ = value;
}
inline void MovieFingerprintTrack::set_preferred_transform_ty(double value) {
  _internal_set_preferred_transform_ty(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.preferred_transform_ty)
}

// optional double preferred_volume = 18;
inline bool MovieFingerprintTrack::_internal_has_preferred_volume() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_preferred_volume() const {
  return _internal_has_preferred_volume();
}
inline void MovieFingerprintTrack::clear_preferred_volume() {
  preferred_volume_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline double MovieFingerprintTrack::_internal_preferred_volume() const {
  return preferred_volume_;
}
inline double MovieFingerprintTrack::preferred_volume() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.preferred_volume)
  return _internal_preferred_volume();
}
inline void MovieFingerprintTrack::_internal_set_preferred_volume(double value) {
  _has_bits_[0] |= 0x00040000u;
  preferred_volume_ = value;
}
inline void MovieFingerprintTrack::set_preferred_volume(double value) {
  _internal_set_preferred_volume(value);
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.preferred_volume)
}

// optional string language_code = 19;
inline bool MovieFingerprintTrack::_internal_has_language_code() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_language_code() const {
  return _internal_has_language_code();
}
inline void MovieFingerprintTrack::clear_language_code() {
  language_code_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MovieFingerprintTrack::language_code() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.language_code)
  return _internal_language_code();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void MovieFingerprintTrack::set_language_code(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 language_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.language_code)
}
inline std::string* MovieFingerprintTrack::mutable_language_code() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieFingerprintTrack.language_code)
  return _internal_mutable_language_code();
}
inline const std::string& MovieFingerprintTrack::_internal_language_code() const {
  return language_code_.Get();
}
inline void MovieFingerprintTrack::_internal_set_language_code(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  language_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* MovieFingerprintTrack::_internal_mutable_language_code() {
  _has_bits_[0] |= 0x00000004u;
  return language_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MovieFingerprintTrack::release_language_code() {
  // @@protoc_insertion_point(field_release:TSD.MovieFingerprintTrack.language_code)
  if (!_internal_has_language_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return language_code_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MovieFingerprintTrack::set_allocated_language_code(std::string* language_code) {
  if (language_code != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  language_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieFingerprintTrack.language_code)
}

// optional string extended_language_tag = 20;
inline bool MovieFingerprintTrack::_internal_has_extended_language_tag() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MovieFingerprintTrack::has_extended_language_tag() const {
  return _internal_has_extended_language_tag();
}
inline void MovieFingerprintTrack::clear_extended_language_tag() {
  extended_language_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MovieFingerprintTrack::extended_language_tag() const {
  // @@protoc_insertion_point(field_get:TSD.MovieFingerprintTrack.extended_language_tag)
  return _internal_extended_language_tag();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void MovieFingerprintTrack::set_extended_language_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 extended_language_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:TSD.MovieFingerprintTrack.extended_language_tag)
}
inline std::string* MovieFingerprintTrack::mutable_extended_language_tag() {
  // @@protoc_insertion_point(field_mutable:TSD.MovieFingerprintTrack.extended_language_tag)
  return _internal_mutable_extended_language_tag();
}
inline const std::string& MovieFingerprintTrack::_internal_extended_language_tag() const {
  return extended_language_tag_.Get();
}
inline void MovieFingerprintTrack::_internal_set_extended_language_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  extended_language_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* MovieFingerprintTrack::_internal_mutable_extended_language_tag() {
  _has_bits_[0] |= 0x00000008u;
  return extended_language_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MovieFingerprintTrack::release_extended_language_tag() {
  // @@protoc_insertion_point(field_release:TSD.MovieFingerprintTrack.extended_language_tag)
  if (!_internal_has_extended_language_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return extended_language_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MovieFingerprintTrack::set_allocated_extended_language_tag(std::string* extended_language_tag) {
  if (extended_language_tag != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  extended_language_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extended_language_tag,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieFingerprintTrack.extended_language_tag)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSD

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TSD::PointPathSourceArchive_PointPathSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::PointPathSourceArchive_PointPathSourceType>() {
  return ::TSD::PointPathSourceArchive_PointPathSourceType_descriptor();
}
template <> struct is_proto_enum< ::TSD::ScalarPathSourceArchive_ScalarPathSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::ScalarPathSourceArchive_ScalarPathSourceType>() {
  return ::TSD::ScalarPathSourceArchive_ScalarPathSourceType_descriptor();
}
template <> struct is_proto_enum< ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType>() {
  return ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor();
}
template <> struct is_proto_enum< ::TSD::EditableBezierPathSourceArchive_NodeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::EditableBezierPathSourceArchive_NodeType>() {
  return ::TSD::EditableBezierPathSourceArchive_NodeType_descriptor();
}
template <> struct is_proto_enum< ::TSD::GradientArchive_GradientType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::GradientArchive_GradientType>() {
  return ::TSD::GradientArchive_GradientType_descriptor();
}
template <> struct is_proto_enum< ::TSD::ImageFillArchive_ImageFillTechnique> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::ImageFillArchive_ImageFillTechnique>() {
  return ::TSD::ImageFillArchive_ImageFillTechnique_descriptor();
}
template <> struct is_proto_enum< ::TSD::StrokePatternArchive_StrokePatternType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::StrokePatternArchive_StrokePatternType>() {
  return ::TSD::StrokePatternArchive_StrokePatternType_descriptor();
}
template <> struct is_proto_enum< ::TSD::StrokeArchive_LineCap> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::StrokeArchive_LineCap>() {
  return ::TSD::StrokeArchive_LineCap_descriptor();
}
template <> struct is_proto_enum< ::TSD::ShadowArchive_ShadowType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::ShadowArchive_ShadowType>() {
  return ::TSD::ShadowArchive_ShadowType_descriptor();
}
template <> struct is_proto_enum< ::TSD::MovieArchive_MovieLoopOption> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::MovieArchive_MovieLoopOption>() {
  return ::TSD::MovieArchive_MovieLoopOption_descriptor();
}
template <> struct is_proto_enum< ::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType>() {
  return ::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType_descriptor();
}
template <> struct is_proto_enum< ::TSD::GuideArchive_GuideType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::GuideArchive_GuideType>() {
  return ::TSD::GuideArchive_GuideType_descriptor();
}
template <> struct is_proto_enum< ::TSD::UserDefinedGuideArchive_GuideType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::UserDefinedGuideArchive_GuideType>() {
  return ::TSD::UserDefinedGuideArchive_GuideType_descriptor();
}
template <> struct is_proto_enum< ::TSD::LineJoin> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::LineJoin>() {
  return ::TSD::LineJoin_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_TSDArchives_2eproto
